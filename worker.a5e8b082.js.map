{"version":3,"sources":["intel-hex.js","util/tools.tsx","worker/z80-constants.ts","worker/z80.ts","worker/worker.ts"],"names":["const","let","i","l","blockAddr","blocks","block"],"mappings":"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AAA,CAAA,OAAA,IAAA,QAAA,SAAA,QAAA,cAAA,EAdA,MAAM,EAAW,CAAC,EAAc,EAAe,KAChD,IAAA,GAAO,EACJ,MAAA,KACA,IACE,GAAQ,IACb,GAAO,EACP,WAAW,KACT,GAAO,EACH,GAAQ,KACX,MAKF,QAAA,SAAA,EAAA,MAAM,EAAW,CAAC,EAAc,KACjC,IAAA,EAAa,EACV,MAAA,KACL,aAAa,GACb,EAAa,WAAW,IAAM,IAAS,KAJpC,QAAA,SAAA;;ACqgCA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,gBAAA,QAAA,gBAAA,QAAA,gBAAA,QAAA,aAAA,QAAA,iBAAA,EAlhCA,MAAM,EAAc,CACzB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GAkxBK,QAAA,YAAA,EAzwBA,MAAM,EAAe,CAC1B,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,GACA,GACA,GACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,GACA,GACA,GACA,GACA,EACA,GACA,EACA,GACA,GACA,EACA,GACA,GACA,EACA,GACA,EACA,GACA,GACA,GACA,GACA,GACA,EACA,GACA,EACA,EACA,GACA,GACA,GACA,EACA,EACA,GACA,EACA,GACA,GACA,GACA,GACA,GACA,EACA,GACA,EACA,EACA,GACA,EACA,GACA,EACA,EACA,GACA,EACA,GACA,GACA,EACA,GACA,GACA,EACA,GACA,EACA,EACA,GACA,EACA,GACA,EACA,EACA,IAygBK,QAAA,aAAA,EAtgBA,MAAM,EAAkB,CAC7B,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,GACA,GACA,GACA,EACA,GACA,EACA,EACA,GACA,GACA,GACA,GACA,EACA,GACA,EACA,EACA,GACA,GACA,GACA,GACA,EACA,GACA,EACA,EACA,GACA,GACA,GACA,GACA,EACA,GACA,EACA,EACA,GACA,GACA,GACA,GACA,EACA,GACA,EACA,GACA,GACA,GACA,GACA,GACA,EACA,GACA,EACA,GACA,GACA,GACA,GACA,GACA,EACA,GACA,EACA,EACA,GACA,GACA,GACA,GACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,GACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,GACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GAsQK,QAAA,gBAAA,EAnQA,MAAM,EAAkB,CAC7B,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,GAGK,QAAA,gBAAA,EAAA,MAAM,EAAkB,CAC7B,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,GACA,GACA,EACA,EACA,GACA,EACA,EACA,GACA,GACA,GACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,GACA,GACA,GACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,GACA,GACA,GACA,GACA,GACA,GACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,GACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,GAhQK,QAAA,gBAAA;;ACosDA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,KAAA,EAAA,QAAA,UAAA,QAAA,QAAA,QAAA,WAAA,EAptFP,IAAA,EAAA,QAAA,mBAiEA,MAAM,EAAmB,CAAC,EAAU,KAGlC,EAAI,MAAM,GAAe,IAAV,KAAoB,EACnC,EAAI,MAAM,GAAe,GAAV,KAAoB,EACnC,EAAI,MAAM,GAAe,GAAV,KAAoB,EACnC,EAAI,MA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","file":"worker.a5e8b082.js","sourceRoot":"../src","sourcesContent":["\n/**\n * Parser/writer for the \"Intel hex\" format.\n */\n\n/*\n * A regexp that matches lines in a .hex file.\n *\n * One hexadecimal character is matched by \"[0-9A-Fa-f]\".\n * Two hex characters are matched by \"[0-9A-Fa-f]{2}\"\n * Eight or more hex characters are matched by \"[0-9A-Fa-f]{8,}\"\n * A capture group of two hex characters is \"([0-9A-Fa-f]{2})\"\n *\n * Record mark         :\n * 8 or more hex chars  ([0-9A-Fa-f]{8,})\n * Checksum                              ([0-9A-Fa-f]{2})\n * Optional newline                                      (?:\\r\\n|\\r|\\n|)\n */\nconst hexLineRegexp = /:([0-9A-Fa-f]{8,})([0-9A-Fa-f]{2})(?:\\r\\n|\\r|\\n|)/g;\n\n\n// Takes a Uint8Array as input,\n// Returns an integer in the 0-255 range.\nfunction checksum(bytes) {\n    return (-bytes.reduce((sum, v)=>sum + v, 0)) & 0xFF;\n}\n\n// Takes two Uint8Arrays as input,\n// Returns an integer in the 0-255 range.\nfunction checksumTwo(array1, array2) {\n    const partial1 = array1.reduce((sum, v)=>sum + v, 0);\n    const partial2 = array2.reduce((sum, v)=>sum + v, 0);\n    return -( partial1 + partial2 ) & 0xFF;\n}\n\n\n// Trivial utility. Converts a number to hex and pads with zeroes up to 2 characters.\nfunction hexpad(number) {\n    return number.toString(16).toUpperCase().padStart(2, '0');\n}\n\n\n// Polyfill as per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\nNumber.isInteger = Number.isInteger || function(value) {\n    return typeof value === 'number' &&\n    isFinite(value) &&\n    Math.floor(value) === value;\n};\n\n\n/**\n * @class MemoryMap\n *\n * Represents the contents of a memory layout, with main focus into (possibly sparse) blocks of data.\n *<br/>\n * A {@linkcode MemoryMap} acts as a subclass of\n * {@linkcode https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Map|Map}.\n * In every entry of it, the key is the starting address of a data block (an integer number),\n * and the value is the <tt>Uint8Array</tt> with the data for that block.\n *<br/>\n * The main rationale for this is that a .hex file can contain a single block of contiguous\n * data starting at memory address 0 (and it's the common case for simple .hex files),\n * but complex files with several non-contiguous data blocks are also possible, thus\n * the need for a data structure on top of the <tt>Uint8Array</tt>s.\n *<br/>\n * In order to parse <tt>.hex</tt> files, use the {@linkcode MemoryMap.fromHex} <em>static</em> factory\n * method. In order to write <tt>.hex</tt> files, create a new {@linkcode MemoryMap} and call\n * its {@linkcode MemoryMap.asHexString} method.\n *\n * @extends Map\n * @example\n * import MemoryMap from 'nrf-intel-hex';\n *\n * let memMap1 = new MemoryMap();\n * let memMap2 = new MemoryMap([[0, new Uint8Array(1,2,3,4)]]);\n * let memMap3 = new MemoryMap({0: new Uint8Array(1,2,3,4)});\n * let memMap4 = new MemoryMap({0xCF0: new Uint8Array(1,2,3,4)});\n */\nclass MemoryMap {\n    /**\n     * @param {Iterable} blocks The initial value for the memory blocks inside this\n     * <tt>MemoryMap</tt>. All keys must be numeric, and all values must be instances of\n     * <tt>Uint8Array</tt>. Optionally it can also be a plain <tt>Object</tt> with\n     * only numeric keys.\n     */\n    constructor(blocks) {\n        this._blocks = new Map();\n\n        if (blocks && typeof blocks[Symbol.iterator] === 'function') {\n            for (const tuple of blocks) {\n                if (!(tuple instanceof Array) || tuple.length !== 2) {\n                    throw new Error('First parameter to MemoryMap constructor must be an iterable of [addr, bytes] or undefined');\n                }\n                this.set(tuple[0], tuple[1]);\n            }\n        } else if (typeof blocks === 'object') {\n            // Try iterating through the object's keys\n            const addrs = Object.keys(blocks);\n            for (const addr of addrs) {\n                this.set(parseInt(addr), blocks[addr]);\n            }\n\n        } else if (blocks !== undefined && blocks !== null) {\n            throw new Error('First parameter to MemoryMap constructor must be an iterable of [addr, bytes] or undefined');\n        }\n    }\n\n    set(addr, value) {\n        if (!Number.isInteger(addr)) {\n            throw new Error('Address passed to MemoryMap is not an integer');\n        }\n        if (addr < 0) {\n            throw new Error('Address passed to MemoryMap is negative');\n        }\n        if (!(value instanceof Uint8Array)) {\n            throw new Error('Bytes passed to MemoryMap are not an Uint8Array');\n        }\n        return this._blocks.set(addr, value);\n    }\n    // Delegate the following to the 'this._blocks' Map:\n    get(addr)    { return this._blocks.get(addr);    }\n    clear()      { return this._blocks.clear();      }\n    delete(addr) { return this._blocks.delete(addr); }\n    entries()    { return this._blocks.entries();    }\n    forEach(callback, that) { return this._blocks.forEach(callback, that); }\n    has(addr)    { return this._blocks.has(addr);    }\n    keys()       { return this._blocks.keys();       }\n    values()     { return this._blocks.values();     }\n    get size()   { return this._blocks.size;         }\n    [Symbol.iterator]() { return this._blocks[Symbol.iterator](); }\n\n\n    /**\n     * Parses a string containing data formatted in \"Intel HEX\" format, and\n     * returns an instance of {@linkcode MemoryMap}.\n     *<br/>\n     * The insertion order of keys in the {@linkcode MemoryMap} is guaranteed to be strictly\n     * ascending. In other words, when iterating through the {@linkcode MemoryMap}, the addresses\n     * will be ordered in ascending order.\n     *<br/>\n     * The parser has an opinionated behaviour, and will throw a descriptive error if it\n     * encounters some malformed input. Check the project's\n     * {@link https://github.com/NordicSemiconductor/nrf-intel-hex#Features|README file} for details.\n     *<br/>\n     * If <tt>maxBlockSize</tt> is given, any contiguous data block larger than that will\n     * be split in several blocks.\n     *\n     * @param {String} hexText The contents of a .hex file.\n     * @param {Number} [maxBlockSize=Infinity] Maximum size of the returned <tt>Uint8Array</tt>s.\n     *\n     * @return {MemoryMap}\n     *\n     * @example\n     * import MemoryMap from 'nrf-intel-hex';\n     *\n     * let intelHexString =\n     *     \":100000000102030405060708090A0B0C0D0E0F1068\\n\" +\n     *     \":00000001FF\";\n     *\n     * let memMap = MemoryMap.fromHex(intelHexString);\n     *\n     * for (let [address, dataBlock] of memMap) {\n     *     console.log('Data block at ', address, ', bytes: ', dataBlock);\n     * }\n     */\n    static fromHex(hexText, maxBlockSize = Infinity) {\n        const blocks = new MemoryMap();\n\n        let lastCharacterParsed = 0;\n        let matchResult;\n        let recordCount = 0;\n\n        // Upper Linear Base Address, the 16 most significant bits (2 bytes) of\n        // the current 32-bit (4-byte) address\n        // In practice this is a offset that is summed to the \"load offset\" of the\n        // data records\n        let ulba = 0;\n\n        hexLineRegexp.lastIndex = 0; // Reset the regexp, if not it would skip content when called twice\n\n        while ((matchResult = hexLineRegexp.exec(hexText)) !== null) {\n            recordCount++;\n\n            // By default, a regexp loop ignores gaps between matches, but\n            // we want to be aware of them.\n            if (lastCharacterParsed !== matchResult.index) {\n                throw new Error(\n                    'Malformed hex file: Could not parse between characters ' +\n                    lastCharacterParsed +\n                    ' and ' +\n                    matchResult.index +\n                    ' (\"' +\n                    hexText.substring(lastCharacterParsed, Math.min(matchResult.index, lastCharacterParsed + 16)).trim() +\n                    '\")');\n            }\n            lastCharacterParsed = hexLineRegexp.lastIndex;\n\n            // Give pretty names to the match's capture groups\n            const [, recordStr, recordChecksum] = matchResult;\n\n            // String to Uint8Array - https://stackoverflow.com/questions/43131242/how-to-convert-a-hexademical-string-of-data-to-an-arraybuffer-in-javascript\n            const recordBytes = new Uint8Array(recordStr.match(/[\\da-f]{2}/gi).map((h)=>parseInt(h, 16)));\n\n            const recordLength = recordBytes[0];\n            if (recordLength + 4 !== recordBytes.length) {\n                throw new Error('Mismatched record length at record ' + recordCount + ' (' + matchResult[0].trim() + '), expected ' + (recordLength) + ' data bytes but actual length is ' + (recordBytes.length - 4));\n            }\n\n            const cs = checksum(recordBytes);\n            if (parseInt(recordChecksum, 16) !== cs) {\n                throw new Error('Checksum failed at record ' + recordCount + ' (' + matchResult[0].trim() + '), should be ' + cs.toString(16) );\n            }\n\n            const offset = (recordBytes[1] << 8) + recordBytes[2];\n            const recordType = recordBytes[3];\n            const data = recordBytes.subarray(4);\n\n            if (recordType === 0) {\n                // Data record, contains data\n                // Create a new block, at (upper linear base address + offset)\n                if (blocks.has(ulba + offset)) {\n                    throw new Error('Duplicated data at record ' + recordCount + ' (' + matchResult[0].trim() + ')');\n                }\n                if (offset + data.length > 0x10000) {\n                    throw new Error(\n                        'Data at record ' +\n                        recordCount +\n                        ' (' +\n                        matchResult[0].trim() +\n                        ') wraps over 0xFFFF. This would trigger ambiguous behaviour. Please restructure your data so that for every record the data offset plus the data length do not exceed 0xFFFF.');\n                }\n\n                blocks.set( ulba + offset, data );\n\n            } else {\n\n                // All non-data records must have a data offset of zero\n                if (offset !== 0) {\n                    throw new Error('Record ' + recordCount + ' (' + matchResult[0].trim() + ') must have 0000 as data offset.');\n                }\n\n                switch (recordType) {\n                case 1: // EOF\n                    if (lastCharacterParsed !== hexText.length) {\n                        // This record should be at the very end of the string\n                        throw new Error('There is data after an EOF record at record ' + recordCount);\n                    }\n\n                    return blocks.join(maxBlockSize);\n\n                case 2: // Extended Segment Address Record\n                    // Sets the 16 most significant bits of the 20-bit Segment Base\n                    // Address for the subsequent data.\n                    ulba = ((data[0] << 8) + data[1]) << 4;\n                    break;\n\n                case 3: // Start Segment Address Record\n                    // Do nothing. Record type 3 only applies to 16-bit Intel CPUs,\n                    // where it should reset the program counter (CS+IP CPU registers)\n                    break;\n\n                case 4: // Extended Linear Address Record\n                    // Sets the 16 most significant (upper) bits of the 32-bit Linear Address\n                    // for the subsequent data\n                    ulba = ((data[0] << 8) + data[1]) << 16;\n                    break;\n\n                case 5: // Start Linear Address Record\n                    // Do nothing. Record type 5 only applies to 32-bit Intel CPUs,\n                    // where it should reset the program counter (EIP CPU register)\n                    // It might have meaning for other CPU architectures\n                    // (see http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/ka9903.html )\n                    // but will be ignored nonetheless.\n                    break;\n                default:\n                    throw new Error('Invalid record type 0x' + hexpad(recordType) + ' at record ' + recordCount + ' (should be between 0x00 and 0x05)');\n                }\n            }\n        }\n\n        if (recordCount) {\n            throw new Error('No EOF record at end of file');\n        } else {\n            throw new Error('Malformed .hex file, could not parse any registers');\n        }\n    }\n\n\n    /**\n     * Returns a <strong>new</strong> instance of {@linkcode MemoryMap}, containing\n     * the same data, but concatenating together those memory blocks that are adjacent.\n     *<br/>\n     * The insertion order of keys in the {@linkcode MemoryMap} is guaranteed to be strictly\n     * ascending. In other words, when iterating through the {@linkcode MemoryMap}, the addresses\n     * will be ordered in ascending order.\n     *<br/>\n     * If <tt>maxBlockSize</tt> is given, blocks will be concatenated together only\n     * until the joined block reaches this size in bytes. This means that the output\n     * {@linkcode MemoryMap} might have more entries than the input one.\n     *<br/>\n     * If there is any overlap between blocks, an error will be thrown.\n     *<br/>\n     * The returned {@linkcode MemoryMap} will use newly allocated memory.\n     *\n     * @param {Number} [maxBlockSize=Infinity] Maximum size of the <tt>Uint8Array</tt>s in the\n     * returned {@linkcode MemoryMap}.\n     *\n     * @return {MemoryMap}\n     */\n    join(maxBlockSize = Infinity) {\n\n        // First pass, create a Map of addresslength of contiguous blocks\n        const sortedKeys = Array.from(this.keys()).sort((a,b)=>a-b);\n        const blockSizes = new Map();\n        let lastBlockAddr = -1;\n        let lastBlockEndAddr = -1;\n\n        for (let i=0,l=sortedKeys.length; i<l; i++) {\n            const blockAddr = sortedKeys[i];\n            const blockLength = this.get(sortedKeys[i]).length;\n\n            if (lastBlockEndAddr === blockAddr && (lastBlockEndAddr - lastBlockAddr) < maxBlockSize) {\n                // Grow when the previous end address equals the current,\n                // and we don't go over the maximum block size.\n                blockSizes.set(lastBlockAddr, blockSizes.get(lastBlockAddr) + blockLength);\n                lastBlockEndAddr += blockLength;\n            } else if (lastBlockEndAddr <= blockAddr) {\n                // Else mark a new block.\n                blockSizes.set(blockAddr, blockLength);\n                lastBlockAddr = blockAddr;\n                lastBlockEndAddr = blockAddr + blockLength;\n            } else {\n                throw new Error('Overlapping data around address 0x' + blockAddr.toString(16));\n            }\n        }\n\n        // Second pass: allocate memory for the contiguous blocks and copy data around.\n        const mergedBlocks = new MemoryMap();\n        let mergingBlock;\n        let mergingBlockAddr = -1;\n        for (let i=0,l=sortedKeys.length; i<l; i++) {\n            const blockAddr = sortedKeys[i];\n            if (blockSizes.has(blockAddr)) {\n                mergingBlock = new Uint8Array(blockSizes.get(blockAddr));\n                mergedBlocks.set(blockAddr, mergingBlock);\n                mergingBlockAddr = blockAddr;\n            }\n            mergingBlock.set(this.get(blockAddr), blockAddr - mergingBlockAddr);\n        }\n\n        return mergedBlocks;\n    }\n\n    /**\n     * Given a {@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Map|<tt>Map</tt>}\n     * of {@linkcode MemoryMap}s, indexed by a alphanumeric ID,\n     * returns a <tt>Map</tt> of address to tuples (<tt>Arrays</tt>s of length 2) of the form\n     * <tt>(id, Uint8Array)</tt>s.\n     *<br/>\n     * The scenario for using this is having several {@linkcode MemoryMap}s, from several calls to\n     * {@link module:nrf-intel-hex~hexToArrays|hexToArrays}, each having a different identifier.\n     * This function locates where those memory block sets overlap, and returns a <tt>Map</tt>\n     * containing addresses as keys, and arrays as values. Each array will contain 1 or more\n     * <tt>(id, Uint8Array)</tt> tuples: the identifier of the memory block set that has\n     * data in that region, and the data itself. When memory block sets overlap, there will\n     * be more than one tuple.\n     *<br/>\n     * The <tt>Uint8Array</tt>s in the output are\n     * {@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray|subarrays}\n     * of the input data; new memory is <strong>not</strong> allocated for them.\n     *<br/>\n     * The insertion order of keys in the output <tt>Map</tt> is guaranteed to be strictly\n     * ascending. In other words, when iterating through the <tt>Map</tt>, the addresses\n     * will be ordered in ascending order.\n     *<br/>\n     * When two blocks overlap, the corresponding array of tuples will have the tuples ordered\n     * in the insertion order of the input <tt>Map</tt> of block sets.\n     *<br/>\n     *\n     * @param {Map.MemoryMap} memoryMaps The input memory block sets\n     *\n     * @example\n     * import MemoryMap from 'nrf-intel-hex';\n     *\n     * let memMap1 = MemoryMap.fromHex( hexdata1 );\n     * let memMap2 = MemoryMap.fromHex( hexdata2 );\n     * let memMap3 = MemoryMap.fromHex( hexdata3 );\n     *\n     * let maps = new Map([\n     *  ['file A', blocks1],\n     *  ['file B', blocks2],\n     *  ['file C', blocks3]\n     * ]);\n     *\n     * let overlappings = MemoryMap.overlapMemoryMaps(maps);\n     *\n     * for (let [address, tuples] of overlappings) {\n     *     // if 'tuples' has length > 1, there is an overlap starting at 'address'\n     *\n     *     for (let [address, tuples] of overlappings) {\n     *         let [id, bytes] = tuple;\n     *         // 'id' in this example is either 'file A', 'file B' or 'file C'\n     *     }\n     * }\n     * @return {Map.Array<mixed,Uint8Array>} The map of possibly overlapping memory blocks\n     */\n    static overlapMemoryMaps(memoryMaps) {\n        // First pass: create a list of addresses where any block starts or ends.\n        const cuts = new Set();\n        for (const [, blocks] of memoryMaps) {\n            for (const [address, block] of blocks) {\n                cuts.add(address);\n                cuts.add(address + block.length);\n            }\n        }\n\n        const orderedCuts = Array.from(cuts.values()).sort((a,b)=>a-b);\n        const overlaps = new Map();\n\n        // Second pass: iterate through the cuts, get slices of every intersecting blockset\n        for (let i=0, l=orderedCuts.length-1; i<l; i++) {\n            const cut = orderedCuts[i];\n            const nextCut = orderedCuts[i+1];\n            const tuples = [];\n\n            for (const [setId, blocks] of memoryMaps) {\n                // Find the block with the highest address that is equal or lower to\n                // the current cut (if any)\n                const blockAddr = Array.from(blocks.keys()).reduce((acc, val)=>{\n                    if (val > cut) {\n                        return acc;\n                    }\n                    return Math.max( acc, val );\n                }, -1);\n\n                if (blockAddr !== -1) {\n                    const block = blocks.get(blockAddr);\n                    const subBlockStart = cut - blockAddr;\n                    const subBlockEnd = nextCut - blockAddr;\n\n                    if (subBlockStart < block.length) {\n                        tuples.push([ setId, block.subarray(subBlockStart, subBlockEnd) ]);\n                    }\n                }\n            }\n\n            if (tuples.length) {\n                overlaps.set(cut, tuples);\n            }\n        }\n\n        return overlaps;\n    }\n\n\n    /**\n     * Given the output of the {@linkcode MemoryMap.overlapMemoryMaps|overlapMemoryMaps}\n     * (a <tt>Map</tt> of address to an <tt>Array</tt> of <tt>(id, Uint8Array)</tt> tuples),\n     * returns a {@linkcode MemoryMap}. This discards the IDs in the process.\n     *<br/>\n     * The output <tt>Map</tt> contains as many entries as the input one (using the same addresses\n     * as keys), but the value for each entry will be the <tt>Uint8Array</tt> of the <b>last</b>\n     * tuple for each address in the input data.\n     *<br/>\n     * The scenario is wanting to join together several parsed .hex files, not worrying about\n     * their overlaps.\n     *<br/>\n     *\n     * @param {Map.Array<mixed,Uint8Array>} overlaps The (possibly overlapping) input memory blocks\n     * @return {MemoryMap} The flattened memory blocks\n     */\n    static flattenOverlaps(overlaps) {\n        return new MemoryMap(\n            Array.from(overlaps.entries()).map(([address, tuples]) => {\n                return [address, tuples[tuples.length - 1][1] ];\n            })\n        );\n    }\n\n\n    /**\n     * Returns a new instance of {@linkcode MemoryMap}, where:\n     *\n     * <ul>\n     *  <li>Each key (the start address of each <tt>Uint8Array</tt>) is a multiple of\n     *    <tt>pageSize</tt></li>\n     *  <li>The size of each <tt>Uint8Array</tt> is exactly <tt>pageSize</tt></li>\n     *  <li>Bytes from the input map to bytes in the output</li>\n     *  <li>Bytes not in the input are replaced by a padding value</li>\n     * </ul>\n     *<br/>\n     * The scenario is wanting to prepare pages of bytes for a write operation, where the write\n     * operation affects a whole page/sector at once.\n     *<br/>\n     * The insertion order of keys in the output {@linkcode MemoryMap} is guaranteed\n     * to be strictly ascending. In other words, when iterating through the\n     * {@linkcode MemoryMap}, the addresses will be ordered in ascending order.\n     *<br/>\n     * The <tt>Uint8Array</tt>s in the output will be newly allocated.\n     *<br/>\n     *\n     * @param {Number} [pageSize=1024] The size of the output pages, in bytes\n     * @param {Number} [pad=0xFF] The byte value to use for padding\n     * @return {MemoryMap}\n     */\n    paginate( pageSize=1024, pad=0xFF) {\n        if (pageSize <= 0) {\n            throw new Error('Page size must be greater than zero');\n        }\n        const outPages = new MemoryMap();\n        let page;\n\n        const sortedKeys = Array.from(this.keys()).sort((a,b)=>a-b);\n\n        for (let i=0,l=sortedKeys.length; i<l; i++) {\n            const blockAddr = sortedKeys[i];\n            const block = this.get(blockAddr);\n            const blockLength = block.length;\n            const blockEnd = blockAddr + blockLength;\n\n            for (let pageAddr = blockAddr - (blockAddr % pageSize); pageAddr < blockEnd; pageAddr += pageSize) {\n                page = outPages.get(pageAddr);\n                if (!page) {\n                    page = new Uint8Array(pageSize);\n                    page.fill(pad);\n                    outPages.set(pageAddr, page);\n                }\n\n                const offset = pageAddr - blockAddr;\n                let subBlock;\n                if (offset <= 0) {\n                    // First page which intersects the block\n                    subBlock = block.subarray(0, Math.min(pageSize + offset, blockLength));\n                    page.set(subBlock, -offset);\n                } else {\n                    // Any other page which intersects the block\n                    subBlock = block.subarray(offset, offset + Math.min(pageSize, blockLength - offset));\n                    page.set(subBlock, 0);\n                }\n            }\n        }\n\n        return outPages;\n    }\n\n\n    /**\n     * Locates the <tt>Uint8Array</tt> which contains the given offset,\n     * and returns the four bytes held at that offset, as a 32-bit unsigned integer.\n     *\n     *<br/>\n     * Behaviour is similar to {@linkcode https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint32|DataView.prototype.getUint32},\n     * except that this operates over a {@linkcode MemoryMap} instead of\n     * over an <tt>ArrayBuffer</tt>, and that this may return <tt>undefined</tt> if\n     * the address is not <em>entirely</em> contained within one of the <tt>Uint8Array</tt>s.\n     *<br/>\n     *\n     * @param {Number} offset The memory offset to read the data\n     * @param {Boolean} [littleEndian=false] Whether to fetch the 4 bytes as a little- or big-endian integer\n     * @return {Number|undefined} An unsigned 32-bit integer number\n     */\n    getUint32(offset, littleEndian) {\n        const keys = Array.from(this.keys());\n\n        for (let i=0,l=keys.length; i<l; i++) {\n            const blockAddr = keys[i];\n            const block = this.get(blockAddr);\n            const blockLength = block.length;\n            const blockEnd = blockAddr + blockLength;\n\n            if (blockAddr <= offset && (offset+4) <= blockEnd) {\n                return (new DataView(block.buffer, offset - blockAddr, 4)).getUint32(0, littleEndian);\n            }\n        }\n        return;\n    }\n\n\n    /**\n     * Returns a <tt>String</tt> of text representing a .hex file.\n     * <br/>\n     * The writer has an opinionated behaviour. Check the project's\n     * {@link https://github.com/NordicSemiconductor/nrf-intel-hex#Features|README file} for details.\n     *\n     * @param {Number} [lineSize=16] Maximum number of bytes to be encoded in each data record.\n     * Must have a value between 1 and 255, as per the specification.\n     *\n     * @return {String} String of text with the .hex representation of the input binary data\n     *\n     * @example\n     * import MemoryMap from 'nrf-intel-hex';\n     *\n     * let memMap = new MemoryMap();\n     * let bytes = new Uint8Array(....);\n     * memMap.set(0x0FF80000, bytes); // The block with 'bytes' will start at offset 0x0FF80000\n     *\n     * let string = memMap.asHexString();\n     */\n    asHexString(lineSize = 16) {\n        let lowAddress  = 0;    // 16 least significant bits of the current addr\n        let highAddress = -1 << 16; // 16 most significant bits of the current addr\n        const records = [];\n        if (lineSize <=0) {\n            throw new Error('Size of record must be greater than zero');\n        } else if (lineSize > 255) {\n            throw new Error('Size of record must be less than 256');\n        }\n\n        // Placeholders\n        const offsetRecord = new Uint8Array(6);\n        const recordHeader = new Uint8Array(4);\n\n        const sortedKeys = Array.from(this.keys()).sort((a,b)=>a-b);\n        for (let i=0,l=sortedKeys.length; i<l; i++) {\n            const blockAddr = sortedKeys[i];\n            const block = this.get(blockAddr);\n\n            // Sanity checks\n            if (!(block instanceof Uint8Array)) {\n                throw new Error('Block at offset ' + blockAddr + ' is not an Uint8Array');\n            }\n            if (blockAddr < 0) {\n                throw new Error('Block at offset ' + blockAddr + ' has a negative thus invalid address');\n            }\n            const blockSize = block.length;\n            if (!blockSize) { continue; }   // Skip zero-length blocks\n\n\n            if (blockAddr > (highAddress + 0xFFFF)) {\n                // Insert a new 0x04 record to jump to a new 64KiB block\n\n                // Round up the least significant 16 bits - no bitmasks because they trigger\n                // base-2 negative numbers, whereas subtracting the modulo maintains precision\n                highAddress = blockAddr - blockAddr % 0x10000;\n                lowAddress = 0;\n\n                offsetRecord[0] = 2;    // Length\n                offsetRecord[1] = 0;    // Load offset, high byte\n                offsetRecord[2] = 0;    // Load offset, low byte\n                offsetRecord[3] = 4;    // Record type\n                offsetRecord[4] = highAddress >> 24;    // new address offset, high byte\n                offsetRecord[5] = highAddress >> 16;    // new address offset, low byte\n\n                records.push(\n                    ':' +\n                    Array.prototype.map.call(offsetRecord, hexpad).join('') +\n                    hexpad(checksum(offsetRecord))\n                );\n            }\n\n            if (blockAddr < (highAddress + lowAddress)) {\n                throw new Error(\n                    'Block starting at 0x' +\n                    blockAddr.toString(16) +\n                    ' overlaps with a previous block.');\n            }\n\n            lowAddress = blockAddr % 0x10000;\n            let blockOffset = 0;\n            const blockEnd = blockAddr + blockSize;\n            if (blockEnd > 0xFFFFFFFF) {\n                throw new Error('Data cannot be over 0xFFFFFFFF');\n            }\n\n            // Loop for every 64KiB memory segment that spans this block\n            while (highAddress + lowAddress < blockEnd) {\n\n                if (lowAddress > 0xFFFF) {\n                    // Insert a new 0x04 record to jump to a new 64KiB block\n                    highAddress += 1 << 16; // Increase by one\n                    lowAddress = 0;\n\n                    offsetRecord[0] = 2;    // Length\n                    offsetRecord[1] = 0;    // Load offset, high byte\n                    offsetRecord[2] = 0;    // Load offset, low byte\n                    offsetRecord[3] = 4;    // Record type\n                    offsetRecord[4] = highAddress >> 24;    // new address offset, high byte\n                    offsetRecord[5] = highAddress >> 16;    // new address offset, low byte\n\n                    records.push(\n                        ':' +\n                        Array.prototype.map.call(offsetRecord, hexpad).join('') +\n                        hexpad(checksum(offsetRecord))\n                    );\n                }\n\n                let recordSize = -1;\n                // Loop for every record for that spans the current 64KiB memory segment\n                while (lowAddress < 0x10000 && recordSize) {\n                    recordSize = Math.min(\n                        lineSize,                            // Normal case\n                        blockEnd - highAddress - lowAddress, // End of block\n                        0x10000 - lowAddress                 // End of low addresses\n                    );\n\n                    if (recordSize) {\n\n                        recordHeader[0] = recordSize;   // Length\n                        recordHeader[1] = lowAddress >> 8;    // Load offset, high byte\n                        recordHeader[2] = lowAddress;    // Load offset, low byte\n                        recordHeader[3] = 0;    // Record type\n\n                        const subBlock = block.subarray(blockOffset, blockOffset + recordSize);   // Data bytes for this record\n\n                        records.push(\n                            ':' +\n                            Array.prototype.map.call(recordHeader, hexpad).join('') +\n                            Array.prototype.map.call(subBlock, hexpad).join('') +\n                            hexpad(checksumTwo(recordHeader, subBlock))\n                        );\n\n                        blockOffset += recordSize;\n                        lowAddress += recordSize;\n                    }\n                }\n            }\n        }\n\n        records.push(':00000001FF');    // EOF record\n\n        return records.join('\\n');\n    }\n\n\n    /**\n     * Performs a deep copy of the current {@linkcode MemoryMap}, returning a new one\n     * with exactly the same contents, but allocating new memory for each of its\n     * <tt>Uint8Array</tt>s.\n     *\n     * @return {MemoryMap}\n     */\n    clone() {\n        const cloned = new MemoryMap();\n\n        for (let [addr, value] of this) {\n            cloned.set(addr, new Uint8Array(value));\n        }\n\n        return cloned;\n    }\n\n\n    /**\n     * Given one <tt>Uint8Array</tt>, looks through its contents and returns a new\n     * {@linkcode MemoryMap}, stripping away those regions where there are only\n     * padding bytes.\n     * <br/>\n     * The start of the input <tt>Uint8Array</tt> is assumed to be offset zero for the output.\n     * <br/>\n     * The use case here is dumping memory from a working device and try to see the\n     * \"interesting\" memory regions it has. This assumes that there is a constant,\n     * predefined padding byte value being used in the \"non-interesting\" regions.\n     * In other words: this will work as long as the dump comes from a flash memory\n     * which has been previously erased (thus <tt>0xFF</tt>s for padding), or from a\n     * previously blanked HDD (thus <tt>0x00</tt>s for padding).\n     * <br/>\n     * This method uses <tt>subarray</tt> on the input data, and thus does not allocate memory\n     * for the <tt>Uint8Array</tt>s.\n     *\n     * @param {Uint8Array} bytes The input data\n     * @param {Number} [padByte=0xFF] The value of the byte assumed to be used as padding\n     * @param {Number} [minPadLength=64] The minimum number of consecutive pad bytes to\n     * be considered actual padding\n     *\n     * @return {MemoryMap}\n     */\n    static fromPaddedUint8Array(bytes, padByte=0xFF, minPadLength=64) {\n\n        if (!(bytes instanceof Uint8Array)) {\n            throw new Error('Bytes passed to fromPaddedUint8Array are not an Uint8Array');\n        }\n\n        // The algorithm used is nave and checks every byte.\n        // An obvious optimization would be to implement Boyer-Moore\n        // (see https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm )\n        // or otherwise start skipping up to minPadLength bytes when going through a non-pad\n        // byte.\n        // Anyway, we could expect a lot of cases where there is a majority of pad bytes,\n        // and the algorithm should check most of them anyway, so the perf gain is questionable.\n\n        const memMap = new MemoryMap();\n        let consecutivePads = 0;\n        let lastNonPad = -1;\n        let firstNonPad = 0;\n        let skippingBytes = false;\n        const l = bytes.length;\n\n        for (let addr = 0; addr < l; addr++) {\n            const byte = bytes[addr];\n\n            if (byte === padByte) {\n                consecutivePads++;\n                if (consecutivePads >= minPadLength) {\n                    // Edge case: ignore writing a zero-length block when skipping\n                    // bytes at the beginning of the input\n                    if (lastNonPad !== -1) {\n                        /// Add the previous block to the result memMap\n                        memMap.set(firstNonPad, bytes.subarray(firstNonPad, lastNonPad+1));\n                    }\n\n                    skippingBytes = true;\n                }\n            } else {\n                if (skippingBytes) {\n                    skippingBytes = false;\n                    firstNonPad = addr;\n                }\n                lastNonPad = addr;\n                consecutivePads = 0;\n            }\n        }\n\n        // At EOF, add the last block if not skipping bytes already (and input not empty)\n        if (!skippingBytes && lastNonPad !== -1) {\n            memMap.set(firstNonPad, bytes.subarray(firstNonPad, l));\n        }\n\n        return memMap;\n    }\n\n\n    /**\n     * Returns a new instance of {@linkcode MemoryMap}, containing only data between\n     * the addresses <tt>address</tt> and <tt>address + length</tt>.\n     * Behaviour is similar to {@linkcode https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/slice|Array.prototype.slice},\n     * in that the return value is a portion of the current {@linkcode MemoryMap}.\n     *\n     * <br/>\n     * The returned {@linkcode MemoryMap} might be empty.\n     *\n     * <br/>\n     * Internally, this uses <tt>subarray</tt>, so new memory is not allocated.\n     *\n     * @param {Number} address The start address of the slice\n     * @param {Number} length The length of memory map to slice out\n     * @return {MemoryMap}\n     */\n    slice(address, length = Infinity){\n        if (length < 0) {\n            throw new Error('Length of the slice cannot be negative');\n        }\n\n        const sliced = new MemoryMap();\n\n        for (let [blockAddr, block] of this) {\n            const blockLength = block.length;\n\n            if ((blockAddr + blockLength) >= address && blockAddr < (address + length)) {\n                const sliceStart = Math.max(address, blockAddr);\n                const sliceEnd = Math.min(address + length, blockAddr + blockLength);\n                const sliceLength = sliceEnd - sliceStart;\n                const relativeSliceStart = sliceStart - blockAddr;\n\n                if (sliceLength > 0) {\n                    sliced.set(sliceStart, block.subarray(relativeSliceStart, relativeSliceStart + sliceLength));\n                }\n            }\n        }\n        return sliced;\n    }\n\n    /**\n     * Returns a new instance of {@linkcode https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint32|Uint8Array}, containing only data between\n     * the addresses <tt>address</tt> and <tt>address + length</tt>. Any byte without a value\n     * in the input {@linkcode MemoryMap} will have a value of <tt>padByte</tt>.\n     *\n     * <br/>\n     * This method allocates new memory.\n     *\n     * @param {Number} address The start address of the slice\n     * @param {Number} length The length of memory map to slice out\n     * @param {Number} [padByte=0xFF] The value of the byte assumed to be used as padding\n     * @return {MemoryMap}\n     */\n    slicePad(address, length, padByte=0xFF){\n        if (length < 0) {\n            throw new Error('Length of the slice cannot be negative');\n        }\n        \n        const out = (new Uint8Array(length)).fill(padByte);\n\n        for (let [blockAddr, block] of this) {\n            const blockLength = block.length;\n\n            if ((blockAddr + blockLength) >= address && blockAddr < (address + length)) {\n                const sliceStart = Math.max(address, blockAddr);\n                const sliceEnd = Math.min(address + length, blockAddr + blockLength);\n                const sliceLength = sliceEnd - sliceStart;\n                const relativeSliceStart = sliceStart - blockAddr;\n\n                if (sliceLength > 0) {\n                    out.set(block.subarray(relativeSliceStart, relativeSliceStart + sliceLength), sliceStart - address);\n                }\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Checks whether the current memory map contains the one given as a parameter.\n     *\n     * <br/>\n     * \"Contains\" means that all the offsets that have a byte value in the given\n     * memory map have a value in the current memory map, and that the byte values\n     * are the same.\n     *\n     * <br/>\n     * An empty memory map is always contained in any other memory map.\n     *\n     * <br/>\n     * Returns boolean <tt>true</tt> if the memory map is contained, <tt>false</tt>\n     * otherwise.\n     *\n     * @param {MemoryMap} memMap The memory map to check\n     * @return {Boolean}\n     */\n    contains(memMap) {\n        for (let [blockAddr, block] of memMap) {\n\n            const blockLength = block.length;\n\n            const slice = this.slice(blockAddr, blockLength).join().get(blockAddr);\n\n            if ((!slice) || slice.length !== blockLength ) {\n                return false;\n            }\n\n            for (const i in block) {\n                if (block[i] !== slice[i]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n\n\nexport default MemoryMap;\n\n","import { Thunk } from '../types';\n\nexport const throttle = (thunk: Thunk, limit: number, latest?: boolean) => {\n  let wait = false;\n  return () => {\n    if (!wait) {\n      if (!latest) thunk();\n      wait = true;\n      setTimeout(() => {\n        wait = false;\n        if (latest) thunk();\n      }, limit);\n    }\n  };\n};\n\nexport const debounce = (thunk: Thunk, limit: number) => {\n  let inDebounce = 0;\n  return () => {\n    clearTimeout(inDebounce);\n    inDebounce = setTimeout(() => thunk(), limit);\n  };\n};\n","/* eslint-disable max-lines */\n/* eslint-disable camelcase */\n\nexport const parity_bits = [\n  1,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  1,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  0,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  0,\n  1,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  1,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  0,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  0,\n  1,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  1,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  0,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  0,\n  1,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  1,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  0,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  0,\n  1,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  1,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  0,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  0,\n  1,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  1,\n  0,\n  0,\n  1,\n];\n\n// ////////////////////////////////////////////////////////////////////////////\n// These tables contain the number of T cycles used for each instruction.\n// In a few special cases, such as conditional control flow instructions,\n//  additional cycles might be added to these values.\n// The total number of cycles is the return value of run_instruction().\n// ////////////////////////////////////////////////////////////////////////////\nexport const cycle_counts = [\n  4,\n  10,\n  7,\n  6,\n  4,\n  4,\n  7,\n  4,\n  4,\n  11,\n  7,\n  6,\n  4,\n  4,\n  7,\n  4,\n  8,\n  10,\n  7,\n  6,\n  4,\n  4,\n  7,\n  4,\n  12,\n  11,\n  7,\n  6,\n  4,\n  4,\n  7,\n  4,\n  7,\n  10,\n  16,\n  6,\n  4,\n  4,\n  7,\n  4,\n  7,\n  11,\n  16,\n  6,\n  4,\n  4,\n  7,\n  4,\n  7,\n  10,\n  13,\n  6,\n  11,\n  11,\n  10,\n  4,\n  7,\n  11,\n  13,\n  6,\n  4,\n  4,\n  7,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  7,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  7,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  7,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  7,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  7,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  7,\n  4,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  4,\n  7,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  7,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  7,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  7,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  7,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  7,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  7,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  7,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  7,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  7,\n  4,\n  5,\n  10,\n  10,\n  10,\n  10,\n  11,\n  7,\n  11,\n  5,\n  10,\n  10,\n  0,\n  10,\n  17,\n  7,\n  11,\n  5,\n  10,\n  10,\n  11,\n  10,\n  11,\n  7,\n  11,\n  5,\n  4,\n  10,\n  11,\n  10,\n  0,\n  7,\n  11,\n  5,\n  10,\n  10,\n  19,\n  10,\n  11,\n  7,\n  11,\n  5,\n  4,\n  10,\n  4,\n  10,\n  0,\n  7,\n  11,\n  5,\n  10,\n  10,\n  4,\n  10,\n  11,\n  7,\n  11,\n  5,\n  6,\n  10,\n  4,\n  10,\n  0,\n  7,\n  11,\n];\n\nexport const cycle_counts_ed = [\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  12,\n  12,\n  15,\n  20,\n  8,\n  14,\n  8,\n  9,\n  12,\n  12,\n  15,\n  20,\n  8,\n  14,\n  8,\n  9,\n  12,\n  12,\n  15,\n  20,\n  8,\n  14,\n  8,\n  9,\n  12,\n  12,\n  15,\n  20,\n  8,\n  14,\n  8,\n  9,\n  12,\n  12,\n  15,\n  20,\n  8,\n  14,\n  8,\n  18,\n  12,\n  12,\n  15,\n  20,\n  8,\n  14,\n  8,\n  18,\n  12,\n  12,\n  15,\n  20,\n  8,\n  14,\n  8,\n  0,\n  12,\n  12,\n  15,\n  20,\n  8,\n  14,\n  8,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  16,\n  16,\n  16,\n  16,\n  0,\n  0,\n  0,\n  0,\n  16,\n  16,\n  16,\n  16,\n  0,\n  0,\n  0,\n  0,\n  16,\n  16,\n  16,\n  16,\n  0,\n  0,\n  0,\n  0,\n  16,\n  16,\n  16,\n  16,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n];\n\nexport const cycle_counts_cb = [\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  15,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  15,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  15,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  15,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  15,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  15,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  15,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  15,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  12,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  12,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  12,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  12,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  12,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  12,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  12,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  12,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  15,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  15,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  15,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  15,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  15,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  15,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  15,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  15,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  15,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  15,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  15,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  15,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  15,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  15,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  15,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  15,\n  8,\n];\n\nexport const cycle_counts_dd = [\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  15,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  15,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  14,\n  20,\n  10,\n  8,\n  8,\n  11,\n  0,\n  0,\n  15,\n  20,\n  10,\n  8,\n  8,\n  11,\n  0,\n  0,\n  0,\n  0,\n  0,\n  23,\n  23,\n  19,\n  0,\n  0,\n  15,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  8,\n  8,\n  19,\n  0,\n  0,\n  0,\n  0,\n  0,\n  8,\n  8,\n  19,\n  0,\n  0,\n  0,\n  0,\n  0,\n  8,\n  8,\n  19,\n  0,\n  0,\n  0,\n  0,\n  0,\n  8,\n  8,\n  19,\n  0,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  19,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  19,\n  8,\n  19,\n  19,\n  19,\n  19,\n  19,\n  19,\n  0,\n  19,\n  0,\n  0,\n  0,\n  0,\n  8,\n  8,\n  19,\n  0,\n  0,\n  0,\n  0,\n  0,\n  8,\n  8,\n  19,\n  0,\n  0,\n  0,\n  0,\n  0,\n  8,\n  8,\n  19,\n  0,\n  0,\n  0,\n  0,\n  0,\n  8,\n  8,\n  19,\n  0,\n  0,\n  0,\n  0,\n  0,\n  8,\n  8,\n  19,\n  0,\n  0,\n  0,\n  0,\n  0,\n  8,\n  8,\n  19,\n  0,\n  0,\n  0,\n  0,\n  0,\n  8,\n  8,\n  19,\n  0,\n  0,\n  0,\n  0,\n  0,\n  8,\n  8,\n  19,\n  0,\n  0,\n  0,\n  0,\n  0,\n  8,\n  8,\n  19,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  14,\n  0,\n  23,\n  0,\n  15,\n  0,\n  0,\n  0,\n  8,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  10,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n];\n","/* eslint-disable max-lines */\n/* eslint-disable no-lonely-if */\n/* eslint-disable no-param-reassign */\n/* eslint-disable camelcase */\n\nimport {\n  cycle_counts_cb,\n  cycle_counts_dd,\n  cycle_counts,\n  cycle_counts_ed,\n  parity_bits,\n} from './z80-constants';\n\nexport interface Callbacks {\n  mem_read: (addr: number) => any;\n  mem_write: (addr: number, value: number) => any;\n  io_read: (port: number) => any;\n  io_write: (port: number, value: number) => void;\n}\n\nexport interface Cpu {\n  b: number;\n  a: number;\n  c: number;\n  d: number;\n  e: number;\n  h: number;\n  l: number;\n  a_prime: number;\n  b_prime: number;\n  c_prime: number;\n  d_prime: number;\n  e_prime: number;\n  h_prime: number;\n  l_prime: number;\n  ix: number;\n  iy: number;\n  i: number;\n  r: number;\n  sp: number;\n  pc: number;\n  flags: {\n    S: number;\n    Z: number;\n    Y: number;\n    H: number;\n    X: number;\n    P: number;\n    N: number;\n    C: number;\n  };\n  flags_prime: {\n    S: number;\n    Z: number;\n    Y: number;\n    H: number;\n    X: number;\n    P: number;\n    N: number;\n    C: number;\n  };\n  imode: number;\n  iff1: number;\n  iff2: number;\n  halted: boolean;\n  do_delayed_di: boolean;\n  do_delayed_ei: boolean;\n  cycle_counter: number;\n}\n\nconst setFlagsRegister = (cpu: Cpu, operand: number) => {\n  // We need to set the F register, probably for a POP AF,\n  //  so break out the given value into our separate flags.\n  cpu.flags.S = (operand & 0x80) >>> 7;\n  cpu.flags.Z = (operand & 0x40) >>> 6;\n  cpu.flags.Y = (operand & 0x20) >>> 5;\n  cpu.flags.H = (operand & 0x10) >>> 4;\n  cpu.flags.X = (operand & 0x08) >>> 3;\n  cpu.flags.P = (operand & 0x04) >>> 2;\n  cpu.flags.N = (operand & 0x02) >>> 1;\n  cpu.flags.C = operand & 0x01;\n};\n\nconst pushWord = (cpu: Cpu, cb: Callbacks, operand: number) => {\n  // Pretty obvious what this function does; given a 16-bit value,\n  //  decrement the stack pointer, write the high byte to the new\n  //  stack pointer location, then repeat for the low byte.\n  cpu.sp = (cpu.sp - 1) & 0xffff;\n  cb.mem_write(cpu.sp, (operand & 0xff00) >>> 8);\n  cpu.sp = (cpu.sp - 1) & 0xffff;\n  cb.mem_write(cpu.sp, operand & 0x00ff);\n};\n\n// ////////////////////////////////////////////////////////////////////////////\n// The public API functions end here.\n//\n// What begins here are just general utility functions, used variously.\n// ////////////////////////////////////////////////////////////////////////////\nconst decodeInstruction = (cpu: Cpu, cb: Callbacks, opcode: number) => {\n  const get_signed_offset_byte = (value: number) => {\n    // This function requires some explanation.\n    // We just use JavaScript Number variables for our registers,\n    //  not like a typed array or anything.\n    // That means that, when we have a byte value that's supposed\n    //  to represent a signed offset, the value we actually see\n    //  isn't signed at all, it's just a small integer.\n    // So, this function converts that byte into something JavaScript\n    //  will recognize as signed, so we can easily do arithmetic with it.\n    // First, we clamp the value to a single byte, just in case.\n    value &= 0xff;\n    // We don't have to do anything if the value is positive.\n    if (value & 0x80) {\n      // But if the value is negative, we need to manually un-two's-compliment it.\n      // I'm going to assume you can figure out what I meant by that,\n      //  because I don't know how else to explain it.\n      // We could also just do value |= 0xffffff00, but I prefer\n      //  not caring how many bits are in the integer representation\n      //  of a JavaScript number in the currently running browser.\n      value = -((0xff & ~value) + 1);\n    }\n    return value;\n  };\n\n  const get_flags_register = () => {\n    // We need the whole F register for some reason.\n    //  probably a PUSH AF instruction,\n    //  so make the F register out of our separate flags.\n    return (\n      (cpu.flags.S << 7) |\n      (cpu.flags.Z << 6) |\n      (cpu.flags.Y << 5) |\n      (cpu.flags.H << 4) |\n      (cpu.flags.X << 3) |\n      (cpu.flags.P << 2) |\n      (cpu.flags.N << 1) |\n      cpu.flags.C\n    );\n  };\n\n  const get_flags_prime = () => {\n    // This is the same as the above for the F' register.\n    return (\n      (cpu.flags_prime.S << 7) |\n      (cpu.flags_prime.Z << 6) |\n      (cpu.flags_prime.Y << 5) |\n      (cpu.flags_prime.H << 4) |\n      (cpu.flags_prime.X << 3) |\n      (cpu.flags_prime.P << 2) |\n      (cpu.flags_prime.N << 1) |\n      cpu.flags_prime.C\n    );\n  };\n\n  const set_flags_prime = (operand: number) => {\n    // Again, this is the same as the above for F'.\n    cpu.flags_prime.S = (operand & 0x80) >>> 7;\n    cpu.flags_prime.Z = (operand & 0x40) >>> 6;\n    cpu.flags_prime.Y = (operand & 0x20) >>> 5;\n    cpu.flags_prime.H = (operand & 0x10) >>> 4;\n    cpu.flags_prime.X = (operand & 0x08) >>> 3;\n    cpu.flags_prime.P = (operand & 0x04) >>> 2;\n    cpu.flags_prime.N = (operand & 0x02) >>> 1;\n    cpu.flags_prime.C = operand & 0x01;\n  };\n\n  const update_xy_flags = (result: number) => {\n    // Most of the time, the undocumented flags\n    //  (sometimes called X and Y, or 3 and 5),\n    //  take their values from the corresponding bits\n    //  of the result of the instruction,\n    //  or from some other related value.\n    // This is a utility function to set those flags based on those bits.\n    cpu.flags.Y = (result & 0x20) >>> 5;\n    cpu.flags.X = (result & 0x08) >>> 3;\n  };\n\n  const pop_word = () => {\n    // Again, not complicated; read a byte off the top of the stack,\n    //  increment the stack pointer, rinse and repeat.\n    let retval = cb.mem_read(cpu.sp) & 0xff;\n    cpu.sp = (cpu.sp + 1) & 0xffff;\n    retval |= cb.mem_read(cpu.sp) << 8;\n    cpu.sp = (cpu.sp + 1) & 0xffff;\n    return retval;\n  };\n\n  // ////////////////////////////////////////////////////////////////////////////\n  // Now, the way most instructions work in this emulator is that they set up\n  //  their operands according to their addressing mode, and then they call a\n  //  utility function that handles all variations of that instruction.\n  // Those utility functions begin here.\n  // ////////////////////////////////////////////////////////////////////////////\n  const do_conditional_absolute_jump = (condition: boolean) => {\n    // This function implements the JP [condition],nn instructions.\n    if (condition) {\n      // We're taking this jump, so write the new PC,\n      //  and then decrement the thing we just wrote,\n      //  because the instruction decoder increments the PC\n      //  unconditionally at the end of every instruction\n      //  and we need to counteract that so we end up at the jump target.\n      cpu.pc =\n        cb.mem_read((cpu.pc + 1) & 0xffff) |\n        (cb.mem_read((cpu.pc + 2) & 0xffff) << 8);\n      cpu.pc = (cpu.pc - 1) & 0xffff;\n    } else {\n      // We're not taking this jump, just move the PC past the operand.\n      cpu.pc = (cpu.pc + 2) & 0xffff;\n    }\n  };\n\n  const do_conditional_relative_jump = (condition: boolean) => {\n    // This function implements the JR [condition],n instructions.\n    if (condition) {\n      // We need a few more cycles to actually take the jump.\n      cpu.cycle_counter += 5;\n      // Calculate the offset specified by our operand.\n      const offset = get_signed_offset_byte(cb.mem_read((cpu.pc + 1) & 0xffff));\n      // Add the offset to the PC, also skipping past this instruction.\n      cpu.pc = (cpu.pc + offset + 1) & 0xffff;\n    } else {\n      // No jump happening, just skip the operand.\n      cpu.pc = (cpu.pc + 1) & 0xffff;\n    }\n  };\n\n  const do_conditional_call = (condition: boolean) => {\n    // This function is the CALL [condition],nn instructions.\n    // If you've seen the previous functions, you know this drill.\n    if (condition) {\n      cpu.cycle_counter += 7;\n      pushWord(cpu, cb, (cpu.pc + 3) & 0xffff);\n      cpu.pc =\n        cb.mem_read((cpu.pc + 1) & 0xffff) |\n        (cb.mem_read((cpu.pc + 2) & 0xffff) << 8);\n      cpu.pc = (cpu.pc - 1) & 0xffff;\n    } else {\n      cpu.pc = (cpu.pc + 2) & 0xffff;\n    }\n  };\n\n  const do_conditional_return = (condition: boolean) => {\n    if (condition) {\n      cpu.cycle_counter += 6;\n      cpu.pc = (pop_word() - 1) & 0xffff;\n    }\n  };\n\n  const do_reset = (address: number) => {\n    // The RST [address] instructions go through here.\n    pushWord(cpu, cb, (cpu.pc + 1) & 0xffff);\n    cpu.pc = (address - 1) & 0xffff;\n  };\n\n  const do_add = (operand: number) => {\n    // This is the ADD A, [operand] instructions.\n    // We'll do the literal addition, which includes any overflow,\n    //  so that we can more easily figure out whether we had\n    //  an overflow or a carry and set the flags accordingly.\n    const result = cpu.a + operand;\n\n    // The great majority of the work for the arithmetic instructions\n    //  turns out to be setting the flags rather than the actual operation.\n    cpu.flags.S = result & 0x80 ? 1 : 0;\n    cpu.flags.Z = !(result & 0xff) ? 1 : 0;\n    cpu.flags.H = ((operand & 0x0f) + (cpu.a & 0x0f)) & 0x10 ? 1 : 0;\n    // An overflow has happened if the sign bits of the accumulator and the operand\n    //  don't match the sign bit of the result value.\n    cpu.flags.P =\n      (cpu.a & 0x80) === (operand & 0x80) && (cpu.a & 0x80) !== (result & 0x80)\n        ? 1\n        : 0;\n    cpu.flags.N = 0;\n    cpu.flags.C = result & 0x100 ? 1 : 0;\n\n    cpu.a = result & 0xff;\n    update_xy_flags(cpu.a);\n  };\n\n  const do_adc = (operand: number) => {\n    const result = cpu.a + operand + cpu.flags.C;\n\n    cpu.flags.S = result & 0x80 ? 1 : 0;\n    cpu.flags.Z = !(result & 0xff) ? 1 : 0;\n    cpu.flags.H =\n      ((operand & 0x0f) + (cpu.a & 0x0f) + cpu.flags.C) & 0x10 ? 1 : 0;\n    cpu.flags.P =\n      (cpu.a & 0x80) === (operand & 0x80) && (cpu.a & 0x80) !== (result & 0x80)\n        ? 1\n        : 0;\n    cpu.flags.N = 0;\n    cpu.flags.C = result & 0x100 ? 1 : 0;\n\n    cpu.a = result & 0xff;\n    update_xy_flags(cpu.a);\n  };\n\n  const do_sub = (operand: number) => {\n    const result = cpu.a - operand;\n\n    cpu.flags.S = result & 0x80 ? 1 : 0;\n    cpu.flags.Z = !(result & 0xff) ? 1 : 0;\n    cpu.flags.H = ((cpu.a & 0x0f) - (operand & 0x0f)) & 0x10 ? 1 : 0;\n    cpu.flags.P =\n      (cpu.a & 0x80) !== (operand & 0x80) && (cpu.a & 0x80) !== (result & 0x80)\n        ? 1\n        : 0;\n    cpu.flags.N = 1;\n    cpu.flags.C = result & 0x100 ? 1 : 0;\n\n    cpu.a = result & 0xff;\n    update_xy_flags(cpu.a);\n  };\n\n  const do_sbc = (operand: number) => {\n    const result = cpu.a - operand - cpu.flags.C;\n\n    cpu.flags.S = result & 0x80 ? 1 : 0;\n    cpu.flags.Z = !(result & 0xff) ? 1 : 0;\n    cpu.flags.H =\n      ((cpu.a & 0x0f) - (operand & 0x0f) - cpu.flags.C) & 0x10 ? 1 : 0;\n    cpu.flags.P =\n      (cpu.a & 0x80) !== (operand & 0x80) && (cpu.a & 0x80) !== (result & 0x80)\n        ? 1\n        : 0;\n    cpu.flags.N = 1;\n    cpu.flags.C = result & 0x100 ? 1 : 0;\n\n    cpu.a = result & 0xff;\n    update_xy_flags(cpu.a);\n  };\n\n  const do_cp = (operand: number) => {\n    // A compare instruction is just a subtraction that doesn't save the value,\n    //  so we implement it as... a subtraction that doesn't save the value.\n    const temp = cpu.a;\n    do_sub(operand);\n    cpu.a = temp;\n    // Since this instruction has no \"result\" value, the undocumented flags\n    //  are set based on the operand instead.\n    update_xy_flags(operand);\n  };\n\n  const do_and = (operand: number) => {\n    // The logic instructions are all pretty straightforward.\n    cpu.a &= operand & 0xff;\n    cpu.flags.S = cpu.a & 0x80 ? 1 : 0;\n    cpu.flags.Z = !cpu.a ? 1 : 0;\n    cpu.flags.H = 1;\n    cpu.flags.P = parity_bits[cpu.a];\n    cpu.flags.N = 0;\n    cpu.flags.C = 0;\n    update_xy_flags(cpu.a);\n  };\n\n  const do_or = (operand: number) => {\n    cpu.a = (operand | cpu.a) & 0xff;\n    cpu.flags.S = cpu.a & 0x80 ? 1 : 0;\n    cpu.flags.Z = !cpu.a ? 1 : 0;\n    cpu.flags.H = 0;\n    cpu.flags.P = parity_bits[cpu.a];\n    cpu.flags.N = 0;\n    cpu.flags.C = 0;\n    update_xy_flags(cpu.a);\n  };\n\n  const do_xor = (operand: number) => {\n    cpu.a = (operand ^ cpu.a) & 0xff;\n    cpu.flags.S = cpu.a & 0x80 ? 1 : 0;\n    cpu.flags.Z = !cpu.a ? 1 : 0;\n    cpu.flags.H = 0;\n    cpu.flags.P = parity_bits[cpu.a];\n    cpu.flags.N = 0;\n    cpu.flags.C = 0;\n    update_xy_flags(cpu.a);\n  };\n\n  const do_inc = (operand: number) => {\n    let result = operand + 1;\n\n    cpu.flags.S = result & 0x80 ? 1 : 0;\n    cpu.flags.Z = !(result & 0xff) ? 1 : 0;\n    cpu.flags.H = (operand & 0x0f) === 0x0f ? 1 : 0;\n    // It's a good deal easier to detect overflow for an increment/decrement.\n    cpu.flags.P = operand === 0x7f ? 1 : 0;\n    cpu.flags.N = 0;\n\n    result &= 0xff;\n    update_xy_flags(result);\n\n    return result;\n  };\n\n  const do_dec = (operand: number) => {\n    let result = operand - 1;\n\n    cpu.flags.S = result & 0x80 ? 1 : 0;\n    cpu.flags.Z = !(result & 0xff) ? 1 : 0;\n    cpu.flags.H = (operand & 0x0f) === 0x00 ? 1 : 0;\n    cpu.flags.P = operand === 0x80 ? 1 : 0;\n    cpu.flags.N = 1;\n\n    result &= 0xff;\n    update_xy_flags(result);\n\n    return result;\n  };\n\n  const do_hl_add = (operand: number) => {\n    // The HL arithmetic instructions are the same as the A ones,\n    //  just with twice as many bits happening.\n    const hl = cpu.l | (cpu.h << 8);\n    const result = hl + operand;\n\n    cpu.flags.N = 0;\n    cpu.flags.C = result & 0x10000 ? 1 : 0;\n    cpu.flags.H = ((hl & 0x0fff) + (operand & 0x0fff)) & 0x1000 ? 1 : 0;\n\n    cpu.l = result & 0xff;\n    cpu.h = (result & 0xff00) >>> 8;\n\n    update_xy_flags(cpu.h);\n  };\n\n  const do_hl_adc = (operand: number) => {\n    operand += cpu.flags.C;\n    const hl = cpu.l | (cpu.h << 8);\n    const result = hl + operand;\n\n    cpu.flags.S = result & 0x8000 ? 1 : 0;\n    cpu.flags.Z = !(result & 0xffff) ? 1 : 0;\n    cpu.flags.H = ((hl & 0x0fff) + (operand & 0x0fff)) & 0x1000 ? 1 : 0;\n    cpu.flags.P =\n      (hl & 0x8000) === (operand & 0x8000) &&\n      (result & 0x8000) !== (hl & 0x8000)\n        ? 1\n        : 0;\n    cpu.flags.N = 0;\n    cpu.flags.C = result & 0x10000 ? 1 : 0;\n\n    cpu.l = result & 0xff;\n    cpu.h = (result >>> 8) & 0xff;\n\n    update_xy_flags(cpu.h);\n  };\n\n  const do_hl_sbc = (operand: number) => {\n    operand += cpu.flags.C;\n    const hl = cpu.l | (cpu.h << 8);\n    const result = hl - operand;\n\n    cpu.flags.S = result & 0x8000 ? 1 : 0;\n    cpu.flags.Z = !(result & 0xffff) ? 1 : 0;\n    cpu.flags.H = ((hl & 0x0fff) - (operand & 0x0fff)) & 0x1000 ? 1 : 0;\n    cpu.flags.P =\n      (hl & 0x8000) !== (operand & 0x8000) &&\n      (result & 0x8000) !== (hl & 0x8000)\n        ? 1\n        : 0;\n    cpu.flags.N = 1;\n    cpu.flags.C = result & 0x10000 ? 1 : 0;\n\n    cpu.l = result & 0xff;\n    cpu.h = (result >>> 8) & 0xff;\n\n    update_xy_flags(cpu.h);\n  };\n\n  const do_in = (port: number) => {\n    const result = cb.io_read(port);\n\n    cpu.flags.S = result & 0x80 ? 1 : 0;\n    cpu.flags.Z = result ? 0 : 1;\n    cpu.flags.H = 0;\n    cpu.flags.P = parity_bits[result] ? 1 : 0;\n    cpu.flags.N = 0;\n    update_xy_flags(result);\n\n    return result;\n  };\n\n  const do_neg = () => {\n    // This instruction is defined to not alter the register if it === 0x80.\n    if (cpu.a !== 0x80) {\n      // This is a signed operation, so convert A to a signed value.\n      cpu.a = get_signed_offset_byte(cpu.a);\n\n      cpu.a = -cpu.a & 0xff;\n    }\n\n    cpu.flags.S = cpu.a & 0x80 ? 1 : 0;\n    cpu.flags.Z = !cpu.a ? 1 : 0;\n    cpu.flags.H = (-cpu.a & 0x0f) > 0 ? 1 : 0;\n    cpu.flags.P = cpu.a === 0x80 ? 1 : 0;\n    cpu.flags.N = 1;\n    cpu.flags.C = cpu.a ? 1 : 0;\n    update_xy_flags(cpu.a);\n  };\n\n  const do_ldi = () => {\n    // Copy the value that we're supposed to copy.\n    const read_value = cb.mem_read(cpu.l | (cpu.h << 8));\n    cb.mem_write(cpu.e | (cpu.d << 8), read_value);\n\n    // Increment DE and HL, and decrement BC.\n    let result = (cpu.e | (cpu.d << 8)) + 1;\n    cpu.e = result & 0xff;\n    cpu.d = (result & 0xff00) >>> 8;\n    result = (cpu.l | (cpu.h << 8)) + 1;\n    cpu.l = result & 0xff;\n    cpu.h = (result & 0xff00) >>> 8;\n    result = (cpu.c | (cpu.b << 8)) - 1;\n    cpu.c = result & 0xff;\n    cpu.b = (result & 0xff00) >>> 8;\n\n    cpu.flags.H = 0;\n    cpu.flags.P = cpu.c || cpu.b ? 1 : 0;\n    cpu.flags.N = 0;\n    cpu.flags.Y = ((cpu.a + read_value) & 0x02) >>> 1;\n    cpu.flags.X = ((cpu.a + read_value) & 0x08) >>> 3;\n  };\n\n  const do_cpi = () => {\n    const temp_carry = cpu.flags.C;\n    const read_value = cb.mem_read(cpu.l | (cpu.h << 8));\n    do_cp(read_value);\n    cpu.flags.C = temp_carry;\n    cpu.flags.Y = ((cpu.a - read_value - cpu.flags.H) & 0x02) >>> 1;\n    cpu.flags.X = ((cpu.a - read_value - cpu.flags.H) & 0x08) >>> 3;\n\n    let result = (cpu.l | (cpu.h << 8)) + 1;\n    cpu.l = result & 0xff;\n    cpu.h = (result & 0xff00) >>> 8;\n    result = (cpu.c | (cpu.b << 8)) - 1;\n    cpu.c = result & 0xff;\n    cpu.b = (result & 0xff00) >>> 8;\n\n    cpu.flags.P = result ? 1 : 0;\n  };\n\n  const do_ini = () => {\n    cpu.b = do_dec(cpu.b);\n\n    cb.mem_write(cpu.l | (cpu.h << 8), cb.io_read((cpu.b << 8) | cpu.c));\n\n    const result = (cpu.l | (cpu.h << 8)) + 1;\n    cpu.l = result & 0xff;\n    cpu.h = (result & 0xff00) >>> 8;\n\n    cpu.flags.N = 1;\n  };\n\n  const do_outi = () => {\n    cb.io_write((cpu.b << 8) | cpu.c, cb.mem_read(cpu.l | (cpu.h << 8)));\n\n    const result = (cpu.l | (cpu.h << 8)) + 1;\n    cpu.l = result & 0xff;\n    cpu.h = (result & 0xff00) >>> 8;\n\n    cpu.b = do_dec(cpu.b);\n    cpu.flags.N = 1;\n  };\n\n  const do_ldd = () => {\n    cpu.flags.N = 0;\n    cpu.flags.H = 0;\n\n    const read_value = cb.mem_read(cpu.l | (cpu.h << 8));\n    cb.mem_write(cpu.e | (cpu.d << 8), read_value);\n\n    let result = (cpu.e | (cpu.d << 8)) - 1;\n    cpu.e = result & 0xff;\n    cpu.d = (result & 0xff00) >>> 8;\n    result = (cpu.l | (cpu.h << 8)) - 1;\n    cpu.l = result & 0xff;\n    cpu.h = (result & 0xff00) >>> 8;\n    result = (cpu.c | (cpu.b << 8)) - 1;\n    cpu.c = result & 0xff;\n    cpu.b = (result & 0xff00) >>> 8;\n\n    cpu.flags.P = cpu.c || cpu.b ? 1 : 0;\n    cpu.flags.Y = ((cpu.a + read_value) & 0x02) >>> 1;\n    cpu.flags.X = ((cpu.a + read_value) & 0x08) >>> 3;\n  };\n\n  const do_cpd = () => {\n    const temp_carry = cpu.flags.C;\n    const read_value = cb.mem_read(cpu.l | (cpu.h << 8));\n    do_cp(read_value);\n    cpu.flags.C = temp_carry;\n    cpu.flags.Y = ((cpu.a - read_value - cpu.flags.H) & 0x02) >>> 1;\n    cpu.flags.X = ((cpu.a - read_value - cpu.flags.H) & 0x08) >>> 3;\n\n    let result = (cpu.l | (cpu.h << 8)) - 1;\n    cpu.l = result & 0xff;\n    cpu.h = (result & 0xff00) >>> 8;\n    result = (cpu.c | (cpu.b << 8)) - 1;\n    cpu.c = result & 0xff;\n    cpu.b = (result & 0xff00) >>> 8;\n\n    cpu.flags.P = result ? 1 : 0;\n  };\n\n  const do_ind = () => {\n    cpu.b = do_dec(cpu.b);\n\n    cb.mem_write(cpu.l | (cpu.h << 8), cb.io_read((cpu.b << 8) | cpu.c));\n\n    const result = (cpu.l | (cpu.h << 8)) - 1;\n    cpu.l = result & 0xff;\n    cpu.h = (result & 0xff00) >>> 8;\n\n    cpu.flags.N = 1;\n  };\n\n  const do_outd = () => {\n    cb.io_write((cpu.b << 8) | cpu.c, cb.mem_read(cpu.l | (cpu.h << 8)));\n\n    const result = (cpu.l | (cpu.h << 8)) - 1;\n    cpu.l = result & 0xff;\n    cpu.h = (result & 0xff00) >>> 8;\n\n    cpu.b = do_dec(cpu.b);\n    cpu.flags.N = 1;\n  };\n\n  const do_rlc = (operand: number) => {\n    cpu.flags.N = 0;\n    cpu.flags.H = 0;\n\n    cpu.flags.C = (operand & 0x80) >>> 7;\n    operand = ((operand << 1) | cpu.flags.C) & 0xff;\n\n    cpu.flags.Z = !operand ? 1 : 0;\n    cpu.flags.P = parity_bits[operand];\n    cpu.flags.S = operand & 0x80 ? 1 : 0;\n    update_xy_flags(operand);\n\n    return operand;\n  };\n\n  const do_rrc = (operand: number) => {\n    cpu.flags.N = 0;\n    cpu.flags.H = 0;\n\n    cpu.flags.C = operand & 1;\n    operand = ((operand >>> 1) & 0x7f) | (cpu.flags.C << 7);\n\n    cpu.flags.Z = !(operand & 0xff) ? 1 : 0;\n    cpu.flags.P = parity_bits[operand];\n    cpu.flags.S = operand & 0x80 ? 1 : 0;\n    update_xy_flags(operand);\n\n    return operand & 0xff;\n  };\n\n  const do_rl = (operand: number) => {\n    cpu.flags.N = 0;\n    cpu.flags.H = 0;\n\n    const temp = cpu.flags.C;\n    cpu.flags.C = (operand & 0x80) >>> 7;\n    operand = ((operand << 1) | temp) & 0xff;\n\n    cpu.flags.Z = !operand ? 1 : 0;\n    cpu.flags.P = parity_bits[operand];\n    cpu.flags.S = operand & 0x80 ? 1 : 0;\n    update_xy_flags(operand);\n\n    return operand;\n  };\n\n  const do_rr = (operand: number) => {\n    cpu.flags.N = 0;\n    cpu.flags.H = 0;\n\n    const temp = cpu.flags.C;\n    cpu.flags.C = operand & 1;\n    operand = ((operand >>> 1) & 0x7f) | (temp << 7);\n\n    cpu.flags.Z = !operand ? 1 : 0;\n    cpu.flags.P = parity_bits[operand];\n    cpu.flags.S = operand & 0x80 ? 1 : 0;\n    update_xy_flags(operand);\n\n    return operand;\n  };\n\n  const do_sla = (operand: number) => {\n    cpu.flags.N = 0;\n    cpu.flags.H = 0;\n\n    cpu.flags.C = (operand & 0x80) >>> 7;\n    operand = (operand << 1) & 0xff;\n\n    cpu.flags.Z = !operand ? 1 : 0;\n    cpu.flags.P = parity_bits[operand];\n    cpu.flags.S = operand & 0x80 ? 1 : 0;\n    update_xy_flags(operand);\n\n    return operand;\n  };\n\n  const do_sra = (operand: number) => {\n    cpu.flags.N = 0;\n    cpu.flags.H = 0;\n\n    cpu.flags.C = operand & 1;\n    operand = ((operand >>> 1) & 0x7f) | (operand & 0x80);\n\n    cpu.flags.Z = !operand ? 1 : 0;\n    cpu.flags.P = parity_bits[operand];\n    cpu.flags.S = operand & 0x80 ? 1 : 0;\n    update_xy_flags(operand);\n\n    return operand;\n  };\n\n  const do_sll = (operand: number) => {\n    cpu.flags.N = 0;\n    cpu.flags.H = 0;\n\n    cpu.flags.C = (operand & 0x80) >>> 7;\n    operand = ((operand << 1) & 0xff) | 1;\n\n    cpu.flags.Z = !operand ? 1 : 0;\n    cpu.flags.P = parity_bits[operand];\n    cpu.flags.S = operand & 0x80 ? 1 : 0;\n    update_xy_flags(operand);\n\n    return operand;\n  };\n\n  const do_srl = (operand: number) => {\n    cpu.flags.N = 0;\n    cpu.flags.H = 0;\n\n    cpu.flags.C = operand & 1;\n    operand = (operand >>> 1) & 0x7f;\n\n    cpu.flags.Z = !operand ? 1 : 0;\n    cpu.flags.P = parity_bits[operand];\n    cpu.flags.S = 0;\n    update_xy_flags(operand);\n\n    return operand;\n  };\n\n  const do_ix_add = (operand: number) => {\n    cpu.flags.N = 0;\n\n    const result = cpu.ix + operand;\n\n    cpu.flags.C = result & 0x10000 ? 1 : 0;\n    cpu.flags.H = ((cpu.ix & 0xfff) + (operand & 0xfff)) & 0x1000 ? 1 : 0;\n    update_xy_flags((result & 0xff00) >>> 8);\n\n    cpu.ix = result;\n  };\n\n  // ////////////////////////////////////////////////////////////////////////////\n  // Like ED, this table is quite sparse,\n  //  and many of the opcodes here are also undocumented.\n  // The undocumented instructions here are those that deal with only one byte\n  //  of the two-byte IX register; the bytes are designed IXH and IXL here.\n  // ////////////////////////////////////////////////////////////////////////////\n  const dd_instructions: (() => void)[] = [];\n  // 0x09 : ADD IX, BC\n  dd_instructions[0x09] = () => {\n    do_ix_add(cpu.c | (cpu.b << 8));\n  };\n  // 0x19 : ADD IX, DE\n  dd_instructions[0x19] = () => {\n    do_ix_add(cpu.e | (cpu.d << 8));\n  };\n  // 0x21 : LD IX, nn\n  dd_instructions[0x21] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    cpu.ix = cb.mem_read(cpu.pc);\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    cpu.ix |= cb.mem_read(cpu.pc) << 8;\n  };\n  // 0x22 : LD (nn), IX\n  dd_instructions[0x22] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    let address = cb.mem_read(cpu.pc);\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    address |= cb.mem_read(cpu.pc) << 8;\n\n    cb.mem_write(address, cpu.ix & 0xff);\n    cb.mem_write((address + 1) & 0xffff, (cpu.ix >>> 8) & 0xff);\n  };\n  // 0x23 : INC IX\n  dd_instructions[0x23] = () => {\n    cpu.ix = (cpu.ix + 1) & 0xffff;\n  };\n  // 0x24 : INC IXH (Undocumented)\n  dd_instructions[0x24] = () => {\n    cpu.ix = (do_inc(cpu.ix >>> 8) << 8) | (cpu.ix & 0xff);\n  };\n  // 0x25 : DEC IXH (Undocumented)\n  dd_instructions[0x25] = () => {\n    cpu.ix = (do_dec(cpu.ix >>> 8) << 8) | (cpu.ix & 0xff);\n  };\n  // 0x26 : LD IXH, n (Undocumented)\n  dd_instructions[0x26] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    cpu.ix = (cb.mem_read(cpu.pc) << 8) | (cpu.ix & 0xff);\n  };\n  // 0x29 : ADD IX, IX\n  dd_instructions[0x29] = () => {\n    do_ix_add(cpu.ix);\n  };\n  // 0x2a : LD IX, (nn)\n  dd_instructions[0x2a] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    let address = cb.mem_read(cpu.pc);\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    address |= cb.mem_read(cpu.pc) << 8;\n\n    cpu.ix = cb.mem_read(address);\n    cpu.ix |= cb.mem_read((address + 1) & 0xffff) << 8;\n  };\n  // 0x2b : DEC IX\n  dd_instructions[0x2b] = () => {\n    cpu.ix = (cpu.ix - 1) & 0xffff;\n  };\n  // 0x2c : INC IXL (Undocumented)\n  dd_instructions[0x2c] = () => {\n    cpu.ix = do_inc(cpu.ix & 0xff) | (cpu.ix & 0xff00);\n  };\n  // 0x2d : DEC IXL (Undocumented)\n  dd_instructions[0x2d] = () => {\n    cpu.ix = do_dec(cpu.ix & 0xff) | (cpu.ix & 0xff00);\n  };\n  // 0x2e : LD IXL, n (Undocumented)\n  dd_instructions[0x2e] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    cpu.ix = (cb.mem_read(cpu.pc) & 0xff) | (cpu.ix & 0xff00);\n  };\n  // 0x34 : INC (IX+n)\n  dd_instructions[0x34] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const offset = get_signed_offset_byte(cb.mem_read(cpu.pc));\n    const value = cb.mem_read((offset + cpu.ix) & 0xffff);\n    cb.mem_write((offset + cpu.ix) & 0xffff, do_inc(value));\n  };\n  // 0x35 : DEC (IX+n)\n  dd_instructions[0x35] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const offset = get_signed_offset_byte(cb.mem_read(cpu.pc));\n    const value = cb.mem_read((offset + cpu.ix) & 0xffff);\n    cb.mem_write((offset + cpu.ix) & 0xffff, do_dec(value));\n  };\n  // 0x36 : LD (IX+n), n\n  dd_instructions[0x36] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const offset = get_signed_offset_byte(cb.mem_read(cpu.pc));\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    cb.mem_write((cpu.ix + offset) & 0xffff, cb.mem_read(cpu.pc));\n  };\n  // 0x39 : ADD IX, SP\n  dd_instructions[0x39] = () => {\n    do_ix_add(cpu.sp);\n  };\n  // 0x44 : LD B, IXH (Undocumented)\n  dd_instructions[0x44] = () => {\n    cpu.b = (cpu.ix >>> 8) & 0xff;\n  };\n  // 0x45 : LD B, IXL (Undocumented)\n  dd_instructions[0x45] = () => {\n    cpu.b = cpu.ix & 0xff;\n  };\n  // 0x46 : LD B, (IX+n)\n  dd_instructions[0x46] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const offset = get_signed_offset_byte(cb.mem_read(cpu.pc));\n    cpu.b = cb.mem_read((cpu.ix + offset) & 0xffff);\n  };\n  // 0x4c : LD C, IXH (Undocumented)\n  dd_instructions[0x4c] = () => {\n    cpu.c = (cpu.ix >>> 8) & 0xff;\n  };\n  // 0x4d : LD C, IXL (Undocumented)\n  dd_instructions[0x4d] = () => {\n    cpu.c = cpu.ix & 0xff;\n  };\n  // 0x4e : LD C, (IX+n)\n  dd_instructions[0x4e] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const offset = get_signed_offset_byte(cb.mem_read(cpu.pc));\n    cpu.c = cb.mem_read((cpu.ix + offset) & 0xffff);\n  };\n  // 0x54 : LD D, IXH (Undocumented)\n  dd_instructions[0x54] = () => {\n    cpu.d = (cpu.ix >>> 8) & 0xff;\n  };\n  // 0x55 : LD D, IXL (Undocumented)\n  dd_instructions[0x55] = () => {\n    cpu.d = cpu.ix & 0xff;\n  };\n  // 0x56 : LD D, (IX+n)\n  dd_instructions[0x56] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const offset = get_signed_offset_byte(cb.mem_read(cpu.pc));\n    cpu.d = cb.mem_read((cpu.ix + offset) & 0xffff);\n  };\n  // 0x5c : LD E, IXH (Undocumented)\n  dd_instructions[0x5c] = () => {\n    cpu.e = (cpu.ix >>> 8) & 0xff;\n  };\n  // 0x5d : LD E, IXL (Undocumented)\n  dd_instructions[0x5d] = () => {\n    cpu.e = cpu.ix & 0xff;\n  };\n  // 0x5e : LD E, (IX+n)\n  dd_instructions[0x5e] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const offset = get_signed_offset_byte(cb.mem_read(cpu.pc));\n    cpu.e = cb.mem_read((cpu.ix + offset) & 0xffff);\n  };\n  // 0x60 : LD IXH, B (Undocumented)\n  dd_instructions[0x60] = () => {\n    cpu.ix = (cpu.ix & 0xff) | (cpu.b << 8);\n  };\n  // 0x61 : LD IXH, C (Undocumented)\n  dd_instructions[0x61] = () => {\n    cpu.ix = (cpu.ix & 0xff) | (cpu.c << 8);\n  };\n  // 0x62 : LD IXH, D (Undocumented)\n  dd_instructions[0x62] = () => {\n    cpu.ix = (cpu.ix & 0xff) | (cpu.d << 8);\n  };\n  // 0x63 : LD IXH, E (Undocumented)\n  dd_instructions[0x63] = () => {\n    cpu.ix = (cpu.ix & 0xff) | (cpu.e << 8);\n  };\n  // 0x64 : LD IXH, IXH (Undocumented)\n  dd_instructions[0x64] = () => {\n    // No-op.\n  };\n  // 0x65 : LD IXH, IXL (Undocumented)\n  dd_instructions[0x65] = () => {\n    cpu.ix = (cpu.ix & 0xff) | ((cpu.ix & 0xff) << 8);\n  };\n  // 0x66 : LD H, (IX+n)\n  dd_instructions[0x66] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const offset = get_signed_offset_byte(cb.mem_read(cpu.pc));\n    cpu.h = cb.mem_read((cpu.ix + offset) & 0xffff);\n  };\n  // 0x67 : LD IXH, A (Undocumented)\n  dd_instructions[0x67] = () => {\n    cpu.ix = (cpu.ix & 0xff) | (cpu.a << 8);\n  };\n  // 0x68 : LD IXL, B (Undocumented)\n  dd_instructions[0x68] = () => {\n    cpu.ix = (cpu.ix & 0xff00) | cpu.b;\n  };\n  // 0x69 : LD IXL, C (Undocumented)\n  dd_instructions[0x69] = () => {\n    cpu.ix = (cpu.ix & 0xff00) | cpu.c;\n  };\n  // 0x6a : LD IXL, D (Undocumented)\n  dd_instructions[0x6a] = () => {\n    cpu.ix = (cpu.ix & 0xff00) | cpu.d;\n  };\n  // 0x6b : LD IXL, E (Undocumented)\n  dd_instructions[0x6b] = () => {\n    cpu.ix = (cpu.ix & 0xff00) | cpu.e;\n  };\n  // 0x6c : LD IXL, IXH (Undocumented)\n  dd_instructions[0x6c] = () => {\n    cpu.ix = (cpu.ix & 0xff00) | (cpu.ix >>> 8);\n  };\n  // 0x6d : LD IXL, IXL (Undocumented)\n  dd_instructions[0x6d] = () => {\n    // No-op.\n  };\n  // 0x6e : LD L, (IX+n)\n  dd_instructions[0x6e] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const offset = get_signed_offset_byte(cb.mem_read(cpu.pc));\n    cpu.l = cb.mem_read((cpu.ix + offset) & 0xffff);\n  };\n  // 0x6f : LD IXL, A (Undocumented)\n  dd_instructions[0x6f] = () => {\n    cpu.ix = (cpu.ix & 0xff00) | cpu.a;\n  };\n  // 0x70 : LD (IX+n), B\n  dd_instructions[0x70] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const offset = get_signed_offset_byte(cb.mem_read(cpu.pc));\n    cb.mem_write((cpu.ix + offset) & 0xffff, cpu.b);\n  };\n  // 0x71 : LD (IX+n), C\n  dd_instructions[0x71] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const offset = get_signed_offset_byte(cb.mem_read(cpu.pc));\n    cb.mem_write((cpu.ix + offset) & 0xffff, cpu.c);\n  };\n  // 0x72 : LD (IX+n), D\n  dd_instructions[0x72] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const offset = get_signed_offset_byte(cb.mem_read(cpu.pc));\n    cb.mem_write((cpu.ix + offset) & 0xffff, cpu.d);\n  };\n  // 0x73 : LD (IX+n), E\n  dd_instructions[0x73] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const offset = get_signed_offset_byte(cb.mem_read(cpu.pc));\n    cb.mem_write((cpu.ix + offset) & 0xffff, cpu.e);\n  };\n  // 0x74 : LD (IX+n), H\n  dd_instructions[0x74] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const offset = get_signed_offset_byte(cb.mem_read(cpu.pc));\n    cb.mem_write((cpu.ix + offset) & 0xffff, cpu.h);\n  };\n  // 0x75 : LD (IX+n), L\n  dd_instructions[0x75] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const offset = get_signed_offset_byte(cb.mem_read(cpu.pc));\n    cb.mem_write((cpu.ix + offset) & 0xffff, cpu.l);\n  };\n  // 0x77 : LD (IX+n), A\n  dd_instructions[0x77] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const offset = get_signed_offset_byte(cb.mem_read(cpu.pc));\n    cb.mem_write((cpu.ix + offset) & 0xffff, cpu.a);\n  };\n  // 0x7c : LD A, IXH (Undocumented)\n  dd_instructions[0x7c] = () => {\n    cpu.a = (cpu.ix >>> 8) & 0xff;\n  };\n  // 0x7d : LD A, IXL (Undocumented)\n  dd_instructions[0x7d] = () => {\n    cpu.a = cpu.ix & 0xff;\n  };\n  // 0x7e : LD A, (IX+n)\n  dd_instructions[0x7e] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const offset = get_signed_offset_byte(cb.mem_read(cpu.pc));\n    cpu.a = cb.mem_read((cpu.ix + offset) & 0xffff);\n  };\n  // 0x84 : ADD A, IXH (Undocumented)\n  dd_instructions[0x84] = () => {\n    do_add((cpu.ix >>> 8) & 0xff);\n  };\n  // 0x85 : ADD A, IXL (Undocumented)\n  dd_instructions[0x85] = () => {\n    do_add(cpu.ix & 0xff);\n  };\n  // 0x86 : ADD A, (IX+n)\n  dd_instructions[0x86] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const offset = get_signed_offset_byte(cb.mem_read(cpu.pc));\n    do_add(cb.mem_read((cpu.ix + offset) & 0xffff));\n  };\n  // 0x8c : ADC A, IXH (Undocumented)\n  dd_instructions[0x8c] = () => {\n    do_adc((cpu.ix >>> 8) & 0xff);\n  };\n  // 0x8d : ADC A, IXL (Undocumented)\n  dd_instructions[0x8d] = () => {\n    do_adc(cpu.ix & 0xff);\n  };\n  // 0x8e : ADC A, (IX+n)\n  dd_instructions[0x8e] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const offset = get_signed_offset_byte(cb.mem_read(cpu.pc));\n    do_adc(cb.mem_read((cpu.ix + offset) & 0xffff));\n  };\n  // 0x94 : SUB IXH (Undocumented)\n  dd_instructions[0x94] = () => {\n    do_sub((cpu.ix >>> 8) & 0xff);\n  };\n  // 0x95 : SUB IXL (Undocumented)\n  dd_instructions[0x95] = () => {\n    do_sub(cpu.ix & 0xff);\n  };\n  // 0x96 : SUB A, (IX+n)\n  dd_instructions[0x96] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const offset = get_signed_offset_byte(cb.mem_read(cpu.pc));\n    do_sub(cb.mem_read((cpu.ix + offset) & 0xffff));\n  };\n  // 0x9c : SBC IXH (Undocumented)\n  dd_instructions[0x9c] = () => {\n    do_sbc((cpu.ix >>> 8) & 0xff);\n  };\n  // 0x9d : SBC IXL (Undocumented)\n  dd_instructions[0x9d] = () => {\n    do_sbc(cpu.ix & 0xff);\n  };\n  // 0x9e : SBC A, (IX+n)\n  dd_instructions[0x9e] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const offset = get_signed_offset_byte(cb.mem_read(cpu.pc));\n    do_sbc(cb.mem_read((cpu.ix + offset) & 0xffff));\n  };\n  // 0xa4 : AND IXH (Undocumented)\n  dd_instructions[0xa4] = () => {\n    do_and((cpu.ix >>> 8) & 0xff);\n  };\n  // 0xa5 : AND IXL (Undocumented)\n  dd_instructions[0xa5] = () => {\n    do_and(cpu.ix & 0xff);\n  };\n  // 0xa6 : AND A, (IX+n)\n  dd_instructions[0xa6] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const offset = get_signed_offset_byte(cb.mem_read(cpu.pc));\n    do_and(cb.mem_read((cpu.ix + offset) & 0xffff));\n  };\n  // 0xac : XOR IXH (Undocumented)\n  dd_instructions[0xac] = () => {\n    do_xor((cpu.ix >>> 8) & 0xff);\n  };\n  // 0xad : XOR IXL (Undocumented)\n  dd_instructions[0xad] = () => {\n    do_xor(cpu.ix & 0xff);\n  };\n  // 0xae : XOR A, (IX+n)\n  dd_instructions[0xae] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const offset = get_signed_offset_byte(cb.mem_read(cpu.pc));\n    do_xor(cb.mem_read((cpu.ix + offset) & 0xffff));\n  };\n  // 0xb4 : OR IXH (Undocumented)\n  dd_instructions[0xb4] = () => {\n    do_or((cpu.ix >>> 8) & 0xff);\n  };\n  // 0xb5 : OR IXL (Undocumented)\n  dd_instructions[0xb5] = () => {\n    do_or(cpu.ix & 0xff);\n  };\n  // 0xb6 : OR A, (IX+n)\n  dd_instructions[0xb6] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const offset = get_signed_offset_byte(cb.mem_read(cpu.pc));\n    do_or(cb.mem_read((cpu.ix + offset) & 0xffff));\n  };\n  // 0xbc : CP IXH (Undocumented)\n  dd_instructions[0xbc] = () => {\n    do_cp((cpu.ix >>> 8) & 0xff);\n  };\n  // 0xbd : CP IXL (Undocumented)\n  dd_instructions[0xbd] = () => {\n    do_cp(cpu.ix & 0xff);\n  };\n  // 0xbe : CP A, (IX+n)\n  dd_instructions[0xbe] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const offset = get_signed_offset_byte(cb.mem_read(cpu.pc));\n    do_cp(cb.mem_read((cpu.ix + offset) & 0xffff));\n  };\n  // 0xcb : CB Prefix (IX bit instructions)\n  dd_instructions[0xcb] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const offset = get_signed_offset_byte(cb.mem_read(cpu.pc));\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const opcode1 = cb.mem_read(cpu.pc);\n    let value;\n\n    // As with the \"normal\" CB prefix, we implement the DDCB prefix\n    //  by decoding the opcode directly, rather than using a table.\n    if (opcode1 < 0x40) {\n      // Shift and rotate instructions.\n      const ddcb_functions = [\n        do_rlc,\n        do_rrc,\n        do_rl,\n        do_rr,\n        do_sla,\n        do_sra,\n        do_sll,\n        do_srl,\n      ];\n\n      // Most of the opcodes in this range are not valid,\n      //  so we map this opcode onto one of the ones that is.\n      const func = ddcb_functions[(opcode1 & 0x38) >>> 3];\n      value = func(cb.mem_read((cpu.ix + offset) & 0xffff));\n\n      cb.mem_write((cpu.ix + offset) & 0xffff, value);\n    } else {\n      const bit_number = (opcode1 & 0x38) >>> 3;\n\n      if (opcode1 < 0x80) {\n        // BIT\n        cpu.flags.N = 0;\n        cpu.flags.H = 1;\n        cpu.flags.Z = !(\n          cb.mem_read((cpu.ix + offset) & 0xffff) &\n          (1 << bit_number)\n        )\n          ? 1\n          : 0;\n        cpu.flags.P = cpu.flags.Z;\n        cpu.flags.S = bit_number === 7 && !cpu.flags.Z ? 1 : 0;\n      } else if (opcode1 < 0xc0) {\n        // RES\n        value =\n          cb.mem_read((cpu.ix + offset) & 0xffff) & ~(1 << bit_number) & 0xff;\n        cb.mem_write((cpu.ix + offset) & 0xffff, value);\n      } else {\n        // SET\n        value = cb.mem_read((cpu.ix + offset) & 0xffff) | (1 << bit_number);\n        cb.mem_write((cpu.ix + offset) & 0xffff, value);\n      }\n    }\n\n    // This implements the undocumented shift, RES, and SET opcodes,\n    //  which write their result to memory and also to an 8080 register.\n    if (value !== undefined) {\n      if ((opcode1 & 0x07) === 0) cpu.b = value;\n      else if ((opcode1 & 0x07) === 1) cpu.c = value;\n      else if ((opcode1 & 0x07) === 2) cpu.d = value;\n      else if ((opcode1 & 0x07) === 3) cpu.e = value;\n      else if ((opcode1 & 0x07) === 4) cpu.h = value;\n      else if ((opcode1 & 0x07) === 5) cpu.l = value;\n      // 6 is the documented opcode, which doesn't set a register.\n      else if ((opcode1 & 0x07) === 7) cpu.a = value;\n    }\n\n    cpu.cycle_counter += cycle_counts_cb[opcode1] + 8;\n  };\n  // 0xe1 : POP IX\n  dd_instructions[0xe1] = () => {\n    cpu.ix = pop_word();\n  };\n  // 0xe3 : EX (SP), IX\n  dd_instructions[0xe3] = () => {\n    const temp = cpu.ix;\n    cpu.ix = cb.mem_read(cpu.sp);\n    cpu.ix |= cb.mem_read((cpu.sp + 1) & 0xffff) << 8;\n    cb.mem_write(cpu.sp, temp & 0xff);\n    cb.mem_write((cpu.sp + 1) & 0xffff, (temp >>> 8) & 0xff);\n  };\n  // 0xe5 : PUSH IX\n  dd_instructions[0xe5] = () => {\n    pushWord(cpu, cb, cpu.ix);\n  };\n  // 0xe9 : JP (IX)\n  dd_instructions[0xe9] = () => {\n    cpu.pc = (cpu.ix - 1) & 0xffff;\n  };\n  // 0xf9 : LD SP, IX\n  dd_instructions[0xf9] = () => {\n    cpu.sp = cpu.ix;\n  };\n\n  // ////////////////////////////////////////////////////////////////////////////\n  // This table of ED opcodes is pretty sparse;\n  //  there are not very many valid ED-prefixed opcodes in the Z80,\n  //  and many of the ones that are valid are not documented.\n  // ////////////////////////////////////////////////////////////////////////////\n  const ed_instructions: any[] = [];\n  // 0x40 : IN B, (C)\n  ed_instructions[0x40] = () => {\n    cpu.b = do_in((cpu.b << 8) | cpu.c);\n  };\n  // 0x41 : OUT (C), B\n  ed_instructions[0x41] = () => {\n    cb.io_write((cpu.b << 8) | cpu.c, cpu.b);\n  };\n  // 0x42 : SBC HL, BC\n  ed_instructions[0x42] = () => {\n    do_hl_sbc(cpu.c | (cpu.b << 8));\n  };\n  // 0x43 : LD (nn), BC\n  ed_instructions[0x43] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    let address = cb.mem_read(cpu.pc);\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    address |= cb.mem_read(cpu.pc) << 8;\n\n    cb.mem_write(address, cpu.c);\n    cb.mem_write((address + 1) & 0xffff, cpu.b);\n  };\n  // 0x44 : NEG\n  ed_instructions[0x44] = () => do_neg;\n  // 0x45 : RETN\n  ed_instructions[0x45] = () => {\n    cpu.pc = (pop_word() - 1) & 0xffff;\n    cpu.iff1 = cpu.iff2;\n  };\n  // 0x46 : IM 0\n  ed_instructions[0x46] = () => {\n    cpu.imode = 0;\n  };\n  // 0x47 : LD I, A\n  ed_instructions[0x47] = () => {\n    cpu.i = cpu.a;\n  };\n  // 0x48 : IN C, (C)\n  ed_instructions[0x48] = () => {\n    cpu.c = do_in((cpu.b << 8) | cpu.c);\n  };\n  // 0x49 : OUT (C), C\n  ed_instructions[0x49] = () => {\n    cb.io_write((cpu.b << 8) | cpu.c, cpu.c);\n  };\n  // 0x4a : ADC HL, BC\n  ed_instructions[0x4a] = () => {\n    do_hl_adc(cpu.c | (cpu.b << 8));\n  };\n  // 0x4b : LD BC, (nn)\n  ed_instructions[0x4b] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    let address = cb.mem_read(cpu.pc);\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    address |= cb.mem_read(cpu.pc) << 8;\n\n    cpu.c = cb.mem_read(address);\n    cpu.b = cb.mem_read((address + 1) & 0xffff);\n  };\n  // 0x4c : NEG (Undocumented)\n  ed_instructions[0x4c] = () => do_neg;\n  // 0x4d : RETI\n  ed_instructions[0x4d] = () => {\n    cpu.pc = (pop_word() - 1) & 0xffff;\n  };\n  // 0x4e : IM 0 (Undocumented)\n  ed_instructions[0x4e] = () => {\n    cpu.imode = 0;\n  };\n  // 0x4f : LD R, A\n  ed_instructions[0x4f] = () => {\n    cpu.r = cpu.a;\n  };\n  // 0x50 : IN D, (C)\n  ed_instructions[0x50] = () => {\n    cpu.d = do_in((cpu.b << 8) | cpu.c);\n  };\n  // 0x51 : OUT (C), D\n  ed_instructions[0x51] = () => {\n    cb.io_write((cpu.b << 8) | cpu.c, cpu.d);\n  };\n  // 0x52 : SBC HL, DE\n  ed_instructions[0x52] = () => {\n    do_hl_sbc(cpu.e | (cpu.d << 8));\n  };\n  // 0x53 : LD (nn), DE\n  ed_instructions[0x53] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    let address = cb.mem_read(cpu.pc);\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    address |= cb.mem_read(cpu.pc) << 8;\n\n    cb.mem_write(address, cpu.e);\n    cb.mem_write((address + 1) & 0xffff, cpu.d);\n  };\n  // 0x54 : NEG (Undocumented)\n  ed_instructions[0x54] = () => do_neg;\n  // 0x55 : RETN\n  ed_instructions[0x55] = () => {\n    cpu.pc = (pop_word() - 1) & 0xffff;\n    cpu.iff1 = cpu.iff2;\n  };\n  // 0x56 : IM 1\n  ed_instructions[0x56] = () => {\n    cpu.imode = 1;\n  };\n  // 0x57 : LD A, I\n  ed_instructions[0x57] = () => {\n    cpu.a = cpu.i;\n    cpu.flags.S = cpu.i & 0x80 ? 1 : 0;\n    cpu.flags.Z = cpu.i ? 0 : 1;\n    cpu.flags.H = 0;\n    cpu.flags.P = cpu.iff2;\n    cpu.flags.N = 0;\n  };\n  // 0x58 : IN E, (C)\n  ed_instructions[0x58] = () => {\n    cpu.e = do_in((cpu.b << 8) | cpu.c);\n  };\n  // 0x59 : OUT (C), E\n  ed_instructions[0x59] = () => {\n    cb.io_write((cpu.b << 8) | cpu.c, cpu.e);\n  };\n  // 0x5a : ADC HL, DE\n  ed_instructions[0x5a] = () => {\n    do_hl_adc(cpu.e | (cpu.d << 8));\n  };\n  // 0x5b : LD DE, (nn)\n  ed_instructions[0x5b] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    let address = cb.mem_read(cpu.pc);\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    address |= cb.mem_read(cpu.pc) << 8;\n\n    cpu.e = cb.mem_read(address);\n    cpu.d = cb.mem_read((address + 1) & 0xffff);\n  };\n  // 0x5c : NEG (Undocumented)\n  ed_instructions[0x5c] = () => do_neg;\n  // 0x5d : RETN\n  ed_instructions[0x5d] = () => {\n    cpu.pc = (pop_word() - 1) & 0xffff;\n    cpu.iff1 = cpu.iff2;\n  };\n  // 0x5e : IM 2\n  ed_instructions[0x5e] = () => {\n    cpu.imode = 2;\n  };\n  // 0x5f : LD A, R\n  ed_instructions[0x5f] = () => {\n    cpu.a = cpu.r;\n    cpu.flags.P = cpu.iff2;\n  };\n  // 0x60 : IN H, (C)\n  ed_instructions[0x60] = () => {\n    cpu.h = do_in((cpu.b << 8) | cpu.c);\n  };\n  // 0x61 : OUT (C), H\n  ed_instructions[0x61] = () => {\n    cb.io_write((cpu.b << 8) | cpu.c, cpu.h);\n  };\n  // 0x62 : SBC HL, HL\n  ed_instructions[0x62] = () => {\n    do_hl_sbc(cpu.l | (cpu.h << 8));\n  };\n  // 0x63 : LD (nn), HL (Undocumented)\n  ed_instructions[0x63] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    let address = cb.mem_read(cpu.pc);\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    address |= cb.mem_read(cpu.pc) << 8;\n\n    cb.mem_write(address, cpu.l);\n    cb.mem_write((address + 1) & 0xffff, cpu.h);\n  };\n  // 0x64 : NEG (Undocumented)\n  ed_instructions[0x64] = () => do_neg;\n  // 0x65 : RETN\n  ed_instructions[0x65] = () => {\n    cpu.pc = (pop_word() - 1) & 0xffff;\n    cpu.iff1 = cpu.iff2;\n  };\n  // 0x66 : IM 0\n  ed_instructions[0x66] = () => {\n    cpu.imode = 0;\n  };\n  // 0x67 : RRD\n  ed_instructions[0x67] = () => {\n    let hl_value = cb.mem_read(cpu.l | (cpu.h << 8));\n    const temp1 = hl_value & 0x0f;\n    const temp2 = cpu.a & 0x0f;\n    hl_value = ((hl_value & 0xf0) >>> 4) | (temp2 << 4);\n    cpu.a = (cpu.a & 0xf0) | temp1;\n    cb.mem_write(cpu.l | (cpu.h << 8), hl_value);\n\n    cpu.flags.S = cpu.a & 0x80 ? 1 : 0;\n    cpu.flags.Z = cpu.a ? 0 : 1;\n    cpu.flags.H = 0;\n    cpu.flags.P = parity_bits[cpu.a] ? 1 : 0;\n    cpu.flags.N = 0;\n    update_xy_flags(cpu.a);\n  };\n  // 0x68 : IN L, (C)\n  ed_instructions[0x68] = () => {\n    cpu.l = do_in((cpu.b << 8) | cpu.c);\n  };\n  // 0x69 : OUT (C), L\n  ed_instructions[0x69] = () => {\n    cb.io_write((cpu.b << 8) | cpu.c, cpu.l);\n  };\n  // 0x6a : ADC HL, HL\n  ed_instructions[0x6a] = () => {\n    do_hl_adc(cpu.l | (cpu.h << 8));\n  };\n  // 0x6b : LD HL, (nn) (Undocumented)\n  ed_instructions[0x6b] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    let address = cb.mem_read(cpu.pc);\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    address |= cb.mem_read(cpu.pc) << 8;\n\n    cpu.l = cb.mem_read(address);\n    cpu.h = cb.mem_read((address + 1) & 0xffff);\n  };\n  // 0x6c : NEG (Undocumented)\n  ed_instructions[0x6c] = () => do_neg;\n  // 0x6d : RETN\n  ed_instructions[0x6d] = () => {\n    cpu.pc = (pop_word() - 1) & 0xffff;\n    cpu.iff1 = cpu.iff2;\n  };\n  // 0x6e : IM 0 (Undocumented)\n  ed_instructions[0x6e] = () => {\n    cpu.imode = 0;\n  };\n  // 0x6f : RLD\n  ed_instructions[0x6f] = () => {\n    let hl_value = cb.mem_read(cpu.l | (cpu.h << 8));\n    const temp1 = hl_value & 0xf0;\n    const temp2 = cpu.a & 0x0f;\n    hl_value = ((hl_value & 0x0f) << 4) | temp2;\n    cpu.a = (cpu.a & 0xf0) | (temp1 >>> 4);\n    cb.mem_write(cpu.l | (cpu.h << 8), hl_value);\n\n    cpu.flags.S = cpu.a & 0x80 ? 1 : 0;\n    cpu.flags.Z = cpu.a ? 0 : 1;\n    cpu.flags.H = 0;\n    cpu.flags.P = parity_bits[cpu.a] ? 1 : 0;\n    cpu.flags.N = 0;\n    update_xy_flags(cpu.a);\n  };\n  // 0x70 : IN (C) (Undocumented)\n  ed_instructions[0x70] = () => {\n    do_in((cpu.b << 8) | cpu.c);\n  };\n  // 0x71 : OUT (C), 0 (Undocumented)\n  ed_instructions[0x71] = () => {\n    cb.io_write((cpu.b << 8) | cpu.c, 0);\n  };\n  // 0x72 : SBC HL, SP\n  ed_instructions[0x72] = () => {\n    do_hl_sbc(cpu.sp);\n  };\n  // 0x73 : LD (nn), SP\n  ed_instructions[0x73] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    let address = cb.mem_read(cpu.pc);\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    address |= cb.mem_read(cpu.pc) << 8;\n\n    cb.mem_write(address, cpu.sp & 0xff);\n    cb.mem_write((address + 1) & 0xffff, (cpu.sp >>> 8) & 0xff);\n  };\n  // 0x74 : NEG (Undocumented)\n  ed_instructions[0x74] = () => do_neg;\n  // 0x75 : RETN\n  ed_instructions[0x75] = () => {\n    cpu.pc = (pop_word() - 1) & 0xffff;\n    cpu.iff1 = cpu.iff2;\n  };\n  // 0x76 : IM 1\n  ed_instructions[0x76] = () => {\n    cpu.imode = 1;\n  };\n  // 0x78 : IN A, (C)\n  ed_instructions[0x78] = () => {\n    cpu.a = do_in((cpu.b << 8) | cpu.c);\n  };\n  // 0x79 : OUT (C), A\n  ed_instructions[0x79] = () => {\n    cb.io_write((cpu.b << 8) | cpu.c, cpu.a);\n  };\n  // 0x7a : ADC HL, SP\n  ed_instructions[0x7a] = () => {\n    do_hl_adc(cpu.sp);\n  };\n  // 0x7b : LD SP, (nn)\n  ed_instructions[0x7b] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    let address = cb.mem_read(cpu.pc);\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    address |= cb.mem_read(cpu.pc) << 8;\n\n    cpu.sp = cb.mem_read(address);\n    cpu.sp |= cb.mem_read((address + 1) & 0xffff) << 8;\n  };\n  // 0x7c : NEG (Undocumented)\n  ed_instructions[0x7c] = () => do_neg;\n  // 0x7d : RETN\n  ed_instructions[0x7d] = () => {\n    cpu.pc = (pop_word() - 1) & 0xffff;\n    cpu.iff1 = cpu.iff2;\n  };\n  // 0x7e : IM 2\n  ed_instructions[0x7e] = () => {\n    cpu.imode = 2;\n  };\n  // 0xa0 : LDI\n  ed_instructions[0xa0] = () => {\n    do_ldi();\n  };\n  // 0xa1 : CPI\n  ed_instructions[0xa1] = () => {\n    do_cpi();\n  };\n  // 0xa2 : INI\n  ed_instructions[0xa2] = () => {\n    do_ini();\n  };\n  // 0xa3 : OUTI\n  ed_instructions[0xa3] = () => {\n    do_outi();\n  };\n  // 0xa8 : LDD\n  ed_instructions[0xa8] = () => {\n    do_ldd();\n  };\n  // 0xa9 : CPD\n  ed_instructions[0xa9] = () => {\n    do_cpd();\n  };\n  // 0xaa : IND\n  ed_instructions[0xaa] = () => {\n    do_ind();\n  };\n  // 0xab : OUTD\n  ed_instructions[0xab] = () => {\n    do_outd();\n  };\n  // 0xb0 : LDIR\n  ed_instructions[0xb0] = () => {\n    do_ldi();\n    if (cpu.b || cpu.c) {\n      cpu.cycle_counter += 5;\n      cpu.pc = (cpu.pc - 2) & 0xffff;\n    }\n  };\n  // 0xb1 : CPIR\n  ed_instructions[0xb1] = () => {\n    do_cpi();\n    if (!cpu.flags.Z && (cpu.b || cpu.c)) {\n      cpu.cycle_counter += 5;\n      cpu.pc = (cpu.pc - 2) & 0xffff;\n    }\n  };\n  // 0xb2 : INIR\n  ed_instructions[0xb2] = () => {\n    do_ini();\n    if (cpu.b) {\n      cpu.cycle_counter += 5;\n      cpu.pc = (cpu.pc - 2) & 0xffff;\n    }\n  };\n  // 0xb3 : OTIR\n  ed_instructions[0xb3] = () => {\n    do_outi();\n    if (cpu.b) {\n      cpu.cycle_counter += 5;\n      cpu.pc = (cpu.pc - 2) & 0xffff;\n    }\n  };\n  // 0xb8 : LDDR\n  ed_instructions[0xb8] = () => {\n    do_ldd();\n    if (cpu.b || cpu.c) {\n      cpu.cycle_counter += 5;\n      cpu.pc = (cpu.pc - 2) & 0xffff;\n    }\n  };\n  // 0xb9 : CPDR\n  ed_instructions[0xb9] = () => {\n    do_cpd();\n    if (!cpu.flags.Z && (cpu.b || cpu.c)) {\n      cpu.cycle_counter += 5;\n      cpu.pc = (cpu.pc - 2) & 0xffff;\n    }\n  };\n  // 0xba : INDR\n  ed_instructions[0xba] = () => {\n    do_ind();\n    if (cpu.b) {\n      cpu.cycle_counter += 5;\n      cpu.pc = (cpu.pc - 2) & 0xffff;\n    }\n  };\n  // 0xbb : OTDR\n  ed_instructions[0xbb] = () => {\n    do_outd();\n    if (cpu.b) {\n      cpu.cycle_counter += 5;\n      cpu.pc = (cpu.pc - 2) & 0xffff;\n    }\n  };\n\n  // ////////////////////////////////////////////////////////////////////////////\n  // This table contains the implementations for the instructions that weren't\n  //  implemented directly in the decoder (everything but the 8-bit\n  //  register loads and the accumulator ALU instructions, in other words).\n  // Similar tables for the ED and DD/FD prefixes follow this one.\n  // ////////////////////////////////////////////////////////////////////////////\n  const instructions: any[] = [];\n\n  // 0x00 : NOP\n  instructions[0x00] = () => {\n    // do nothing\n  };\n  // 0x01 : LD BC, nn\n  instructions[0x01] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    cpu.c = cb.mem_read(cpu.pc);\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    cpu.b = cb.mem_read(cpu.pc);\n  };\n  // 0x02 : LD (BC), A\n  instructions[0x02] = () => {\n    cb.mem_write(cpu.c | (cpu.b << 8), cpu.a);\n  };\n  // 0x03 : INC BC\n  instructions[0x03] = () => {\n    let result = cpu.c | (cpu.b << 8);\n    result += 1;\n    cpu.c = result & 0xff;\n    cpu.b = (result & 0xff00) >>> 8;\n  };\n  // 0x04 : INC B\n  instructions[0x04] = () => {\n    cpu.b = do_inc(cpu.b);\n  };\n  // 0x05 : DEC B\n  instructions[0x05] = () => {\n    cpu.b = do_dec(cpu.b);\n  };\n  // 0x06 : LD B, n\n  instructions[0x06] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    cpu.b = cb.mem_read(cpu.pc);\n  };\n  // 0x07 : RLCA\n  instructions[0x07] = () => {\n    // This instruction is implemented as a special case of the\n    //  more general Z80-specific RLC instruction.\n    // Specifially, RLCA is a version of RLC A that affects fewer flags.\n    // The same applies to RRCA, RLA, and RRA.\n    const temp_s = cpu.flags.S;\n    const temp_z = cpu.flags.Z;\n    const temp_p = cpu.flags.P;\n    cpu.a = do_rlc(cpu.a);\n    cpu.flags.S = temp_s;\n    cpu.flags.Z = temp_z;\n    cpu.flags.P = temp_p;\n  };\n  // 0x08 : EX AF, AF'\n  instructions[0x08] = () => {\n    let temp = cpu.a;\n    cpu.a = cpu.a_prime;\n    cpu.a_prime = temp;\n\n    temp = get_flags_register();\n    setFlagsRegister(cpu, get_flags_prime());\n    set_flags_prime(temp);\n  };\n  // 0x09 : ADD HL, BC\n  instructions[0x09] = () => {\n    do_hl_add(cpu.c | (cpu.b << 8));\n  };\n  // 0x0a : LD A, (BC)\n  instructions[0x0a] = () => {\n    cpu.a = cb.mem_read(cpu.c | (cpu.b << 8));\n  };\n  // 0x0b : DEC BC\n  instructions[0x0b] = () => {\n    let result = cpu.c | (cpu.b << 8);\n    result -= 1;\n    cpu.c = result & 0xff;\n    cpu.b = (result & 0xff00) >>> 8;\n  };\n  // 0x0c : INC C\n  instructions[0x0c] = () => {\n    cpu.c = do_inc(cpu.c);\n  };\n  // 0x0d : DEC C\n  instructions[0x0d] = () => {\n    cpu.c = do_dec(cpu.c);\n  };\n  // 0x0e : LD C, n\n  instructions[0x0e] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    cpu.c = cb.mem_read(cpu.pc);\n  };\n  // 0x0f : RRCA\n  instructions[0x0f] = () => {\n    const temp_s = cpu.flags.S;\n    const temp_z = cpu.flags.Z;\n    const temp_p = cpu.flags.P;\n    cpu.a = do_rrc(cpu.a);\n    cpu.flags.S = temp_s;\n    cpu.flags.Z = temp_z;\n    cpu.flags.P = temp_p;\n  };\n  // 0x10 : DJNZ nn\n  instructions[0x10] = () => {\n    cpu.b = (cpu.b - 1) & 0xff;\n    do_conditional_relative_jump(cpu.b !== 0);\n  };\n  // 0x11 : LD DE, nn\n  instructions[0x11] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    cpu.e = cb.mem_read(cpu.pc);\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    cpu.d = cb.mem_read(cpu.pc);\n  };\n  // 0x12 : LD (DE), A\n  instructions[0x12] = () => {\n    cb.mem_write(cpu.e | (cpu.d << 8), cpu.a);\n  };\n  // 0x13 : INC DE\n  instructions[0x13] = () => {\n    let result = cpu.e | (cpu.d << 8);\n    result += 1;\n    cpu.e = result & 0xff;\n    cpu.d = (result & 0xff00) >>> 8;\n  };\n  // 0x14 : INC D\n  instructions[0x14] = () => {\n    cpu.d = do_inc(cpu.d);\n  };\n  // 0x15 : DEC D\n  instructions[0x15] = () => {\n    cpu.d = do_dec(cpu.d);\n  };\n  // 0x16 : LD D, n\n  instructions[0x16] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    cpu.d = cb.mem_read(cpu.pc);\n  };\n  // 0x17 : RLA\n  instructions[0x17] = () => {\n    const temp_s = cpu.flags.S;\n    const temp_z = cpu.flags.Z;\n    const temp_p = cpu.flags.P;\n    cpu.a = do_rl(cpu.a);\n    cpu.flags.S = temp_s;\n    cpu.flags.Z = temp_z;\n    cpu.flags.P = temp_p;\n  };\n  // 0x18 : JR n\n  instructions[0x18] = () => {\n    const offset = get_signed_offset_byte(cb.mem_read((cpu.pc + 1) & 0xffff));\n    cpu.pc = (cpu.pc + offset + 1) & 0xffff;\n  };\n  // 0x19 : ADD HL, DE\n  instructions[0x19] = () => {\n    do_hl_add(cpu.e | (cpu.d << 8));\n  };\n  // 0x1a : LD A, (DE)\n  instructions[0x1a] = () => {\n    cpu.a = cb.mem_read(cpu.e | (cpu.d << 8));\n  };\n  // 0x1b : DEC DE\n  instructions[0x1b] = () => {\n    let result = cpu.e | (cpu.d << 8);\n    result -= 1;\n    cpu.e = result & 0xff;\n    cpu.d = (result & 0xff00) >>> 8;\n  };\n  // 0x1c : INC E\n  instructions[0x1c] = () => {\n    cpu.e = do_inc(cpu.e);\n  };\n  // 0x1d : DEC E\n  instructions[0x1d] = () => {\n    cpu.e = do_dec(cpu.e);\n  };\n  // 0x1e : LD E, n\n  instructions[0x1e] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    cpu.e = cb.mem_read(cpu.pc);\n  };\n  // 0x1f : RRA\n  instructions[0x1f] = () => {\n    const temp_s = cpu.flags.S;\n    const temp_z = cpu.flags.Z;\n    const temp_p = cpu.flags.P;\n    cpu.a = do_rr(cpu.a);\n    cpu.flags.S = temp_s;\n    cpu.flags.Z = temp_z;\n    cpu.flags.P = temp_p;\n  };\n  // 0x20 : JR NZ, n\n  instructions[0x20] = () => {\n    do_conditional_relative_jump(!cpu.flags.Z);\n  };\n  // 0x21 : LD HL, nn\n  instructions[0x21] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    cpu.l = cb.mem_read(cpu.pc);\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    cpu.h = cb.mem_read(cpu.pc);\n  };\n  // 0x22 : LD (nn), HL\n  instructions[0x22] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    let address = cb.mem_read(cpu.pc);\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    address |= cb.mem_read(cpu.pc) << 8;\n\n    cb.mem_write(address, cpu.l);\n    cb.mem_write((address + 1) & 0xffff, cpu.h);\n  };\n  // 0x23 : INC HL\n  instructions[0x23] = () => {\n    let result = cpu.l | (cpu.h << 8);\n    result += 1;\n    cpu.l = result & 0xff;\n    cpu.h = (result & 0xff00) >>> 8;\n  };\n  // 0x24 : INC H\n  instructions[0x24] = () => {\n    cpu.h = do_inc(cpu.h);\n  };\n  // 0x25 : DEC H\n  instructions[0x25] = () => {\n    cpu.h = do_dec(cpu.h);\n  };\n  // 0x26 : LD H, n\n  instructions[0x26] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    cpu.h = cb.mem_read(cpu.pc);\n  };\n  // 0x27 : DAA\n  instructions[0x27] = () => {\n    let temp = cpu.a;\n    if (!cpu.flags.N) {\n      if (cpu.flags.H || (cpu.a & 0x0f) > 9) temp += 0x06;\n      if (cpu.flags.C || cpu.a > 0x99) temp += 0x60;\n    } else {\n      if (cpu.flags.H || (cpu.a & 0x0f) > 9) temp -= 0x06;\n      if (cpu.flags.C || cpu.a > 0x99) temp -= 0x60;\n    }\n\n    cpu.flags.S = temp & 0x80 ? 1 : 0;\n    cpu.flags.Z = !(temp & 0xff) ? 1 : 0;\n    cpu.flags.H = (cpu.a & 0x10) ^ (temp & 0x10) ? 1 : 0;\n    cpu.flags.P = parity_bits[temp & 0xff];\n    // DAA never clears the carry flag if it was already set,\n    //  but it is able to set the carry flag if it was clear.\n    // Don't ask me, I don't know.\n    // Note also that we check for a BCD carry, instead of the usual.\n    cpu.flags.C = cpu.flags.C || cpu.a > 0x99 ? 1 : 0;\n\n    cpu.a = temp & 0xff;\n\n    update_xy_flags(cpu.a);\n  };\n  // 0x28 : JR Z, n\n  instructions[0x28] = () => {\n    do_conditional_relative_jump(!!cpu.flags.Z);\n  };\n  // 0x29 : ADD HL, HL\n  instructions[0x29] = () => {\n    do_hl_add(cpu.l | (cpu.h << 8));\n  };\n  // 0x2a : LD HL, (nn)\n  instructions[0x2a] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    let address = cb.mem_read(cpu.pc);\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    address |= cb.mem_read(cpu.pc) << 8;\n\n    cpu.l = cb.mem_read(address);\n    cpu.h = cb.mem_read((address + 1) & 0xffff);\n  };\n  // 0x2b : DEC HL\n  instructions[0x2b] = () => {\n    let result = cpu.l | (cpu.h << 8);\n    result -= 1;\n    cpu.l = result & 0xff;\n    cpu.h = (result & 0xff00) >>> 8;\n  };\n  // 0x2c : INC L\n  instructions[0x2c] = () => {\n    cpu.l = do_inc(cpu.l);\n  };\n  // 0x2d : DEC L\n  instructions[0x2d] = () => {\n    cpu.l = do_dec(cpu.l);\n  };\n  // 0x2e : LD L, n\n  instructions[0x2e] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    cpu.l = cb.mem_read(cpu.pc);\n  };\n  // 0x2f : CPL\n  instructions[0x2f] = () => {\n    cpu.a = ~cpu.a & 0xff;\n    cpu.flags.N = 1;\n    cpu.flags.H = 1;\n    update_xy_flags(cpu.a);\n  };\n  // 0x30 : JR NC, n\n  instructions[0x30] = () => {\n    do_conditional_relative_jump(!cpu.flags.C);\n  };\n  // 0x31 : LD SP, nn\n  instructions[0x31] = () => {\n    cpu.sp =\n      cb.mem_read((cpu.pc + 1) & 0xffff) |\n      (cb.mem_read((cpu.pc + 2) & 0xffff) << 8);\n    cpu.pc = (cpu.pc + 2) & 0xffff;\n  };\n  // 0x32 : LD (nn), A\n  instructions[0x32] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    let address = cb.mem_read(cpu.pc);\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    address |= cb.mem_read(cpu.pc) << 8;\n\n    cb.mem_write(address, cpu.a);\n  };\n  // 0x33 : INC SP\n  instructions[0x33] = () => {\n    cpu.sp = (cpu.sp + 1) & 0xffff;\n  };\n  // 0x34 : INC (HL)\n  instructions[0x34] = () => {\n    const address = cpu.l | (cpu.h << 8);\n    cb.mem_write(address, do_inc(cb.mem_read(address)));\n  };\n  // 0x35 : DEC (HL)\n  instructions[0x35] = () => {\n    const address = cpu.l | (cpu.h << 8);\n    cb.mem_write(address, do_dec(cb.mem_read(address)));\n  };\n  // 0x36 : LD (HL), n\n  instructions[0x36] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    cb.mem_write(cpu.l | (cpu.h << 8), cb.mem_read(cpu.pc));\n  };\n  // 0x37 : SCF\n  instructions[0x37] = () => {\n    cpu.flags.N = 0;\n    cpu.flags.H = 0;\n    cpu.flags.C = 1;\n    update_xy_flags(cpu.a);\n  };\n  // 0x38 : JR C, n\n  instructions[0x38] = () => {\n    do_conditional_relative_jump(!!cpu.flags.C);\n  };\n  // 0x39 : ADD HL, SP\n  instructions[0x39] = () => {\n    do_hl_add(cpu.sp);\n  };\n  // 0x3a : LD A, (nn)\n  instructions[0x3a] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    let address = cb.mem_read(cpu.pc);\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    address |= cb.mem_read(cpu.pc) << 8;\n\n    cpu.a = cb.mem_read(address);\n  };\n  // 0x3b : DEC SP\n  instructions[0x3b] = () => {\n    cpu.sp = (cpu.sp - 1) & 0xffff;\n  };\n  // 0x3c : INC A\n  instructions[0x3c] = () => {\n    cpu.a = do_inc(cpu.a);\n  };\n  // 0x3d : DEC A\n  instructions[0x3d] = () => {\n    cpu.a = do_dec(cpu.a);\n  };\n  // 0x3e : LD A, n\n  instructions[0x3e] = () => {\n    cpu.a = cb.mem_read((cpu.pc + 1) & 0xffff);\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n  };\n  // 0x3f : CCF\n  instructions[0x3f] = () => {\n    cpu.flags.N = 0;\n    cpu.flags.H = cpu.flags.C;\n    cpu.flags.C = cpu.flags.C ? 0 : 1;\n    update_xy_flags(cpu.a);\n  };\n  // 0xc0 : RET NZ\n  instructions[0xc0] = () => {\n    do_conditional_return(!cpu.flags.Z);\n  };\n  // 0xc1 : POP BC\n  instructions[0xc1] = () => {\n    const result = pop_word();\n    cpu.c = result & 0xff;\n    cpu.b = (result & 0xff00) >>> 8;\n  };\n  // 0xc2 : JP NZ, nn\n  instructions[0xc2] = () => {\n    do_conditional_absolute_jump(!cpu.flags.Z);\n  };\n  // 0xc3 : JP nn\n  instructions[0xc3] = () => {\n    cpu.pc =\n      cb.mem_read((cpu.pc + 1) & 0xffff) |\n      (cb.mem_read((cpu.pc + 2) & 0xffff) << 8);\n    cpu.pc = (cpu.pc - 1) & 0xffff;\n  };\n  // 0xc4 : CALL NZ, nn\n  instructions[0xc4] = () => {\n    do_conditional_call(!cpu.flags.Z);\n  };\n  // 0xc5 : PUSH BC\n  instructions[0xc5] = () => {\n    pushWord(cpu, cb, cpu.c | (cpu.b << 8));\n  };\n  // 0xc6 : ADD A, n\n  instructions[0xc6] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    do_add(cb.mem_read(cpu.pc));\n  };\n  // 0xc7 : RST 00h\n  instructions[0xc7] = () => {\n    do_reset(0x00);\n  };\n  // 0xc8 : RET Z\n  instructions[0xc8] = () => {\n    do_conditional_return(!!cpu.flags.Z);\n  };\n  // 0xc9 : RET\n  instructions[0xc9] = () => {\n    cpu.pc = (pop_word() - 1) & 0xffff;\n  };\n  // 0xca : JP Z, nn\n  instructions[0xca] = () => {\n    do_conditional_absolute_jump(!!cpu.flags.Z);\n  };\n  // 0xcb : CB Prefix\n  instructions[0xcb] = () => {\n    // R is incremented at the start of the second instruction cycle,\n    //  before the instruction actually runs.\n    // The high bit of R is not affected by this increment,\n    //  it can only be changed using the LD R, A instruction.\n    cpu.r = (cpu.r & 0x80) | (((cpu.r & 0x7f) + 1) & 0x7f);\n\n    // We don't have a table for this prefix,\n    //  the instructions are all so uniform that we can directly decode them.\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const opcode1 = cb.mem_read(cpu.pc);\n    const bit_number = (opcode1 & 0x38) >>> 3;\n    const reg_code = opcode1 & 0x07;\n\n    if (opcode1 < 0x40) {\n      // Shift/rotate instructions\n      const op_array = [\n        do_rlc,\n        do_rrc,\n        do_rl,\n        do_rr,\n        do_sla,\n        do_sra,\n        do_sll,\n        do_srl,\n      ];\n\n      if (reg_code === 0) cpu.b = op_array[bit_number](cpu.b);\n      else if (reg_code === 1) cpu.c = op_array[bit_number](cpu.c);\n      else if (reg_code === 2) cpu.d = op_array[bit_number](cpu.d);\n      else if (reg_code === 3) cpu.e = op_array[bit_number](cpu.e);\n      else if (reg_code === 4) cpu.h = op_array[bit_number](cpu.h);\n      else if (reg_code === 5) cpu.l = op_array[bit_number](cpu.l);\n      else if (reg_code === 6) {\n        cb.mem_write(\n          cpu.l | (cpu.h << 8),\n          op_array[bit_number](cb.mem_read(cpu.l | (cpu.h << 8)))\n        );\n      } else if (reg_code === 7) cpu.a = op_array[bit_number](cpu.a);\n    } else if (opcode1 < 0x80) {\n      // BIT instructions\n      if (reg_code === 0) cpu.flags.Z = !(cpu.b & (1 << bit_number)) ? 1 : 0;\n      else if (reg_code === 1)\n        cpu.flags.Z = !(cpu.c & (1 << bit_number)) ? 1 : 0;\n      else if (reg_code === 2)\n        cpu.flags.Z = !(cpu.d & (1 << bit_number)) ? 1 : 0;\n      else if (reg_code === 3)\n        cpu.flags.Z = !(cpu.e & (1 << bit_number)) ? 1 : 0;\n      else if (reg_code === 4)\n        cpu.flags.Z = !(cpu.h & (1 << bit_number)) ? 1 : 0;\n      else if (reg_code === 5)\n        cpu.flags.Z = !(cpu.l & (1 << bit_number)) ? 1 : 0;\n      else if (reg_code === 6) {\n        cpu.flags.Z = !(cb.mem_read(cpu.l | (cpu.h << 8)) & (1 << bit_number))\n          ? 1\n          : 0;\n      } else if (reg_code === 7)\n        cpu.flags.Z = !(cpu.a & (1 << bit_number)) ? 1 : 0;\n\n      cpu.flags.N = 0;\n      cpu.flags.H = 1;\n      cpu.flags.P = cpu.flags.Z;\n      cpu.flags.S = bit_number === 7 && !cpu.flags.Z ? 1 : 0;\n      // For the BIT n, (HL) instruction, the X and Y flags are obtained\n      //  from what is apparently an internal temporary register used for\n      //  some of the 16-bit arithmetic instructions.\n      // I haven't implemented that register here,\n      //  so for now we'll set X and Y the same way for every BIT opcode,\n      //  which means that they will usually be wrong for BIT n, (HL).\n      cpu.flags.Y = bit_number === 5 && !cpu.flags.Z ? 1 : 0;\n      cpu.flags.X = bit_number === 3 && !cpu.flags.Z ? 1 : 0;\n    } else if (opcode1 < 0xc0) {\n      // RES instructions\n      if (reg_code === 0) cpu.b &= 0xff & ~(1 << bit_number);\n      else if (reg_code === 1) cpu.c &= 0xff & ~(1 << bit_number);\n      else if (reg_code === 2) cpu.d &= 0xff & ~(1 << bit_number);\n      else if (reg_code === 3) cpu.e &= 0xff & ~(1 << bit_number);\n      else if (reg_code === 4) cpu.h &= 0xff & ~(1 << bit_number);\n      else if (reg_code === 5) cpu.l &= 0xff & ~(1 << bit_number);\n      else if (reg_code === 6) {\n        cb.mem_write(\n          cpu.l | (cpu.h << 8),\n          cb.mem_read(cpu.l | (cpu.h << 8)) & ~(1 << bit_number)\n        );\n      } else if (reg_code === 7) cpu.a &= 0xff & ~(1 << bit_number);\n    } else {\n      // SET instructions\n      if (reg_code === 0) cpu.b |= 1 << bit_number;\n      else if (reg_code === 1) cpu.c |= 1 << bit_number;\n      else if (reg_code === 2) cpu.d |= 1 << bit_number;\n      else if (reg_code === 3) cpu.e |= 1 << bit_number;\n      else if (reg_code === 4) cpu.h |= 1 << bit_number;\n      else if (reg_code === 5) cpu.l |= 1 << bit_number;\n      else if (reg_code === 6) {\n        cb.mem_write(\n          cpu.l | (cpu.h << 8),\n          cb.mem_read(cpu.l | (cpu.h << 8)) | (1 << bit_number)\n        );\n      } else if (reg_code === 7) cpu.a |= 1 << bit_number;\n    }\n\n    cpu.cycle_counter += cycle_counts_cb[opcode1];\n  };\n  // 0xcc : CALL Z, nn\n  instructions[0xcc] = () => {\n    do_conditional_call(!!cpu.flags.Z);\n  };\n  // 0xcd : CALL nn\n  instructions[0xcd] = () => {\n    pushWord(cpu, cb, (cpu.pc + 3) & 0xffff);\n    cpu.pc =\n      cb.mem_read((cpu.pc + 1) & 0xffff) |\n      (cb.mem_read((cpu.pc + 2) & 0xffff) << 8);\n    cpu.pc = (cpu.pc - 1) & 0xffff;\n  };\n  // 0xce : ADC A, n\n  instructions[0xce] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    do_adc(cb.mem_read(cpu.pc));\n  };\n  // 0xcf : RST 08h\n  instructions[0xcf] = () => {\n    do_reset(0x08);\n  };\n  // 0xd0 : RET NC\n  instructions[0xd0] = () => {\n    do_conditional_return(!cpu.flags.C);\n  };\n  // 0xd1 : POP DE\n  instructions[0xd1] = () => {\n    const result = pop_word();\n    cpu.e = result & 0xff;\n    cpu.d = (result & 0xff00) >>> 8;\n  };\n  // 0xd2 : JP NC, nn\n  instructions[0xd2] = () => {\n    do_conditional_absolute_jump(!cpu.flags.C);\n  };\n  // 0xd3 : OUT (n), A\n  instructions[0xd3] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    cb.io_write((cpu.a << 8) | cb.mem_read(cpu.pc), cpu.a);\n  };\n  // 0xd4 : CALL NC, nn\n  instructions[0xd4] = () => {\n    do_conditional_call(!cpu.flags.C);\n  };\n  // 0xd5 : PUSH DE\n  instructions[0xd5] = () => {\n    pushWord(cpu, cb, cpu.e | (cpu.d << 8));\n  };\n  // 0xd6 : SUB n\n  instructions[0xd6] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    do_sub(cb.mem_read(cpu.pc));\n  };\n  // 0xd7 : RST 10h\n  instructions[0xd7] = () => {\n    do_reset(0x10);\n  };\n  // 0xd8 : RET C\n  instructions[0xd8] = () => {\n    do_conditional_return(!!cpu.flags.C);\n  };\n  // 0xd9 : EXX\n  instructions[0xd9] = () => {\n    let temp = cpu.b;\n    cpu.b = cpu.b_prime;\n    cpu.b_prime = temp;\n    temp = cpu.c;\n    cpu.c = cpu.c_prime;\n    cpu.c_prime = temp;\n    temp = cpu.d;\n    cpu.d = cpu.d_prime;\n    cpu.d_prime = temp;\n    temp = cpu.e;\n    cpu.e = cpu.e_prime;\n    cpu.e_prime = temp;\n    temp = cpu.h;\n    cpu.h = cpu.h_prime;\n    cpu.h_prime = temp;\n    temp = cpu.l;\n    cpu.l = cpu.l_prime;\n    cpu.l_prime = temp;\n  };\n  // 0xda : JP C, nn\n  instructions[0xda] = () => {\n    do_conditional_absolute_jump(!!cpu.flags.C);\n  };\n  // 0xdb : IN A, (n)\n  instructions[0xdb] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    cpu.a = cb.io_read((cpu.a << 8) | cb.mem_read(cpu.pc));\n  };\n  // 0xdc : CALL C, nn\n  instructions[0xdc] = () => {\n    do_conditional_call(!!cpu.flags.C);\n  };\n  // 0xdd : DD Prefix (IX instructions)\n  instructions[0xdd] = () => {\n    // R is incremented at the start of the second instruction cycle,\n    //  before the instruction actually runs.\n    // The high bit of R is not affected by this increment,\n    //  it can only be changed using the LD R, A instruction.\n    cpu.r = (cpu.r & 0x80) | (((cpu.r & 0x7f) + 1) & 0x7f);\n\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const opcode1 = cb.mem_read(cpu.pc);\n    const func = dd_instructions[opcode1];\n\n    if (func) {\n      // func = func.bind(this);\n      func();\n      cpu.cycle_counter += cycle_counts_dd[opcode1];\n    } else {\n      // Apparently if a DD opcode doesn't exist,\n      //  it gets treated as an unprefixed opcode.\n      // What we'll do to handle that is just back up the\n      //  program counter, so that this byte gets decoded\n      //  as a normal instruction.\n      cpu.pc = (cpu.pc - 1) & 0xffff;\n      // And we'll add in the cycle count for a NOP.\n      cpu.cycle_counter += cycle_counts[0];\n    }\n  };\n  // 0xde : SBC n\n  instructions[0xde] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    do_sbc(cb.mem_read(cpu.pc));\n  };\n  // 0xdf : RST 18h\n  instructions[0xdf] = () => {\n    do_reset(0x18);\n  };\n  // 0xe0 : RET PO\n  instructions[0xe0] = () => {\n    do_conditional_return(!cpu.flags.P);\n  };\n  // 0xe1 : POP HL\n  instructions[0xe1] = () => {\n    const result = pop_word();\n    cpu.l = result & 0xff;\n    cpu.h = (result & 0xff00) >>> 8;\n  };\n  // 0xe2 : JP PO, (nn)\n  instructions[0xe2] = () => {\n    do_conditional_absolute_jump(!cpu.flags.P);\n  };\n  // 0xe3 : EX (SP), HL\n  instructions[0xe3] = () => {\n    let temp = cb.mem_read(cpu.sp);\n    cb.mem_write(cpu.sp, cpu.l);\n    cpu.l = temp;\n    temp = cb.mem_read((cpu.sp + 1) & 0xffff);\n    cb.mem_write((cpu.sp + 1) & 0xffff, cpu.h);\n    cpu.h = temp;\n  };\n  // 0xe4 : CALL PO, nn\n  instructions[0xe4] = () => {\n    do_conditional_call(!cpu.flags.P);\n  };\n  // 0xe5 : PUSH HL\n  instructions[0xe5] = () => {\n    pushWord(cpu, cb, cpu.l | (cpu.h << 8));\n  };\n  // 0xe6 : AND n\n  instructions[0xe6] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    do_and(cb.mem_read(cpu.pc));\n  };\n  // 0xe7 : RST 20h\n  instructions[0xe7] = () => {\n    do_reset(0x20);\n  };\n  // 0xe8 : RET PE\n  instructions[0xe8] = () => {\n    do_conditional_return(!!cpu.flags.P);\n  };\n  // 0xe9 : JP (HL)\n  instructions[0xe9] = () => {\n    cpu.pc = cpu.l | (cpu.h << 8);\n    cpu.pc = (cpu.pc - 1) & 0xffff;\n  };\n  // 0xea : JP PE, nn\n  instructions[0xea] = () => {\n    do_conditional_absolute_jump(!!cpu.flags.P);\n  };\n  // 0xeb : EX DE, HL\n  instructions[0xeb] = () => {\n    let temp = cpu.d;\n    cpu.d = cpu.h;\n    cpu.h = temp;\n    temp = cpu.e;\n    cpu.e = cpu.l;\n    cpu.l = temp;\n  };\n  // 0xec : CALL PE, nn\n  instructions[0xec] = () => {\n    do_conditional_call(!!cpu.flags.P);\n  };\n  // 0xed : ED Prefix\n  instructions[0xed] = () => {\n    // R is incremented at the start of the second instruction cycle,\n    //  before the instruction actually runs.\n    // The high bit of R is not affected by this increment,\n    //  it can only be changed using the LD R, A instruction.\n    cpu.r = (cpu.r & 0x80) | (((cpu.r & 0x7f) + 1) & 0x7f);\n\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const opcode1 = cb.mem_read(cpu.pc);\n    const func = ed_instructions[opcode1];\n\n    if (func) {\n      // func = func.bind(this);\n      func();\n      cpu.cycle_counter += cycle_counts_ed[opcode1];\n    } else {\n      // If the opcode didn't exist, the whole thing is a two-byte NOP.\n      cpu.cycle_counter += cycle_counts[0];\n    }\n  };\n  // 0xee : XOR n\n  instructions[0xee] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    do_xor(cb.mem_read(cpu.pc));\n  };\n  // 0xef : RST 28h\n  instructions[0xef] = () => {\n    do_reset(0x28);\n  };\n  // 0xf0 : RET P\n  instructions[0xf0] = () => {\n    do_conditional_return(!cpu.flags.S);\n  };\n  // 0xf1 : POP AF\n  instructions[0xf1] = () => {\n    const result = pop_word();\n    setFlagsRegister(cpu, result & 0xff);\n    cpu.a = (result & 0xff00) >>> 8;\n  };\n  // 0xf2 : JP P, nn\n  instructions[0xf2] = () => {\n    do_conditional_absolute_jump(!cpu.flags.S);\n  };\n  // 0xf3 : DI\n  instructions[0xf3] = () => {\n    // DI doesn't actually take effect until after the next instruction.\n    cpu.do_delayed_di = true;\n  };\n  // 0xf4 : CALL P, nn\n  instructions[0xf4] = () => {\n    do_conditional_call(!cpu.flags.S);\n  };\n  // 0xf5 : PUSH AF\n  instructions[0xf5] = () => {\n    pushWord(cpu, cb, get_flags_register() | (cpu.a << 8));\n  };\n  // 0xf6 : OR n\n  instructions[0xf6] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    do_or(cb.mem_read(cpu.pc));\n  };\n  // 0xf7 : RST 30h\n  instructions[0xf7] = () => {\n    do_reset(0x30);\n  };\n  // 0xf8 : RET M\n  instructions[0xf8] = () => {\n    do_conditional_return(!!cpu.flags.S);\n  };\n  // 0xf9 : LD SP, HL\n  instructions[0xf9] = () => {\n    cpu.sp = cpu.l | (cpu.h << 8);\n  };\n  // 0xfa : JP M, nn\n  instructions[0xfa] = () => {\n    do_conditional_absolute_jump(!!cpu.flags.S);\n  };\n  // 0xfb : EI\n  instructions[0xfb] = () => {\n    // EI doesn't actually take effect until after the next instruction.\n    cpu.do_delayed_ei = true;\n  };\n  // 0xfc : CALL M, nn\n  instructions[0xfc] = () => {\n    do_conditional_call(!!cpu.flags.S);\n  };\n  // 0xfd : FD Prefix (IY instructions)\n  instructions[0xfd] = () => {\n    // R is incremented at the start of the second instruction cycle,\n    //  before the instruction actually runs.\n    // The high bit of R is not affected by this increment,\n    //  it can only be changed using the LD R, A instruction.\n    cpu.r = (cpu.r & 0x80) | (((cpu.r & 0x7f) + 1) & 0x7f);\n\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    const opcode1 = cb.mem_read(cpu.pc);\n    const func = dd_instructions[opcode1];\n\n    if (func) {\n      // Rather than copy and paste all the IX instructions into IY instructions,\n      //  what we'll do is sneakily copy IY into IX, run the IX instruction,\n      //  and then copy the result into IY and restore the old IX.\n      const temp = cpu.ix;\n      cpu.ix = cpu.iy;\n      // func = func.bind(this);\n      func();\n      cpu.iy = cpu.ix;\n      cpu.ix = temp;\n\n      cpu.cycle_counter += cycle_counts_dd[opcode1];\n    } else {\n      // Apparently if an FD opcode doesn't exist,\n      //  it gets treated as an unprefixed opcode.\n      // What we'll do to handle that is just back up the\n      //  program counter, so that this byte gets decoded\n      //  as a normal instruction.\n      cpu.pc = (cpu.pc - 1) & 0xffff;\n      // And we'll add in the cycle count for a NOP.\n      cpu.cycle_counter += cycle_counts[0];\n    }\n  };\n  // 0xfe : CP n\n  instructions[0xfe] = () => {\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n    do_cp(cb.mem_read(cpu.pc));\n  };\n  // 0xff : RST 38h\n  instructions[0xff] = () => {\n    do_reset(0x38);\n  };\n\n  // The register-to-register loads and ALU instructions\n  //  are all so uniform that we can decode them directly\n  //  instead of going into the instruction array for them.\n  // This function gets the operand for all of these instructions.\n  // eslint-disable-next-line no-shadow\n  const get_operand = (opcode: number) => {\n    return (opcode & 0x07) === 0\n      ? cpu.b\n      : (opcode & 0x07) === 1\n      ? cpu.c\n      : (opcode & 0x07) === 2\n      ? cpu.d\n      : (opcode & 0x07) === 3\n      ? cpu.e\n      : (opcode & 0x07) === 4\n      ? cpu.h\n      : (opcode & 0x07) === 5\n      ? cpu.l\n      : (opcode & 0x07) === 6\n      ? cb.mem_read(cpu.l | (cpu.h << 8))\n      : cpu.a;\n  };\n\n  // Handle HALT right up front, because it fouls up our LD decoding\n  //  by falling where LD (HL), (HL) ought to be.\n  if (opcode === 0x76) {\n    cpu.halted = true;\n  } else if (opcode >= 0x40 && opcode < 0x80) {\n    // This entire range is all 8-bit register loads.\n    // Get the operand and assign it to the correct destination.\n    const operand = get_operand(opcode);\n\n    if ((opcode & 0x38) >>> 3 === 0) cpu.b = operand;\n    else if ((opcode & 0x38) >>> 3 === 1) cpu.c = operand;\n    else if ((opcode & 0x38) >>> 3 === 2) cpu.d = operand;\n    else if ((opcode & 0x38) >>> 3 === 3) cpu.e = operand;\n    else if ((opcode & 0x38) >>> 3 === 4) cpu.h = operand;\n    else if ((opcode & 0x38) >>> 3 === 5) cpu.l = operand;\n    else if ((opcode & 0x38) >>> 3 === 6) {\n      cb.mem_write(cpu.l | (cpu.h << 8), operand);\n    } else if ((opcode & 0x38) >>> 3 === 7) cpu.a = operand;\n  } else if (opcode >= 0x80 && opcode < 0xc0) {\n    // These are the 8-bit register ALU instructions.\n    // We'll get the operand and then use this \"jump table\"\n    //  to call the correct utility function for the instruction.\n    const operand = get_operand(opcode);\n    const op_array = [\n      do_add,\n      do_adc,\n      do_sub,\n      do_sbc,\n      do_and,\n      do_xor,\n      do_or,\n      do_cp,\n    ];\n\n    op_array[(opcode & 0x38) >>> 3](operand);\n  } else {\n    // This is one of the less formulaic instructions;\n    //  we'll get the specific function for it from our array.\n    const func = instructions[opcode];\n    func();\n  }\n\n  // Update the cycle counter with however many cycles\n  //  the base instruction took.\n  // If this was a prefixed instruction, then\n  //  the prefix handler has added its extra cycles already.\n  cpu.cycle_counter += cycle_counts[opcode];\n};\n\nexport function init(): Cpu {\n  return {\n    a: 0x00,\n    b: 0x00,\n    c: 0x00,\n    d: 0x00,\n    e: 0x00,\n    h: 0x00,\n    l: 0x00,\n    // Now the special Z80 copies of the 8080 registers\n    //  (the ones used for the SWAP instruction and such).\n    a_prime: 0x00,\n    b_prime: 0x00,\n    c_prime: 0x00,\n    d_prime: 0x00,\n    e_prime: 0x00,\n    h_prime: 0x00,\n    l_prime: 0x00,\n    // And now the Z80 index registers.\n    ix: 0x0000,\n    iy: 0x0000,\n    // Then the \"utility\" registers: the interrupt vector,\n    //  the memory refresh, the stack pointer, and the program counter.\n    i: 0x00,\n    r: 0x00,\n    sp: 0xdff0,\n    pc: 0x0000,\n    // We don't keep an F register for the flags,\n    //  because most of the time we're only accessing a single flag,\n    //  so we optimize for that case and use utility functions\n    //  for the rarer occasions when we need to access the whole register.\n    flags: {\n      S: 0,\n      Z: 0,\n      Y: 0,\n      H: 0,\n      X: 0,\n      P: 0,\n      N: 0,\n      C: 0,\n    },\n    flags_prime: {\n      S: 0,\n      Z: 0,\n      Y: 0,\n      H: 0,\n      X: 0,\n      P: 0,\n      N: 0,\n      C: 0,\n    },\n    // And finally we have the interrupt mode and flip-flop registers.\n    imode: 0,\n    iff1: 0,\n    iff2: 0,\n\n    // These are all specific to this implementation, not Z80 features.\n    // Keep track of whether we've had a HALT instruction called.\n    halted: false,\n    // EI and DI wait one instruction before they take effect,\n    //  these flags tell us when we're in that wait state.\n    do_delayed_di: false,\n    do_delayed_ei: false,\n    // This tracks the number of cycles spent in a single instruction run,\n    //  including processing any prefixes and handling interrupts.\n    cycle_counter: 0,\n  };\n}\n\n// ////////////////////////////////////////////////////////////////////////////\n// @public reset\n//\n// @brief Re-initialize the processor as if a reset or power on had occured\n// ////////////////////////////////////////////////////////////////////////////\nexport const reset = (cpu: Cpu) => {\n  // These registers are the ones that have predictable states\n  //  immediately following a power-on or a reset.\n  // The others are left alone, because their states are unpredictable.\n  cpu.sp = 0xdff0;\n  cpu.pc = 0x0000;\n  cpu.a = 0x00;\n  cpu.r = 0x00;\n  setFlagsRegister(cpu, 0);\n  // Start up with interrupts disabled.\n  cpu.imode = 0;\n  cpu.iff1 = 0;\n  cpu.iff2 = 0;\n  // Don't start halted or in a delayed DI or EI.\n  cpu.halted = false;\n  cpu.do_delayed_di = false;\n  cpu.do_delayed_ei = false;\n  // Obviously we've not used any cycles yet.\n  cpu.cycle_counter = 0;\n};\n\n// ////////////////////////////////////////////////////////////////////////////\n// @public run_instruction\n//\n// @brief Runs a single instruction\n//\n// @return The number of T cycles the instruction took to run,\n//          plus any time that went into handling interrupts that fired\n//          while this instruction was executing\n// ////////////////////////////////////////////////////////////////////////////\nexport const execute = (cpu: Cpu, cb: Callbacks) => {\n  if (!cpu.halted) {\n    // If the previous instruction was a DI or an EI,\n    //  we'll need to disable or enable interrupts\n    //  after whatever instruction we're about to run is finished.\n    let doing_delayed_di = false;\n    let doing_delayed_ei = false;\n    if (cpu.do_delayed_di) {\n      cpu.do_delayed_di = false;\n      doing_delayed_di = true;\n    } else if (cpu.do_delayed_ei) {\n      cpu.do_delayed_ei = false;\n      doing_delayed_ei = true;\n    }\n\n    // R is incremented at the start of every instruction cycle,\n    //  before the instruction actually runs.\n    // The high bit of R is not affected by this increment,\n    //  it can only be changed using the LD R, A instruction.\n    cpu.r = (cpu.r & 0x80) | (((cpu.r & 0x7f) + 1) & 0x7f);\n\n    // Read the byte at the PC and run the instruction it encodes.\n    const opcode = cb.mem_read(cpu.pc);\n    decodeInstruction(cpu, cb, opcode);\n    cpu.pc = (cpu.pc + 1) & 0xffff;\n\n    // Actually do the delayed interrupt disable/enable if we have one.\n    if (doing_delayed_di) {\n      cpu.iff1 = 0;\n      cpu.iff2 = 0;\n    } else if (doing_delayed_ei) {\n      cpu.iff1 = 1;\n      cpu.iff2 = 1;\n    }\n\n    // And finally clear out the cycle counter for the next instruction\n    //  before returning it to the emulator core.\n    const retval = cpu.cycle_counter;\n    cpu.cycle_counter = 0;\n    return retval;\n  }\n  // While we're halted, claim that we spent a cycle doing nothing,\n  //  so that the rest of the emulator can still proceed.\n  return 1;\n};\n\n// ////////////////////////////////////////////////////////////////////////////\n// @public interrupt\n//\n// @brief Simulates pulsing the processor's INT (or NMI) pin\n//\n// @param non_maskable - true if this is a non-maskable interrupt\n// @param data - the value to be placed on the data bus, if needed\n// ////////////////////////////////////////////////////////////////////////////\nexport const interrupt = (\n  cpu: Cpu,\n  cb: Callbacks,\n  non_maskable: boolean,\n  data: number\n) => {\n  if (non_maskable) {\n    // The high bit of R is not affected by this increment,\n    //  it can only be changed using the LD R, A instruction.\n    cpu.r = (cpu.r & 0x80) | (((cpu.r & 0x7f) + 1) & 0x7f);\n    // Non-maskable interrupts are always handled the same way;\n    //  clear IFF1 and then do a CALL 0x0066.\n    // Also, all interrupts reset the HALT state.\n    cpu.halted = false;\n    cpu.iff2 = cpu.iff1;\n    cpu.iff1 = 0;\n    pushWord(cpu, cb, cpu.pc);\n    cpu.pc = 0x66;\n    cpu.cycle_counter += 11;\n  } else if (cpu.iff1) {\n    // The high bit of R is not affected by this increment,\n    //  it can only be changed using the LD R, A instruction.\n    cpu.r = (cpu.r & 0x80) | (((cpu.r & 0x7f) + 1) & 0x7f);\n\n    cpu.halted = false;\n    cpu.iff1 = 0;\n    cpu.iff2 = 0;\n\n    if (cpu.imode === 0) {\n      // In the 8080-compatible interrupt mode,\n      //  decode the content of the data bus as an instruction and run it.\n      decodeInstruction(cpu, cb, data);\n      cpu.cycle_counter += 2;\n    } else if (cpu.imode === 1) {\n      // Mode 1 is always just RST 0x38.\n      pushWord(cpu, cb, cpu.pc);\n      cpu.pc = 0x38;\n      cpu.cycle_counter += 13;\n    } else if (cpu.imode === 2) {\n      // Mode 2 uses the value on the data bus as in index\n      //  into the vector table pointer to by the I register.\n      pushWord(cpu, cb, cpu.pc);\n      // The Z80 manual says that this address must be 2-byte aligned,\n      //  but it doesn't appear that this is actually the case on the hardware,\n      //  so we don't attempt to enforce that here.\n      const vector_address = (cpu.i << 8) | data;\n      cpu.pc =\n        cb.mem_read(vector_address) |\n        (cb.mem_read((vector_address + 1) & 0xffff) << 8);\n\n      cpu.cycle_counter += 19;\n    }\n  }\n};\n","import MemoryMap from 'nrf-intel-hex';\nimport { throttle } from '../util/tools';\nimport { execute, reset, interrupt, init } from './z80';\n\nconst sixtyfourK = 0x10000;\n\nlet running = false;\nconst active = true;\nlet speed = 30;\nlet smooth = true;\n\nlet cycles = 0;\nconst memory = new Uint8Array(new ArrayBuffer(sixtyfourK)).fill(0xff);\nconst inPorts = Array(256).fill(0xff);\nconst outPorts = Array(256).fill(0xff);\nconst display = Array(6).fill(0);\nlet speaker = 1;\nlet wavelength = 0;\n\nconst cpu = init();\n\nconst postAllMemory = throttle(\n  () => {\n    const memMap = new MemoryMap();\n    const bytes = new Uint8Array(memory);\n    memMap.set(0, bytes);\n    const hexString = memMap.asHexString();\n\n    (self as any).postMessage({\n      type: 'POST_ALL_MEMORY',\n      memory: hexString,\n    });\n  },\n  5 * 1000,\n  true\n);\n\nconst postDisplay = throttle(() => {\n  const displayBuffer = new ArrayBuffer(6);\n  const view = new Uint8Array(displayBuffer);\n  for (let i = 0; i < 6; i++) {\n    view[i] = display[i];\n  }\n  (self as any).postMessage(\n    {\n      type: 'POST_DISPLAY',\n      display: displayBuffer,\n    },\n    [displayBuffer]\n  );\n}, 100);\n\nfunction ioWrite(port: number, value: number) {\n  const port1 = port & 0xff;\n  outPorts[port1] = value;\n  const digits = outPorts[1];\n  const segments = outPorts[2];\n  let mask = 0x01;\n  for (let i = 0; i < 6; i++) {\n    if (digits & mask) {\n      display[i] = segments;\n    }\n    else if (!smooth) {\n      display[i] = 0;\n    }\n    mask <<= 1;\n  }\n  let wavelengthChanged = false;\n  if (port1 === 1) {\n    const speaker1 = value >> 7;\n    if (speaker1 === 1 && speaker === 0) {\n      if (wavelength !== cycles) {\n        wavelengthChanged = true;\n      }\n      wavelength = cycles;\n      cycles = 0;\n    }\n    speaker = speaker1;\n  }\n  if (cycles > 10000) {\n    if (wavelength !== 0) {\n      wavelengthChanged = true;\n    }\n    wavelength = 0;\n  }\n  if (wavelengthChanged) {\n    (self as any).postMessage(\n      {\n        type: 'POST_WAVELENGTH',\n        wavelength,\n      },\n      []\n    );\n  }\n  postDisplay();\n}\n\nconst cb = {\n  mem_read: (addr: number) => memory[addr],\n  mem_write: (addr: number, value: number) => {\n    const oldValue = memory[addr];\n    memory[addr] = value;\n    if (oldValue !== value) {\n      postAllMemory();\n    }\n  },\n  io_read: (port: number) => {\n    return inPorts[port & 0xff];\n  },\n  io_write: ioWrite,\n};\n\nfunction* runGen() {\n  while (true) {\n    for (let i = 0; i < 1000; i++) {\n      try {\n        const count = execute(cpu, cb);\n        cycles += count;\n      } catch (e) {\n        const pc = cpu.pc;\n        const mem = memory[pc] || 0;\n        console.error(\n          `Illegal operation at ${pc.toString(16)}: ${mem.toString(16)}`\n        );\n        reset(cpu);\n      }\n    }\n    yield cycles;\n  }\n}\n\nlet pending = false;\nconst iter = runGen();\nfunction run() {\n  if (pending) return;\n  if (!running) return;\n  iter.next();\n  if (running) {\n    pending = true;\n    const delay = Math.floor((1 - Number(speed)) * 30);\n    setTimeout(function () {\n      pending = false;\n      run();\n    }, delay);\n  }\n}\n\nconst resetRun = (doReset: boolean) => {\n  if (doReset) {\n    reset(cpu);\n  }\n  running = true;\n  run();\n};\n\nconst doInit = () => {\n  console.log('init');\n};\n\nconst doReset = () => {\n  resetRun(true);\n};\n\nconst doSetInputValue = (event: any) => {\n  const { port, value } = event.data;\n  inPorts[port] = value;\n};\n\nconst doSetKeyValue = (event: any) => {\n  const { code, pressed } = event.data;\n  inPorts[0] = code;\n  const bit6 = 0b01000000;\n  const bit6mask = ~bit6;\n  inPorts[3] = (inPorts[3] & bit6mask) | (!pressed ? bit6 : 0);\n};\n\nconst doSetSpeed = (event: any) => {\n  speed = Number(event.data.value) / 100;\n};\n\nconst doSetSmooth = (event: any) => {\n  smooth = event.data.value === true;\n};\n\nconst doNMI = () => {\n  interrupt(cpu, cb, true, 0);\n};\n\nconst doUpdateMemory = (event: any) => {\n  console.log('memory updated');\n  const rom = event.data.value;\n  const blocks = MemoryMap.fromHex(rom);\n  for (const address of blocks.keys()) {\n    const block = blocks.get(address);\n    for (let i = 0; i < block.length; i++) {\n      memory[i + address] = block[i];\n    }\n  }\n  resetRun(true);\n};\n\nconst doReadMemory = (event: any) => {\n  console.log('read memory');\n  const from = event.data.from;\n  const size = event.data.size;\n  const buffer1 = new ArrayBuffer(size);\n  const bytes = new Uint8Array(buffer1);\n  for (let i = 0; i < size; i++) {\n    bytes[i] = memory[i + from];\n  }\n  (self as any).postMessage(\n    {\n      type: 'POST_MEMORY',\n      from,\n      size,\n      buffer: buffer1,\n    },\n    [buffer1]\n  );\n};\n\nconst doProcessHidden = (event: any) => {\n  const hidden = event.data.value;\n  if (hidden) {\n    running = false;\n  } else if (active) {\n    resetRun(false);\n  } else {\n    console.log('not active');\n  }\n};\n\nself.onmessage = (event: any) => {\n  if (event.data.type === 'INIT') {\n    doInit();\n  } else if (event.data.type === 'RESET') {\n    doReset();\n  } else if (event.data.type === 'SET_INPUT_VALUE') {\n    doSetInputValue(event);\n  } else if (event.data.type === 'SET_KEY_VALUE') {\n    doSetKeyValue(event);\n  } else if (event.data.type === 'SET_SMOOTH') {\n    doSetSmooth(event);\n  } else if (event.data.type === 'SET_SPEED') {\n    doSetSpeed(event);\n  } else if (event.data.type === 'NMI') {\n    doNMI();\n  } else if (event.data.type === 'UPDATE_MEMORY') {\n    doUpdateMemory(event);\n  } else if (event.data.type === 'READ_MEMORY') {\n    doReadMemory(event);\n  } else if (event.data.type === 'HIDDEN') {\n    doProcessHidden(event);\n  }\n};"]}