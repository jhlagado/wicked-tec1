{"version":3,"sources":["src/worker/z80.js","src/worker/ROM.js","intel-hex.js","src/worker/worker.js"],"names":["Z80","coreParameter","core","mem_read","mem_write","io_read","io_write","a","b","c","d","e","h","l","a_prime","b_prime","c_prime","d_prime","e_prime","h_prime","l_prime","ix","iy","i","r","sp","pc","flags","S","Z","Y","H","X","P","N","C","flags_prime","imode","iff1","iff2","halted","do_delayed_di","do_delayed_ei","cycle_counter","reset","decode_instruction","opcode","get_operand","operand","do_add","do_adc","do_sub","do_sbc","do_and","do_xor","do_or","do_cp","func","instructions","cycle_counts","get_signed_offset_byte","value","get_flags_register","set_flags_register","update_xy_flags","result","get_parity","parity_bits","push_word","pop_word","retval","do_conditional_absolute_jump","condition","do_conditional_relative_jump","offset","do_conditional_call","do_conditional_return","do_reset","address","temp","do_inc","do_dec","do_hl_add","hl","do_hl_adc","do_hl_sbc","do_in","port","do_neg","do_ldi","read_value","do_cpi","temp_carry","do_ini","do_outi","do_ldd","do_cpd","do_ind","do_outd","do_rlc","do_rrc","do_rl","do_rr","do_sla","do_sra","do_sll","do_srl","do_ix_add","temp_s","temp_z","temp_p","bit_number","reg_code","op_array","cycle_counts_cb","dd_instructions","cycle_counts_dd","ed_instructions","cycle_counts_ed","hl_value","temp1","ddcb_functions","undefined","getState","setState","state","reset1","run_instruction","doing_delayed_di","doing_delayed_ei","console","log","interrupt","non_maskable","data","vector_address","ROM","const","let","blockAddr","blocks","block","running","active","speed","cycles","memory","Array","fill","inPorts","outPorts","cpu","addr","port1","updateDisplay","postOutPorts","display","runGen","count","self","onmessage","event","type","loadROM","run","Number","pending","iter","next","delay","Math","floor","setTimeout","digits","segments","mask","getPortsBuffer","buffer","ArrayBuffer","view","Uint8Array","getDisplayBuffer","speaker","wavelength","speaker1","postMessage","MemoryMap","fromHex","keys","get","length"],"mappings":"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G,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EACvD,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EACrD,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EACrD,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAG7CJ,GAAkB,CAClB,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAC/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAC/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAC/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAC/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAC/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAC/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAC/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAC/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAC/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAC/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAC/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAC/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAC/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAC/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAC/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAG/CE,GAAkB,CAClB,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAC9C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAC9C,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,EACrD,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EACjD,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAA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","file":"worker.5fbe8b00.map","sourceRoot":"..","sourcesContent":["///////////////////////////////////////////////////////////////////////////////\n/// @file Z80.js\n///\n/// @brief Emulator for the Zilog Z80 microprocessor\n///\n/// @author Matthew Howell\n///\n/// @remarks\n///  This module is a simple, straightforward instruction interpreter.\n///   There is no fancy dynamic recompilation or cycle-accurate emulation.\n///   The author believes that this should be sufficient for any emulator that\n///   would be feasible to write in JavaScript anyway.\n///  The code and the comments in this file assume that the reader is familiar\n///   with the Z80 architecture. If you're not, here are some references I use:\n///  http://clrhome.org/table/ - Z80 instruction set tables\n///  http://www.zilog.com/docs/z80/um0080.pdf - The official manual\n///  http://www.myquest.nl/z80undocumented/z80-documented-v0.91.pdf\n///   - The Undocumented Z80, Documented\n///\n/// @copyright (c) 2013 Matthew Howell\n///  This code is released under the MIT license,\n///  a copy of which is available in the associated README.md file,\n///  or at http://opensource.org/licenses/MIT\n///////////////////////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////////////////////\n/// We'll begin with the object constructor and the public API functions.\n///////////////////////////////////////////////////////////////////////////////\n\nexport function Z80(coreParameter) {\n    // Obviously we'll be needing the core object's functions again.\n    let core = coreParameter;\n\n    // The argument to this constructor should be an object containing 4 functions:\n    // mem_read(address) should return the byte at the given memory address,\n    // mem_write(address, value) should write the given value to the given memory address,\n    // io_read(port) should read a return a byte read from the given I/O port,\n    // io_write(port, value) should write the given byte to the given I/O port.\n    // If any of those functions is missing, this module cannot run.\n    if (!core || (typeof core.mem_read !== \"function\") || (typeof core.mem_write !== \"function\") ||\n        (typeof core.io_read !== \"function\") || (typeof core.io_write !== \"function\"))\n        throw (\"Z80: Core object is missing required functions.\");\n\n    // All right, let's initialize the registers.\n    // First, the standard 8080 registers.\n    let a = 0x00;\n    let b = 0x00;\n    let c = 0x00;\n    let d = 0x00;\n    let e = 0x00;\n    let h = 0x00;\n    let l = 0x00;\n    // Now the special Z80 copies of the 8080 registers\n    //  (the ones used for the SWAP instruction and such).\n    let a_prime = 0x00;\n    let b_prime = 0x00;\n    let c_prime = 0x00;\n    let d_prime = 0x00;\n    let e_prime = 0x00;\n    let h_prime = 0x00;\n    let l_prime = 0x00;\n    // And now the Z80 index registers.\n    let ix = 0x0000;\n    let iy = 0x0000;\n    // Then the \"utility\" registers: the interrupt vector,\n    //  the memory refresh, the stack pointer, and the program counter.\n    let i = 0x00;\n    let r = 0x00;\n    let sp = 0xdff0;\n    let pc = 0x0000;\n    // We don't keep an F register for the flags,\n    //  because most of the time we're only accessing a single flag,\n    //  so we optimize for that case and use utility functions\n    //  for the rarer occasions when we need to access the whole register.\n    let flags = { S: 0, Z: 0, Y: 0, H: 0, X: 0, P: 0, N: 0, C: 0 };\n    let flags_prime = { S: 0, Z: 0, Y: 0, H: 0, X: 0, P: 0, N: 0, C: 0 };\n    // And finally we have the interrupt mode and flip-flop registers.\n    let imode = 0;\n    let iff1 = 0;\n    let iff2 = 0;\n\n    // These are all specific to this implementation, not Z80 features.\n    // Keep track of whether we've had a HALT instruction called.\n    let halted = false;\n    // EI and DI wait one instruction before they take effect;\n    //  these flags tell us when we're in that wait state.\n    let do_delayed_di = false;\n    let do_delayed_ei = false;\n    // This tracks the number of cycles spent in a single instruction run,\n    //  including processing any prefixes and handling interrupts.\n    let cycle_counter = 0;\n\n    function getState() {\n        return {\n            b: b,\n            a: a,\n            c: c,\n            d: d,\n            e: e,\n            h: h,\n            l: l,\n            a_prime: a_prime,\n            b_prime: b_prime,\n            c_prime: c_prime,\n            d_prime: d_prime,\n            e_prime: e_prime,\n            h_prime: h_prime,\n            l_prime: l_prime,\n            ix: ix,\n            iy: iy,\n            i: i,\n            r: r,\n            sp: sp,\n            pc: pc,\n            flags: {\n                S: flags.S,\n                Z: flags.Z,\n                Y: flags.Y,\n                H: flags.H,\n                X: flags.X,\n                P: flags.P,\n                N: flags.N,\n                C: flags.C\n            },\n            flags_prime: {\n                S: flags_prime.S,\n                Z: flags_prime.Z,\n                Y: flags_prime.Y,\n                H: flags_prime.H,\n                X: flags_prime.X,\n                P: flags_prime.P,\n                N: flags_prime.N,\n                C: flags_prime.C\n            },\n            imode: imode,\n            iff1: iff1,\n            iff2: iff2,\n            halted: halted,\n            do_delayed_di: do_delayed_di,\n            do_delayed_ei: do_delayed_ei,\n            cycle_counter: cycle_counter\n        };\n    }\n\n    function setState(state) {\n        b = state.b;\n        a = state.a;\n        c = state.c;\n        d = state.d;\n        e = state.e;\n        h = state.h;\n        l = state.l;\n        a_prime = state.a_prime;\n        b_prime = state.b_prime;\n        c_prime = state.c_prime;\n        d_prime = state.d_prime;\n        e_prime = state.e_prime;\n        h_prime = state.h_prime;\n        l_prime = state.l_prime;\n        ix = state.ix;\n        iy = state.iy;\n        i = state.i;\n        r = state.r;\n        sp = state.sp;\n        pc = state.pc;\n        flags.S = state.flags.S;\n        flags.Z = state.flags.Z;\n        flags.Y = state.flags.Y;\n        flags.H = state.flags.H;\n        flags.X = state.flags.X;\n        flags.P = state.flags.P;\n        flags.N = state.flags.N;\n        flags.C = state.flags.C;\n        flags_prime.S = state.flags_prime.S;\n        flags_prime.Z = state.flags_prime.Z;\n        flags_prime.Y = state.flags_prime.Y;\n        flags_prime.H = state.flags_prime.H;\n        flags_prime.X = state.flags_prime.X;\n        flags_prime.P = state.flags_prime.P;\n        flags_prime.N = state.flags_prime.N;\n        flags_prime.C = state.flags_prime.C;\n        imode = state.imode;\n        iff1 = state.iff1;\n        iff2 = state.iff2;\n        halted = state.halted;\n        do_delayed_di = state.do_delayed_di;\n        do_delayed_ei = state.do_delayed_ei;\n        cycle_counter = state.cycle_counter;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// @public reset\n    ///\n    /// @brief Re-initialize the processor as if a reset or power on had occured\n    ///////////////////////////////////////////////////////////////////////////////\n    let reset = function () {\n        // These registers are the ones that have predictable states\n        //  immediately following a power-on or a reset.\n        // The others are left alone, because their states are unpredictable.\n        sp = 0xdff0;\n        pc = 0x0000;\n        a = 0x00;\n        r = 0x00;\n        set_flags_register(0);\n        // Start up with interrupts disabled.\n        imode = 0;\n        iff1 = 0;\n        iff2 = 0;\n        // Don't start halted or in a delayed DI or EI.\n        halted = false;\n        do_delayed_di = false;\n        do_delayed_ei = false;\n        // Obviously we've not used any cycles yet.\n        cycle_counter = 0;\n    };\n\n    let reset1 = function () {\n        sp = 0xdff0;\n        pc = 0x0000;\n        halted = false;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// @public run_instruction\n    ///\n    /// @brief Runs a single instruction\n    ///\n    /// @return The number of T cycles the instruction took to run,\n    ///          plus any time that went into handling interrupts that fired\n    ///          while this instruction was executing\n    ///////////////////////////////////////////////////////////////////////////////\n    let run_instruction = function () {\n        if (!halted) {\n            // If the previous instruction was a DI or an EI,\n            //  we'll need to disable or enable interrupts\n            //  after whatever instruction we're about to run is finished.\n            var doing_delayed_di = false, doing_delayed_ei = false;\n            if (do_delayed_di) {\n                do_delayed_di = false;\n                doing_delayed_di = true;\n            }\n            else if (do_delayed_ei) {\n                do_delayed_ei = false;\n                doing_delayed_ei = true;\n            }\n\n            // R is incremented at the start of every instruction cycle,\n            //  before the instruction actually runs.\n            // The high bit of R is not affected by this increment,\n            //  it can only be changed using the LD R, A instruction.\n            r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n\n            // Read the byte at the PC and run the instruction it encodes.\n            var opcode = core.mem_read(pc);\n            try {\n                decode_instruction(opcode);\n            }\n            catch (e) {\n                console.log(`Illegal opcode ${opcode} at ${pc}`);\n                halted = true;\n            }\n            pc = (pc + 1) & 0xffff;\n\n            // Actually do the delayed interrupt disable/enable if we have one.\n            if (doing_delayed_di) {\n                iff1 = 0;\n                iff2 = 0;\n            }\n            else if (doing_delayed_ei) {\n                iff1 = 1;\n                iff2 = 1;\n            }\n\n            // And finally clear out the cycle counter for the next instruction\n            //  before returning it to the emulator core.\n            var retval = cycle_counter;\n            cycle_counter = 0;\n            return retval;\n        }\n        else {\n            // While we're halted, claim that we spent a cycle doing nothing,\n            //  so that the rest of the emulator can still proceed.\n            return 1;\n        }\n    };\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// @public interrupt\n    ///\n    /// @brief Simulates pulsing the processor's INT (or NMI) pin\n    ///\n    /// @param non_maskable - true if this is a non-maskable interrupt\n    /// @param data - the value to be placed on the data bus, if needed\n    ///////////////////////////////////////////////////////////////////////////////\n    let interrupt = function (non_maskable, data) {\n        if (non_maskable) {\n            // The high bit of R is not affected by this increment,\n            //  it can only be changed using the LD R, A instruction.\n            r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n            // Non-maskable interrupts are always handled the same way;\n            //  clear IFF1 and then do a CALL 0x0066.\n            // Also, all interrupts reset the HALT state.\n            halted = false;\n            iff2 = iff1;\n            iff1 = 0;\n            push_word(pc);\n            pc = 0x66;\n            cycle_counter += 11;\n        }\n        else if (iff1) {\n            // The high bit of R is not affected by this increment,\n            //  it can only be changed using the LD R, A instruction.\n            r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n\n            halted = false;\n            iff1 = 0;\n            iff2 = 0;\n\n            if (imode === 0) {\n                // In the 8080-compatible interrupt mode,\n                //  decode the content of the data bus as an instruction and run it.\n                decode_instruction(data);\n                cycle_counter += 2;\n            }\n            else if (imode === 1) {\n                // Mode 1 is always just RST 0x38.\n                push_word(pc);\n                pc = 0x38;\n                cycle_counter += 13;\n            }\n            else if (imode === 2) {\n                // Mode 2 uses the value on the data bus as in index\n                //  into the vector table pointer to by the I register.\n                push_word(pc);\n                // The Z80 manual says that this address must be 2-byte aligned,\n                //  but it doesn't appear that this is actually the case on the hardware,\n                //  so we don't attempt to enforce that here.\n                var vector_address = ((i << 8) | data);\n                pc = core.mem_read(vector_address) |\n                    (core.mem_read((vector_address + 1) & 0xffff) << 8);\n\n                cycle_counter += 19;\n            }\n        }\n    };\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// The public API functions end here.\n    ///\n    /// What begins here are just general utility functions, used variously.\n    ///////////////////////////////////////////////////////////////////////////////\n    let decode_instruction = function (opcode) {\n        // The register-to-register loads and ALU instructions\n        //  are all so uniform that we can decode them directly\n        //  instead of going into the instruction array for them.\n        // This function gets the operand for all of these instructions.\n        var get_operand = function (opcode) {\n            return ((opcode & 0x07) === 0) ? b :\n                ((opcode & 0x07) === 1) ? c :\n                    ((opcode & 0x07) === 2) ? d :\n                        ((opcode & 0x07) === 3) ? e :\n                            ((opcode & 0x07) === 4) ? h :\n                                ((opcode & 0x07) === 5) ? l :\n                                    ((opcode & 0x07) === 6) ? core.mem_read(l | (h << 8)) : a;\n        };\n\n        // Handle HALT right up front, because it fouls up our LD decoding\n        //  by falling where LD (HL), (HL) ought to be.\n        if (opcode === 0x76) {\n            halted = true;\n        }\n        else if ((opcode >= 0x40) && (opcode < 0x80)) {\n            // This entire range is all 8-bit register loads.\n            // Get the operand and assign it to the correct destination.\n            var operand = get_operand(opcode);\n\n            if (((opcode & 0x38) >>> 3) === 0)\n                b = operand;\n            else if (((opcode & 0x38) >>> 3) === 1)\n                c = operand;\n            else if (((opcode & 0x38) >>> 3) === 2)\n                d = operand;\n            else if (((opcode & 0x38) >>> 3) === 3)\n                e = operand;\n            else if (((opcode & 0x38) >>> 3) === 4)\n                h = operand;\n            else if (((opcode & 0x38) >>> 3) === 5)\n                l = operand;\n            else if (((opcode & 0x38) >>> 3) === 6)\n                core.mem_write(l | (h << 8), operand);\n            else if (((opcode & 0x38) >>> 3) === 7)\n                a = operand;\n        }\n        else if ((opcode >= 0x80) && (opcode < 0xc0)) {\n            // These are the 8-bit register ALU instructions.\n            // We'll get the operand and then use this \"jump table\"\n            //  to call the correct utility function for the instruction.\n            var operand = get_operand(opcode),\n                op_array = [do_add, do_adc, do_sub, do_sbc,\n                    do_and, do_xor, do_or, do_cp];\n\n            op_array[(opcode & 0x38) >>> 3](operand);\n        }\n        else {\n            // This is one of the less formulaic instructions;\n            //  we'll get the specific function for it from our array.\n            var func = instructions[opcode];\n            func();\n        }\n\n        // Update the cycle counter with however many cycles\n        //  the base instruction took.\n        // If this was a prefixed instruction, then\n        //  the prefix handler has added its extra cycles already.\n        cycle_counter += cycle_counts[opcode];\n    };\n\n    let get_signed_offset_byte = function (value) {\n        // This function requires some explanation.\n        // We just use JavaScript Number variables for our registers,\n        //  not like a typed array or anything.\n        // That means that, when we have a byte value that's supposed\n        //  to represent a signed offset, the value we actually see\n        //  isn't signed at all, it's just a small integer.\n        // So, this function converts that byte into something JavaScript\n        //  will recognize as signed, so we can easily do arithmetic with it.\n        // First, we clamp the value to a single byte, just in case.\n        value &= 0xff;\n        // We don't have to do anything if the value is positive.\n        if (value & 0x80) {\n            // But if the value is negative, we need to manually un-two's-compliment it.\n            // I'm going to assume you can figure out what I meant by that,\n            //  because I don't know how else to explain it.\n            // We could also just do value |= 0xffffff00, but I prefer\n            //  not caring how many bits are in the integer representation\n            //  of a JavaScript number in the currently running browser.\n            value = -((0xff & ~value) + 1);\n        }\n        return value;\n    };\n\n    let get_flags_register = function () {\n        // We need the whole F register for some reason.\n        //  probably a PUSH AF instruction,\n        //  so make the F register out of our separate flags.\n        return (flags.S << 7) |\n            (flags.Z << 6) |\n            (flags.Y << 5) |\n            (flags.H << 4) |\n            (flags.X << 3) |\n            (flags.P << 2) |\n            (flags.N << 1) |\n            (flags.C);\n    };\n\n    let get_flags_prime = function () {\n        // This is the same as the above for the F' register.\n        return (flags_prime.S << 7) |\n            (flags_prime.Z << 6) |\n            (flags_prime.Y << 5) |\n            (flags_prime.H << 4) |\n            (flags_prime.X << 3) |\n            (flags_prime.P << 2) |\n            (flags_prime.N << 1) |\n            (flags_prime.C);\n    };\n\n    let set_flags_register = function (operand) {\n        // We need to set the F register, probably for a POP AF,\n        //  so break out the given value into our separate flags.\n        flags.S = (operand & 0x80) >>> 7;\n        flags.Z = (operand & 0x40) >>> 6;\n        flags.Y = (operand & 0x20) >>> 5;\n        flags.H = (operand & 0x10) >>> 4;\n        flags.X = (operand & 0x08) >>> 3;\n        flags.P = (operand & 0x04) >>> 2;\n        flags.N = (operand & 0x02) >>> 1;\n        flags.C = (operand & 0x01);\n    };\n\n    let set_flags_prime = function (operand) {\n        // Again, this is the same as the above for F'.\n        flags_prime.S = (operand & 0x80) >>> 7;\n        flags_prime.Z = (operand & 0x40) >>> 6;\n        flags_prime.Y = (operand & 0x20) >>> 5;\n        flags_prime.H = (operand & 0x10) >>> 4;\n        flags_prime.X = (operand & 0x08) >>> 3;\n        flags_prime.P = (operand & 0x04) >>> 2;\n        flags_prime.N = (operand & 0x02) >>> 1;\n        flags_prime.C = (operand & 0x01);\n    };\n\n    let update_xy_flags = function (result) {\n        // Most of the time, the undocumented flags\n        //  (sometimes called X and Y, or 3 and 5),\n        //  take their values from the corresponding bits\n        //  of the result of the instruction,\n        //  or from some other related value.\n        // This is a utility function to set those flags based on those bits.\n        flags.Y = (result & 0x20) >>> 5;\n        flags.X = (result & 0x08) >>> 3;\n    };\n\n    let get_parity = function (value) {\n        // We could try to actually calculate the parity every time,\n        //  but why calculate what you can pre-calculate?\n        var parity_bits = [\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1\n        ];\n        return parity_bits[value];\n    };\n\n    let push_word = function (operand) {\n        // Pretty obvious what this function does; given a 16-bit value,\n        //  decrement the stack pointer, write the high byte to the new\n        //  stack pointer location, then repeat for the low byte.\n        sp = (sp - 1) & 0xffff;\n        core.mem_write(sp, (operand & 0xff00) >>> 8);\n        sp = (sp - 1) & 0xffff;\n        core.mem_write(sp, operand & 0x00ff);\n    };\n\n    let pop_word = function () {\n        // Again, not complicated; read a byte off the top of the stack,\n        //  increment the stack pointer, rinse and repeat.\n        var retval = core.mem_read(sp) & 0xff;\n        sp = (sp + 1) & 0xffff;\n        retval |= core.mem_read(sp) << 8;\n        sp = (sp + 1) & 0xffff;\n        return retval;\n    };\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// Now, the way most instructions work in this emulator is that they set up\n    ///  their operands according to their addressing mode, and then they call a\n    ///  utility function that handles all variations of that instruction.\n    /// Those utility functions begin here.\n    ///////////////////////////////////////////////////////////////////////////////\n    let do_conditional_absolute_jump = function (condition) {\n        // This function implements the JP [condition],nn instructions.\n        if (condition) {\n            // We're taking this jump, so write the new PC,\n            //  and then decrement the thing we just wrote,\n            //  because the instruction decoder increments the PC\n            //  unconditionally at the end of every instruction\n            //  and we need to counteract that so we end up at the jump target.\n            pc = core.mem_read((pc + 1) & 0xffff) |\n                (core.mem_read((pc + 2) & 0xffff) << 8);\n            pc = (pc - 1) & 0xffff;\n        }\n        else {\n            // We're not taking this jump, just move the PC past the operand.\n            pc = (pc + 2) & 0xffff;\n        }\n    };\n\n    let do_conditional_relative_jump = function (condition) {\n        // This function implements the JR [condition],n instructions.\n        if (condition) {\n            // We need a few more cycles to actually take the jump.\n            cycle_counter += 5;\n            // Calculate the offset specified by our operand.\n            var offset = get_signed_offset_byte(core.mem_read((pc + 1) & 0xffff));\n            // Add the offset to the PC, also skipping past this instruction.\n            pc = (pc + offset + 1) & 0xffff;\n        }\n        else {\n            // No jump happening, just skip the operand.\n            pc = (pc + 1) & 0xffff;\n        }\n    };\n\n    let do_conditional_call = function (condition) {\n        // This function is the CALL [condition],nn instructions.\n        // If you've seen the previous functions, you know this drill.\n        if (condition) {\n            cycle_counter += 7;\n            push_word((pc + 3) & 0xffff);\n            pc = core.mem_read((pc + 1) & 0xffff) |\n                (core.mem_read((pc + 2) & 0xffff) << 8);\n            pc = (pc - 1) & 0xffff;\n        }\n        else {\n            pc = (pc + 2) & 0xffff;\n        }\n    };\n\n    let do_conditional_return = function (condition) {\n        if (condition) {\n            cycle_counter += 6;\n            pc = (pop_word() - 1) & 0xffff;\n        }\n    };\n\n    let do_reset = function (address) {\n        // The RST [address] instructions go through here.\n        push_word((pc + 1) & 0xffff);\n        pc = (address - 1) & 0xffff;\n    };\n\n    let do_add = function (operand) {\n        // This is the ADD A, [operand] instructions.\n        // We'll do the literal addition, which includes any overflow,\n        //  so that we can more easily figure out whether we had\n        //  an overflow or a carry and set the flags accordingly.\n        var result = a + operand;\n\n        // The great majority of the work for the arithmetic instructions\n        //  turns out to be setting the flags rather than the actual operation.\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = !(result & 0xff) ? 1 : 0;\n        flags.H = (((operand & 0x0f) + (a & 0x0f)) & 0x10) ? 1 : 0;\n        // An overflow has happened if the sign bits of the accumulator and the operand\n        //  don't match the sign bit of the result value.\n        flags.P = ((a & 0x80) === (operand & 0x80)) && ((a & 0x80) !== (result & 0x80)) ? 1 : 0;\n        flags.N = 0;\n        flags.C = (result & 0x100) ? 1 : 0;\n\n        a = result & 0xff;\n        update_xy_flags(a);\n    };\n\n    let do_adc = function (operand) {\n        var result = a + operand + flags.C;\n\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = !(result & 0xff) ? 1 : 0;\n        flags.H = (((operand & 0x0f) + (a & 0x0f) + flags.C) & 0x10) ? 1 : 0;\n        flags.P = ((a & 0x80) === (operand & 0x80)) && ((a & 0x80) !== (result & 0x80)) ? 1 : 0;\n        flags.N = 0;\n        flags.C = (result & 0x100) ? 1 : 0;\n\n        a = result & 0xff;\n        update_xy_flags(a);\n    };\n\n    let do_sub = function (operand) {\n        var result = a - operand;\n\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = !(result & 0xff) ? 1 : 0;\n        flags.H = (((a & 0x0f) - (operand & 0x0f)) & 0x10) ? 1 : 0;\n        flags.P = ((a & 0x80) !== (operand & 0x80)) && ((a & 0x80) !== (result & 0x80)) ? 1 : 0;\n        flags.N = 1;\n        flags.C = (result & 0x100) ? 1 : 0;\n\n        a = result & 0xff;\n        update_xy_flags(a);\n    };\n\n    let do_sbc = function (operand) {\n        var result = a - operand - flags.C;\n\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = !(result & 0xff) ? 1 : 0;\n        flags.H = (((a & 0x0f) - (operand & 0x0f) - flags.C) & 0x10) ? 1 : 0;\n        flags.P = ((a & 0x80) !== (operand & 0x80)) && ((a & 0x80) !== (result & 0x80)) ? 1 : 0;\n        flags.N = 1;\n        flags.C = (result & 0x100) ? 1 : 0;\n\n        a = result & 0xff;\n        update_xy_flags(a);\n    };\n\n    let do_cp = function (operand) {\n        // A compare instruction is just a subtraction that doesn't save the value,\n        //  so we implement it as... a subtraction that doesn't save the value.\n        var temp = a;\n        do_sub(operand);\n        a = temp;\n        // Since this instruction has no \"result\" value, the undocumented flags\n        //  are set based on the operand instead.\n        update_xy_flags(operand);\n    };\n\n    let do_and = function (operand) {\n        // The logic instructions are all pretty straightforward.\n        a &= operand & 0xff;\n        flags.S = (a & 0x80) ? 1 : 0;\n        flags.Z = !a ? 1 : 0;\n        flags.H = 1;\n        flags.P = get_parity(a);\n        flags.N = 0;\n        flags.C = 0;\n        update_xy_flags(a);\n    };\n\n    let do_or = function (operand) {\n        a = (operand | a) & 0xff;\n        flags.S = (a & 0x80) ? 1 : 0;\n        flags.Z = !a ? 1 : 0;\n        flags.H = 0;\n        flags.P = get_parity(a);\n        flags.N = 0;\n        flags.C = 0;\n        update_xy_flags(a);\n    };\n\n    let do_xor = function (operand) {\n        a = (operand ^ a) & 0xff;\n        flags.S = (a & 0x80) ? 1 : 0;\n        flags.Z = !a ? 1 : 0;\n        flags.H = 0;\n        flags.P = get_parity(a);\n        flags.N = 0;\n        flags.C = 0;\n        update_xy_flags(a);\n    };\n\n    let do_inc = function (operand) {\n        var result = operand + 1;\n\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = !(result & 0xff) ? 1 : 0;\n        flags.H = ((operand & 0x0f) === 0x0f) ? 1 : 0;\n        // It's a good deal easier to detect overflow for an increment/decrement.\n        flags.P = (operand === 0x7f) ? 1 : 0;\n        flags.N = 0;\n\n        result &= 0xff;\n        update_xy_flags(result);\n\n        return result;\n    };\n\n    let do_dec = function (operand) {\n        var result = operand - 1;\n\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = !(result & 0xff) ? 1 : 0;\n        flags.H = ((operand & 0x0f) === 0x00) ? 1 : 0;\n        flags.P = (operand === 0x80) ? 1 : 0;\n        flags.N = 1;\n\n        result &= 0xff;\n        update_xy_flags(result);\n\n        return result;\n    };\n\n    let do_hl_add = function (operand) {\n        // The HL arithmetic instructions are the same as the A ones,\n        //  just with twice as many bits happening.\n        var hl = l | (h << 8), result = hl + operand;\n\n        flags.N = 0;\n        flags.C = (result & 0x10000) ? 1 : 0;\n        flags.H = (((hl & 0x0fff) + (operand & 0x0fff)) & 0x1000) ? 1 : 0;\n\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n\n        update_xy_flags(h);\n    };\n\n    let do_hl_adc = function (operand) {\n        operand += flags.C;\n        var hl = l | (h << 8), result = hl + operand;\n\n        flags.S = (result & 0x8000) ? 1 : 0;\n        flags.Z = !(result & 0xffff) ? 1 : 0;\n        flags.H = (((hl & 0x0fff) + (operand & 0x0fff)) & 0x1000) ? 1 : 0;\n        flags.P = ((hl & 0x8000) === (operand & 0x8000)) && ((result & 0x8000) !== (hl & 0x8000)) ? 1 : 0;\n        flags.N = 0;\n        flags.C = (result & 0x10000) ? 1 : 0;\n\n        l = result & 0xff;\n        h = (result >>> 8) & 0xff;\n\n        update_xy_flags(h);\n    };\n\n    let do_hl_sbc = function (operand) {\n        operand += flags.C;\n        var hl = l | (h << 8), result = hl - operand;\n\n        flags.S = (result & 0x8000) ? 1 : 0;\n        flags.Z = !(result & 0xffff) ? 1 : 0;\n        flags.H = (((hl & 0x0fff) - (operand & 0x0fff)) & 0x1000) ? 1 : 0;\n        flags.P = ((hl & 0x8000) !== (operand & 0x8000)) && ((result & 0x8000) !== (hl & 0x8000)) ? 1 : 0;\n        flags.N = 1;\n        flags.C = (result & 0x10000) ? 1 : 0;\n\n        l = result & 0xff;\n        h = (result >>> 8) & 0xff;\n\n        update_xy_flags(h);\n    };\n\n    let do_in = function (port) {\n        var result = core.io_read(port);\n\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = result ? 0 : 1;\n        flags.H = 0;\n        flags.P = get_parity(result) ? 1 : 0;\n        flags.N = 0;\n        update_xy_flags(result);\n\n        return result;\n    };\n\n    let do_neg = function () {\n        // This instruction is defined to not alter the register if it === 0x80.\n        if (a !== 0x80) {\n            // This is a signed operation, so convert A to a signed value.\n            a = get_signed_offset_byte(a);\n\n            a = (-a) & 0xff;\n        }\n\n        flags.S = (a & 0x80) ? 1 : 0;\n        flags.Z = !a ? 1 : 0;\n        flags.H = (((-a) & 0x0f) > 0) ? 1 : 0;\n        flags.P = (a === 0x80) ? 1 : 0;\n        flags.N = 1;\n        flags.C = a ? 1 : 0;\n        update_xy_flags(a);\n    };\n\n    let do_ldi = function () {\n        // Copy the value that we're supposed to copy.\n        var read_value = core.mem_read(l | (h << 8));\n        core.mem_write(e | (d << 8), read_value);\n\n        // Increment DE and HL, and decrement BC.\n        var result = (e | (d << 8)) + 1;\n        e = result & 0xff;\n        d = (result & 0xff00) >>> 8;\n        result = (l | (h << 8)) + 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n        result = (c | (b << 8)) - 1;\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n\n        flags.H = 0;\n        flags.P = (c || b) ? 1 : 0;\n        flags.N = 0;\n        flags.Y = ((a + read_value) & 0x02) >>> 1;\n        flags.X = ((a + read_value) & 0x08) >>> 3;\n    };\n\n    let do_cpi = function () {\n        var temp_carry = flags.C;\n        var read_value = core.mem_read(l | (h << 8))\n        do_cp(read_value);\n        flags.C = temp_carry;\n        flags.Y = ((a - read_value - flags.H) & 0x02) >>> 1;\n        flags.X = ((a - read_value - flags.H) & 0x08) >>> 3;\n\n        var result = (l | (h << 8)) + 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n        result = (c | (b << 8)) - 1;\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n\n        flags.P = result ? 1 : 0;\n    };\n\n    let do_ini = function () {\n        b = do_dec(b);\n\n        core.mem_write(l | (h << 8), core.io_read((b << 8) | c));\n\n        var result = (l | (h << 8)) + 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n\n        flags.N = 1;\n    };\n\n    let do_outi = function () {\n        core.io_write((b << 8) | c, core.mem_read(l | (h << 8)));\n\n        var result = (l | (h << 8)) + 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n\n        b = do_dec(b);\n        flags.N = 1;\n    };\n\n    let do_ldd = function () {\n        flags.N = 0;\n        flags.H = 0;\n\n        var read_value = core.mem_read(l | (h << 8));\n        core.mem_write(e | (d << 8), read_value);\n\n        var result = (e | (d << 8)) - 1;\n        e = result & 0xff;\n        d = (result & 0xff00) >>> 8;\n        result = (l | (h << 8)) - 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n        result = (c | (b << 8)) - 1;\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n\n        flags.P = (c || b) ? 1 : 0;\n        flags.Y = ((a + read_value) & 0x02) >>> 1;\n        flags.X = ((a + read_value) & 0x08) >>> 3;\n    };\n\n    let do_cpd = function () {\n        var temp_carry = flags.C\n        var read_value = core.mem_read(l | (h << 8))\n        do_cp(read_value);\n        flags.C = temp_carry;\n        flags.Y = ((a - read_value - flags.H) & 0x02) >>> 1;\n        flags.X = ((a - read_value - flags.H) & 0x08) >>> 3;\n\n        var result = (l | (h << 8)) - 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n        result = (c | (b << 8)) - 1;\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n\n        flags.P = result ? 1 : 0;\n    };\n\n    let do_ind = function () {\n        b = do_dec(b);\n\n        core.mem_write(l | (h << 8), core.io_read((b << 8) | c));\n\n        var result = (l | (h << 8)) - 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n\n        flags.N = 1;\n    };\n\n    let do_outd = function () {\n        core.io_write((b << 8) | c, core.mem_read(l | (h << 8)));\n\n        var result = (l | (h << 8)) - 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n\n        b = do_dec(b);\n        flags.N = 1;\n    };\n\n    let do_rlc = function (operand) {\n        flags.N = 0;\n        flags.H = 0;\n\n        flags.C = (operand & 0x80) >>> 7;\n        operand = ((operand << 1) | flags.C) & 0xff;\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_rrc = function (operand) {\n        flags.N = 0;\n        flags.H = 0;\n\n        flags.C = operand & 1;\n        operand = ((operand >>> 1) & 0x7f) | (flags.C << 7);\n\n        flags.Z = !(operand & 0xff) ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand & 0xff;\n    };\n\n    let do_rl = function (operand) {\n        flags.N = 0;\n        flags.H = 0;\n\n        var temp = flags.C;\n        flags.C = (operand & 0x80) >>> 7;\n        operand = ((operand << 1) | temp) & 0xff;\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_rr = function (operand) {\n        flags.N = 0;\n        flags.H = 0;\n\n        var temp = flags.C;\n        flags.C = operand & 1;\n        operand = ((operand >>> 1) & 0x7f) | (temp << 7);\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_sla = function (operand) {\n        flags.N = 0;\n        flags.H = 0;\n\n        flags.C = (operand & 0x80) >>> 7;\n        operand = (operand << 1) & 0xff;\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_sra = function (operand) {\n        flags.N = 0;\n        flags.H = 0;\n\n        flags.C = operand & 1;\n        operand = ((operand >>> 1) & 0x7f) | (operand & 0x80);\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_sll = function (operand) {\n        flags.N = 0;\n        flags.H = 0;\n\n        flags.C = (operand & 0x80) >>> 7;\n        operand = ((operand << 1) & 0xff) | 1;\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_srl = function (operand) {\n        flags.N = 0;\n        flags.H = 0;\n\n        flags.C = operand & 1;\n        operand = (operand >>> 1) & 0x7f;\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_ix_add = function (operand) {\n        flags.N = 0;\n\n        var result = ix + operand;\n\n        flags.C = (result & 0x10000) ? 1 : 0;\n        flags.H = (((ix & 0xfff) + (operand & 0xfff)) & 0x1000) ? 1 : 0;\n        update_xy_flags((result & 0xff00) >>> 8);\n\n        ix = result;\n    };\n\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// This table contains the implementations for the instructions that weren't\n    ///  implemented directly in the decoder function (everything but the 8-bit\n    ///  register loads and the accumulator ALU instructions, in other words).\n    /// Similar tables for the ED and DD/FD prefixes follow this one.\n    ///////////////////////////////////////////////////////////////////////////////\n    let instructions = [];\n\n    // 0x00 : NOP\n    instructions[0x00] = function () { };\n    // 0x01 : LD BC, nn\n    instructions[0x01] = function () {\n        pc = (pc + 1) & 0xffff;\n        c = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        b = core.mem_read(pc);\n    };\n    // 0x02 : LD (BC), A\n    instructions[0x02] = function () {\n        core.mem_write(c | (b << 8), a);\n    };\n    // 0x03 : INC BC\n    instructions[0x03] = function () {\n        var result = (c | (b << 8));\n        result += 1;\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n    };\n    // 0x04 : INC B\n    instructions[0x04] = function () {\n        b = do_inc(b);\n    };\n    // 0x05 : DEC B\n    instructions[0x05] = function () {\n        b = do_dec(b);\n    };\n    // 0x06 : LD B, n\n    instructions[0x06] = function () {\n        pc = (pc + 1) & 0xffff;\n        b = core.mem_read(pc);\n    };\n    // 0x07 : RLCA\n    instructions[0x07] = function () {\n        // This instruction is implemented as a special case of the\n        //  more general Z80-specific RLC instruction.\n        // Specifially, RLCA is a version of RLC A that affects fewer flags.\n        // The same applies to RRCA, RLA, and RRA.\n        var temp_s = flags.S, temp_z = flags.Z, temp_p = flags.P;\n        a = do_rlc(a);\n        flags.S = temp_s;\n        flags.Z = temp_z;\n        flags.P = temp_p;\n    };\n    // 0x08 : EX AF, AF'\n    instructions[0x08] = function () {\n        var temp = a;\n        a = a_prime;\n        a_prime = temp;\n\n        temp = get_flags_register();\n        set_flags_register(get_flags_prime());\n        set_flags_prime(temp);\n    };\n    // 0x09 : ADD HL, BC\n    instructions[0x09] = function () {\n        do_hl_add(c | (b << 8));\n    };\n    // 0x0a : LD A, (BC)\n    instructions[0x0a] = function () {\n        a = core.mem_read(c | (b << 8));\n    };\n    // 0x0b : DEC BC\n    instructions[0x0b] = function () {\n        var result = (c | (b << 8));\n        result -= 1;\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n    };\n    // 0x0c : INC C\n    instructions[0x0c] = function () {\n        c = do_inc(c);\n    };\n    // 0x0d : DEC C\n    instructions[0x0d] = function () {\n        c = do_dec(c);\n    };\n    // 0x0e : LD C, n\n    instructions[0x0e] = function () {\n        pc = (pc + 1) & 0xffff;\n        c = core.mem_read(pc);\n    };\n    // 0x0f : RRCA\n    instructions[0x0f] = function () {\n        var temp_s = flags.S, temp_z = flags.Z, temp_p = flags.P;\n        a = do_rrc(a);\n        flags.S = temp_s;\n        flags.Z = temp_z;\n        flags.P = temp_p;\n    };\n    // 0x10 : DJNZ nn\n    instructions[0x10] = function () {\n        b = (b - 1) & 0xff;\n        do_conditional_relative_jump(b !== 0);\n    };\n    // 0x11 : LD DE, nn\n    instructions[0x11] = function () {\n        pc = (pc + 1) & 0xffff;\n        e = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        d = core.mem_read(pc);\n    };\n    // 0x12 : LD (DE), A\n    instructions[0x12] = function () {\n        core.mem_write(e | (d << 8), a);\n    };\n    // 0x13 : INC DE\n    instructions[0x13] = function () {\n        var result = (e | (d << 8));\n        result += 1;\n        e = result & 0xff;\n        d = (result & 0xff00) >>> 8;\n    };\n    // 0x14 : INC D\n    instructions[0x14] = function () {\n        d = do_inc(d);\n    };\n    // 0x15 : DEC D\n    instructions[0x15] = function () {\n        d = do_dec(d);\n    };\n    // 0x16 : LD D, n\n    instructions[0x16] = function () {\n        pc = (pc + 1) & 0xffff;\n        d = core.mem_read(pc);\n    };\n    // 0x17 : RLA\n    instructions[0x17] = function () {\n        var temp_s = flags.S, temp_z = flags.Z, temp_p = flags.P;\n        a = do_rl(a);\n        flags.S = temp_s;\n        flags.Z = temp_z;\n        flags.P = temp_p;\n    };\n    // 0x18 : JR n\n    instructions[0x18] = function () {\n        var offset = get_signed_offset_byte(core.mem_read((pc + 1) & 0xffff));\n        pc = (pc + offset + 1) & 0xffff;\n    };\n    // 0x19 : ADD HL, DE\n    instructions[0x19] = function () {\n        do_hl_add(e | (d << 8));\n    };\n    // 0x1a : LD A, (DE)\n    instructions[0x1a] = function () {\n        a = core.mem_read(e | (d << 8));\n    };\n    // 0x1b : DEC DE\n    instructions[0x1b] = function () {\n        var result = (e | (d << 8));\n        result -= 1;\n        e = result & 0xff;\n        d = (result & 0xff00) >>> 8;\n    };\n    // 0x1c : INC E\n    instructions[0x1c] = function () {\n        e = do_inc(e);\n    };\n    // 0x1d : DEC E\n    instructions[0x1d] = function () {\n        e = do_dec(e);\n    };\n    // 0x1e : LD E, n\n    instructions[0x1e] = function () {\n        pc = (pc + 1) & 0xffff;\n        e = core.mem_read(pc);\n    };\n    // 0x1f : RRA\n    instructions[0x1f] = function () {\n        var temp_s = flags.S, temp_z = flags.Z, temp_p = flags.P;\n        a = do_rr(a);\n        flags.S = temp_s;\n        flags.Z = temp_z;\n        flags.P = temp_p;\n    };\n    // 0x20 : JR NZ, n\n    instructions[0x20] = function () {\n        do_conditional_relative_jump(!flags.Z);\n    };\n    // 0x21 : LD HL, nn\n    instructions[0x21] = function () {\n        pc = (pc + 1) & 0xffff;\n        l = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        h = core.mem_read(pc);\n    };\n    // 0x22 : LD (nn), HL\n    instructions[0x22] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        core.mem_write(address, l);\n        core.mem_write((address + 1) & 0xffff, h);\n    };\n    // 0x23 : INC HL\n    instructions[0x23] = function () {\n        var result = (l | (h << 8));\n        result += 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n    };\n    // 0x24 : INC H\n    instructions[0x24] = function () {\n        h = do_inc(h);\n    };\n    // 0x25 : DEC H\n    instructions[0x25] = function () {\n        h = do_dec(h);\n    };\n    // 0x26 : LD H, n\n    instructions[0x26] = function () {\n        pc = (pc + 1) & 0xffff;\n        h = core.mem_read(pc);\n    };\n    // 0x27 : DAA\n    instructions[0x27] = function () {\n        var temp = a;\n        if (!flags.N) {\n            if (flags.H || ((a & 0x0f) > 9))\n                temp += 0x06;\n            if (flags.C || (a > 0x99))\n                temp += 0x60;\n        }\n        else {\n            if (flags.H || ((a & 0x0f) > 9))\n                temp -= 0x06;\n            if (flags.C || (a > 0x99))\n                temp -= 0x60;\n        }\n\n        flags.S = (temp & 0x80) ? 1 : 0;\n        flags.Z = !(temp & 0xff) ? 1 : 0;\n        flags.H = ((a & 0x10) ^ (temp & 0x10)) ? 1 : 0;\n        flags.P = get_parity(temp & 0xff);\n        // DAA never clears the carry flag if it was already set,\n        //  but it is able to set the carry flag if it was clear.\n        // Don't ask me, I don't know.\n        // Note also that we check for a BCD carry, instead of the usual.\n        flags.C = (flags.C || (a > 0x99)) ? 1 : 0;\n\n        a = temp & 0xff;\n\n        update_xy_flags(a);\n    };\n    // 0x28 : JR Z, n\n    instructions[0x28] = function () {\n        do_conditional_relative_jump(!!flags.Z);\n    };\n    // 0x29 : ADD HL, HL\n    instructions[0x29] = function () {\n        do_hl_add(l | (h << 8));\n    };\n    // 0x2a : LD HL, (nn)\n    instructions[0x2a] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        l = core.mem_read(address);\n        h = core.mem_read((address + 1) & 0xffff);\n    };\n    // 0x2b : DEC HL\n    instructions[0x2b] = function () {\n        var result = (l | (h << 8));\n        result -= 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n    };\n    // 0x2c : INC L\n    instructions[0x2c] = function () {\n        l = do_inc(l);\n    };\n    // 0x2d : DEC L\n    instructions[0x2d] = function () {\n        l = do_dec(l);\n    };\n    // 0x2e : LD L, n\n    instructions[0x2e] = function () {\n        pc = (pc + 1) & 0xffff;\n        l = core.mem_read(pc);\n    };\n    // 0x2f : CPL\n    instructions[0x2f] = function () {\n        a = (~a) & 0xff;\n        flags.N = 1;\n        flags.H = 1;\n        update_xy_flags(a);\n    };\n    // 0x30 : JR NC, n\n    instructions[0x30] = function () {\n        do_conditional_relative_jump(!flags.C);\n    };\n    // 0x31 : LD SP, nn\n    instructions[0x31] = function () {\n        sp = core.mem_read((pc + 1) & 0xffff) |\n            (core.mem_read((pc + 2) & 0xffff) << 8);\n        pc = (pc + 2) & 0xffff;\n    };\n    // 0x32 : LD (nn), A\n    instructions[0x32] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        core.mem_write(address, a);\n    };\n    // 0x33 : INC SP\n    instructions[0x33] = function () {\n        sp = (sp + 1) & 0xffff;\n    };\n    // 0x34 : INC (HL)\n    instructions[0x34] = function () {\n        var address = l | (h << 8);\n        core.mem_write(address, do_inc(core.mem_read(address)));\n    };\n    // 0x35 : DEC (HL)\n    instructions[0x35] = function () {\n        var address = l | (h << 8);\n        core.mem_write(address, do_dec(core.mem_read(address)));\n    };\n    // 0x36 : LD (HL), n\n    instructions[0x36] = function () {\n        pc = (pc + 1) & 0xffff;\n        core.mem_write(l | (h << 8), core.mem_read(pc));\n    };\n    // 0x37 : SCF\n    instructions[0x37] = function () {\n        flags.N = 0;\n        flags.H = 0;\n        flags.C = 1;\n        update_xy_flags(a);\n    };\n    // 0x38 : JR C, n\n    instructions[0x38] = function () {\n        do_conditional_relative_jump(!!flags.C);\n    };\n    // 0x39 : ADD HL, SP\n    instructions[0x39] = function () {\n        do_hl_add(sp);\n    };\n    // 0x3a : LD A, (nn)\n    instructions[0x3a] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        a = core.mem_read(address);\n    };\n    // 0x3b : DEC SP\n    instructions[0x3b] = function () {\n        sp = (sp - 1) & 0xffff;\n    };\n    // 0x3c : INC A\n    instructions[0x3c] = function () {\n        a = do_inc(a);\n    };\n    // 0x3d : DEC A\n    instructions[0x3d] = function () {\n        a = do_dec(a);\n    };\n    // 0x3e : LD A, n\n    instructions[0x3e] = function () {\n        a = core.mem_read((pc + 1) & 0xffff);\n        pc = (pc + 1) & 0xffff;\n    };\n    // 0x3f : CCF\n    instructions[0x3f] = function () {\n        flags.N = 0;\n        flags.H = flags.C;\n        flags.C = flags.C ? 0 : 1;\n        update_xy_flags(a);\n    };\n    // 0xc0 : RET NZ\n    instructions[0xc0] = function () {\n        do_conditional_return(!flags.Z);\n    };\n    // 0xc1 : POP BC\n    instructions[0xc1] = function () {\n        var result = pop_word();\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n    };\n    // 0xc2 : JP NZ, nn\n    instructions[0xc2] = function () {\n        do_conditional_absolute_jump(!flags.Z);\n    };\n    // 0xc3 : JP nn\n    instructions[0xc3] = function () {\n        pc = core.mem_read((pc + 1) & 0xffff) |\n            (core.mem_read((pc + 2) & 0xffff) << 8);\n        pc = (pc - 1) & 0xffff;\n    };\n    // 0xc4 : CALL NZ, nn\n    instructions[0xc4] = function () {\n        do_conditional_call(!flags.Z);\n    };\n    // 0xc5 : PUSH BC\n    instructions[0xc5] = function () {\n        push_word(c | (b << 8));\n    };\n    // 0xc6 : ADD A, n\n    instructions[0xc6] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_add(core.mem_read(pc));\n    };\n    // 0xc7 : RST 00h\n    instructions[0xc7] = function () {\n        do_reset(0x00);\n    };\n    // 0xc8 : RET Z\n    instructions[0xc8] = function () {\n        do_conditional_return(!!flags.Z);\n    };\n    // 0xc9 : RET\n    instructions[0xc9] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n    };\n    // 0xca : JP Z, nn\n    instructions[0xca] = function () {\n        do_conditional_absolute_jump(!!flags.Z);\n    };\n    // 0xcb : CB Prefix\n    instructions[0xcb] = function () {\n        // R is incremented at the start of the second instruction cycle,\n        //  before the instruction actually runs.\n        // The high bit of R is not affected by this increment,\n        //  it can only be changed using the LD R, A instruction.\n        r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n\n        // We don't have a table for this prefix,\n        //  the instructions are all so uniform that we can directly decode them.\n        pc = (pc + 1) & 0xffff;\n        var opcode = core.mem_read(pc),\n            bit_number = (opcode & 0x38) >>> 3,\n            reg_code = opcode & 0x07;\n\n        if (opcode < 0x40) {\n            // Shift/rotate instructions\n            var op_array = [do_rlc, do_rrc, do_rl, do_rr,\n                do_sla, do_sra, do_sll, do_srl];\n\n            if (reg_code === 0)\n                b = op_array[bit_number](b);\n            else if (reg_code === 1)\n                c = op_array[bit_number](c);\n            else if (reg_code === 2)\n                d = op_array[bit_number](d);\n            else if (reg_code === 3)\n                e = op_array[bit_number](e);\n            else if (reg_code === 4)\n                h = op_array[bit_number](h);\n            else if (reg_code === 5)\n                l = op_array[bit_number](l);\n            else if (reg_code === 6)\n                core.mem_write(l | (h << 8),\n                    op_array[bit_number](core.mem_read(l | (h << 8))));\n            else if (reg_code === 7)\n                a = op_array[bit_number](a);\n        }\n        else if (opcode < 0x80) {\n            // BIT instructions\n            if (reg_code === 0)\n                flags.Z = !(b & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 1)\n                flags.Z = !(c & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 2)\n                flags.Z = !(d & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 3)\n                flags.Z = !(e & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 4)\n                flags.Z = !(h & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 5)\n                flags.Z = !(l & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 6)\n                flags.Z = !((core.mem_read(l | (h << 8))) & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 7)\n                flags.Z = !(a & (1 << bit_number)) ? 1 : 0;\n\n            flags.N = 0;\n            flags.H = 1;\n            flags.P = flags.Z;\n            flags.S = ((bit_number === 7) && !flags.Z) ? 1 : 0;\n            // For the BIT n, (HL) instruction, the X and Y flags are obtained\n            //  from what is apparently an internal temporary register used for\n            //  some of the 16-bit arithmetic instructions.\n            // I haven't implemented that register here,\n            //  so for now we'll set X and Y the same way for every BIT opcode,\n            //  which means that they will usually be wrong for BIT n, (HL).\n            flags.Y = ((bit_number === 5) && !flags.Z) ? 1 : 0;\n            flags.X = ((bit_number === 3) && !flags.Z) ? 1 : 0;\n        }\n        else if (opcode < 0xc0) {\n            // RES instructions\n            if (reg_code === 0)\n                b &= (0xff & ~(1 << bit_number));\n            else if (reg_code === 1)\n                c &= (0xff & ~(1 << bit_number));\n            else if (reg_code === 2)\n                d &= (0xff & ~(1 << bit_number));\n            else if (reg_code === 3)\n                e &= (0xff & ~(1 << bit_number));\n            else if (reg_code === 4)\n                h &= (0xff & ~(1 << bit_number));\n            else if (reg_code === 5)\n                l &= (0xff & ~(1 << bit_number));\n            else if (reg_code === 6)\n                core.mem_write(l | (h << 8),\n                    core.mem_read(l | (h << 8)) & ~(1 << bit_number));\n            else if (reg_code === 7)\n                a &= (0xff & ~(1 << bit_number));\n        }\n        else {\n            // SET instructions\n            if (reg_code === 0)\n                b |= (1 << bit_number);\n            else if (reg_code === 1)\n                c |= (1 << bit_number);\n            else if (reg_code === 2)\n                d |= (1 << bit_number);\n            else if (reg_code === 3)\n                e |= (1 << bit_number);\n            else if (reg_code === 4)\n                h |= (1 << bit_number);\n            else if (reg_code === 5)\n                l |= (1 << bit_number);\n            else if (reg_code === 6)\n                core.mem_write(l | (h << 8),\n                    core.mem_read(l | (h << 8)) | (1 << bit_number));\n            else if (reg_code === 7)\n                a |= (1 << bit_number);\n        }\n\n        cycle_counter += cycle_counts_cb[opcode];\n    };\n    // 0xcc : CALL Z, nn\n    instructions[0xcc] = function () {\n        do_conditional_call(!!flags.Z);\n    };\n    // 0xcd : CALL nn\n    instructions[0xcd] = function () {\n        push_word((pc + 3) & 0xffff);\n        pc = core.mem_read((pc + 1) & 0xffff) |\n            (core.mem_read((pc + 2) & 0xffff) << 8);\n        pc = (pc - 1) & 0xffff;\n    };\n    // 0xce : ADC A, n\n    instructions[0xce] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_adc(core.mem_read(pc));\n    };\n    // 0xcf : RST 08h\n    instructions[0xcf] = function () {\n        do_reset(0x08);\n    };\n    // 0xd0 : RET NC\n    instructions[0xd0] = function () {\n        do_conditional_return(!flags.C);\n    };\n    // 0xd1 : POP DE\n    instructions[0xd1] = function () {\n        var result = pop_word();\n        e = result & 0xff;\n        d = (result & 0xff00) >>> 8;\n    };\n    // 0xd2 : JP NC, nn\n    instructions[0xd2] = function () {\n        do_conditional_absolute_jump(!flags.C);\n    };\n    // 0xd3 : OUT (n), A\n    instructions[0xd3] = function () {\n        pc = (pc + 1) & 0xffff;\n        core.io_write((a << 8) | core.mem_read(pc), a);\n    };\n    // 0xd4 : CALL NC, nn\n    instructions[0xd4] = function () {\n        do_conditional_call(!flags.C);\n    };\n    // 0xd5 : PUSH DE\n    instructions[0xd5] = function () {\n        push_word(e | (d << 8));\n    };\n    // 0xd6 : SUB n\n    instructions[0xd6] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_sub(core.mem_read(pc));\n    };\n    // 0xd7 : RST 10h\n    instructions[0xd7] = function () {\n        do_reset(0x10);\n    };\n    // 0xd8 : RET C\n    instructions[0xd8] = function () {\n        do_conditional_return(!!flags.C);\n    };\n    // 0xd9 : EXX\n    instructions[0xd9] = function () {\n        var temp = b;\n        b = b_prime;\n        b_prime = temp;\n        temp = c;\n        c = c_prime;\n        c_prime = temp;\n        temp = d;\n        d = d_prime;\n        d_prime = temp;\n        temp = e;\n        e = e_prime;\n        e_prime = temp;\n        temp = h;\n        h = h_prime;\n        h_prime = temp;\n        temp = l;\n        l = l_prime;\n        l_prime = temp;\n    };\n    // 0xda : JP C, nn\n    instructions[0xda] = function () {\n        do_conditional_absolute_jump(!!flags.C);\n    };\n    // 0xdb : IN A, (n)\n    instructions[0xdb] = function () {\n        pc = (pc + 1) & 0xffff;\n        a = core.io_read((a << 8) | core.mem_read(pc));\n    };\n    // 0xdc : CALL C, nn\n    instructions[0xdc] = function () {\n        do_conditional_call(!!flags.C);\n    };\n    // 0xdd : DD Prefix (IX instructions)\n    instructions[0xdd] = function () {\n        // R is incremented at the start of the second instruction cycle,\n        //  before the instruction actually runs.\n        // The high bit of R is not affected by this increment,\n        //  it can only be changed using the LD R, A instruction.\n        r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n\n        pc = (pc + 1) & 0xffff;\n        var opcode = core.mem_read(pc),\n            func = dd_instructions[opcode];\n\n        if (func) {\n            //func = func.bind(this);\n            func();\n            cycle_counter += cycle_counts_dd[opcode];\n        }\n        else {\n            // Apparently if a DD opcode doesn't exist,\n            //  it gets treated as an unprefixed opcode.\n            // What we'll do to handle that is just back up the\n            //  program counter, so that this byte gets decoded\n            //  as a normal instruction.\n            pc = (pc - 1) & 0xffff;\n            // And we'll add in the cycle count for a NOP.\n            cycle_counter += cycle_counts[0];\n        }\n    };\n    // 0xde : SBC n\n    instructions[0xde] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_sbc(core.mem_read(pc));\n    };\n    // 0xdf : RST 18h\n    instructions[0xdf] = function () {\n        do_reset(0x18);\n    };\n    // 0xe0 : RET PO\n    instructions[0xe0] = function () {\n        do_conditional_return(!flags.P);\n    };\n    // 0xe1 : POP HL\n    instructions[0xe1] = function () {\n        var result = pop_word();\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n    };\n    // 0xe2 : JP PO, (nn)\n    instructions[0xe2] = function () {\n        do_conditional_absolute_jump(!flags.P);\n    };\n    // 0xe3 : EX (SP), HL\n    instructions[0xe3] = function () {\n        var temp = core.mem_read(sp);\n        core.mem_write(sp, l);\n        l = temp;\n        temp = core.mem_read((sp + 1) & 0xffff);\n        core.mem_write((sp + 1) & 0xffff, h);\n        h = temp;\n    };\n    // 0xe4 : CALL PO, nn\n    instructions[0xe4] = function () {\n        do_conditional_call(!flags.P);\n    };\n    // 0xe5 : PUSH HL\n    instructions[0xe5] = function () {\n        push_word(l | (h << 8));\n    };\n    // 0xe6 : AND n\n    instructions[0xe6] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_and(core.mem_read(pc));\n    };\n    // 0xe7 : RST 20h\n    instructions[0xe7] = function () {\n        do_reset(0x20);\n    };\n    // 0xe8 : RET PE\n    instructions[0xe8] = function () {\n        do_conditional_return(!!flags.P);\n    };\n    // 0xe9 : JP (HL)\n    instructions[0xe9] = function () {\n        pc = l | (h << 8);\n        pc = (pc - 1) & 0xffff;\n    };\n    // 0xea : JP PE, nn\n    instructions[0xea] = function () {\n        do_conditional_absolute_jump(!!flags.P);\n    };\n    // 0xeb : EX DE, HL\n    instructions[0xeb] = function () {\n        var temp = d;\n        d = h;\n        h = temp;\n        temp = e;\n        e = l;\n        l = temp;\n    };\n    // 0xec : CALL PE, nn\n    instructions[0xec] = function () {\n        do_conditional_call(!!flags.P);\n    };\n    // 0xed : ED Prefix\n    instructions[0xed] = function () {\n        // R is incremented at the start of the second instruction cycle,\n        //  before the instruction actually runs.\n        // The high bit of R is not affected by this increment,\n        //  it can only be changed using the LD R, A instruction.\n        r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n\n        pc = (pc + 1) & 0xffff;\n        var opcode = core.mem_read(pc),\n            func = ed_instructions[opcode];\n\n        if (func) {\n            //func = func.bind(this);\n            func();\n            cycle_counter += cycle_counts_ed[opcode];\n        }\n        else {\n            // If the opcode didn't exist, the whole thing is a two-byte NOP.\n            cycle_counter += cycle_counts[0];\n        }\n    };\n    // 0xee : XOR n\n    instructions[0xee] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_xor(core.mem_read(pc));\n    };\n    // 0xef : RST 28h\n    instructions[0xef] = function () {\n        do_reset(0x28);\n    };\n    // 0xf0 : RET P\n    instructions[0xf0] = function () {\n        do_conditional_return(!flags.S);\n    };\n    // 0xf1 : POP AF\n    instructions[0xf1] = function () {\n        var result = pop_word();\n        set_flags_register(result & 0xff);\n        a = (result & 0xff00) >>> 8;\n    };\n    // 0xf2 : JP P, nn\n    instructions[0xf2] = function () {\n        do_conditional_absolute_jump(!flags.S);\n    };\n    // 0xf3 : DI\n    instructions[0xf3] = function () {\n        // DI doesn't actually take effect until after the next instruction.\n        do_delayed_di = true;\n    };\n    // 0xf4 : CALL P, nn\n    instructions[0xf4] = function () {\n        do_conditional_call(!flags.S);\n    };\n    // 0xf5 : PUSH AF\n    instructions[0xf5] = function () {\n        push_word(get_flags_register() | (a << 8));\n    };\n    // 0xf6 : OR n\n    instructions[0xf6] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_or(core.mem_read(pc));\n    };\n    // 0xf7 : RST 30h\n    instructions[0xf7] = function () {\n        do_reset(0x30);\n    };\n    // 0xf8 : RET M\n    instructions[0xf8] = function () {\n        do_conditional_return(!!flags.S);\n    };\n    // 0xf9 : LD SP, HL\n    instructions[0xf9] = function () {\n        sp = l | (h << 8);\n    };\n    // 0xfa : JP M, nn\n    instructions[0xfa] = function () {\n        do_conditional_absolute_jump(!!flags.S);\n    };\n    // 0xfb : EI\n    instructions[0xfb] = function () {\n        // EI doesn't actually take effect until after the next instruction.\n        do_delayed_ei = true;\n    };\n    // 0xfc : CALL M, nn\n    instructions[0xfc] = function () {\n        do_conditional_call(!!flags.S);\n    };\n    // 0xfd : FD Prefix (IY instructions)\n    instructions[0xfd] = function () {\n        // R is incremented at the start of the second instruction cycle,\n        //  before the instruction actually runs.\n        // The high bit of R is not affected by this increment,\n        //  it can only be changed using the LD R, A instruction.\n        r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n\n        pc = (pc + 1) & 0xffff;\n        var opcode = core.mem_read(pc),\n            func = dd_instructions[opcode];\n\n        if (func) {\n            // Rather than copy and paste all the IX instructions into IY instructions,\n            //  what we'll do is sneakily copy IY into IX, run the IX instruction,\n            //  and then copy the result into IY and restore the old IX.\n            var temp = ix;\n            ix = iy;\n            //func = func.bind(this);\n            func();\n            iy = ix;\n            ix = temp;\n\n            cycle_counter += cycle_counts_dd[opcode];\n        }\n        else {\n            // Apparently if an FD opcode doesn't exist,\n            //  it gets treated as an unprefixed opcode.\n            // What we'll do to handle that is just back up the\n            //  program counter, so that this byte gets decoded\n            //  as a normal instruction.\n            pc = (pc - 1) & 0xffff;\n            // And we'll add in the cycle count for a NOP.\n            cycle_counter += cycle_counts[0];\n        }\n    };\n    // 0xfe : CP n\n    instructions[0xfe] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_cp(core.mem_read(pc));\n    };\n    // 0xff : RST 38h\n    instructions[0xff] = function () {\n        do_reset(0x38);\n    };\n\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// This table of ED opcodes is pretty sparse;\n    ///  there are not very many valid ED-prefixed opcodes in the Z80,\n    ///  and many of the ones that are valid are not documented.\n    ///////////////////////////////////////////////////////////////////////////////\n    let ed_instructions = [];\n    // 0x40 : IN B, (C)\n    ed_instructions[0x40] = function () {\n        b = do_in((b << 8) | c);\n    };\n    // 0x41 : OUT (C), B\n    ed_instructions[0x41] = function () {\n        core.io_write((b << 8) | c, b);\n    };\n    // 0x42 : SBC HL, BC\n    ed_instructions[0x42] = function () {\n        do_hl_sbc(c | (b << 8));\n    };\n    // 0x43 : LD (nn), BC\n    ed_instructions[0x43] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        core.mem_write(address, c);\n        core.mem_write((address + 1) & 0xffff, b);\n    };\n    // 0x44 : NEG\n    ed_instructions[0x44] = function () {\n        do_neg();\n    };\n    // 0x45 : RETN\n    ed_instructions[0x45] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x46 : IM 0\n    ed_instructions[0x46] = function () {\n        imode = 0;\n    };\n    // 0x47 : LD I, A\n    ed_instructions[0x47] = function () {\n        i = a\n    };\n    // 0x48 : IN C, (C)\n    ed_instructions[0x48] = function () {\n        c = do_in((b << 8) | c);\n    };\n    // 0x49 : OUT (C), C\n    ed_instructions[0x49] = function () {\n        core.io_write((b << 8) | c, c);\n    };\n    // 0x4a : ADC HL, BC\n    ed_instructions[0x4a] = function () {\n        do_hl_adc(c | (b << 8));\n    };\n    // 0x4b : LD BC, (nn)\n    ed_instructions[0x4b] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        c = core.mem_read(address);\n        b = core.mem_read((address + 1) & 0xffff);\n    };\n    // 0x4c : NEG (Undocumented)\n    ed_instructions[0x4c] = function () {\n        do_neg();\n    };\n    // 0x4d : RETI\n    ed_instructions[0x4d] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n    };\n    // 0x4e : IM 0 (Undocumented)\n    ed_instructions[0x4e] = function () {\n        imode = 0;\n    };\n    // 0x4f : LD R, A\n    ed_instructions[0x4f] = function () {\n        r = a;\n    };\n    // 0x50 : IN D, (C)\n    ed_instructions[0x50] = function () {\n        d = do_in((b << 8) | c);\n    };\n    // 0x51 : OUT (C), D\n    ed_instructions[0x51] = function () {\n        core.io_write((b << 8) | c, d);\n    };\n    // 0x52 : SBC HL, DE\n    ed_instructions[0x52] = function () {\n        do_hl_sbc(e | (d << 8));\n    };\n    // 0x53 : LD (nn), DE\n    ed_instructions[0x53] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        core.mem_write(address, e);\n        core.mem_write((address + 1) & 0xffff, d);\n    };\n    // 0x54 : NEG (Undocumented)\n    ed_instructions[0x54] = function () {\n        do_neg();\n    };\n    // 0x55 : RETN\n    ed_instructions[0x55] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x56 : IM 1\n    ed_instructions[0x56] = function () {\n        imode = 1;\n    };\n    // 0x57 : LD A, I\n    ed_instructions[0x57] = function () {\n        a = i;\n        flags.S = i & 0x80 ? 1 : 0;\n        flags.Z = i ? 0 : 1;\n        flags.H = 0;\n        flags.P = iff2;\n        flags.N = 0;\n    };\n    // 0x58 : IN E, (C)\n    ed_instructions[0x58] = function () {\n        e = do_in((b << 8) | c);\n    };\n    // 0x59 : OUT (C), E\n    ed_instructions[0x59] = function () {\n        core.io_write((b << 8) | c, e);\n    };\n    // 0x5a : ADC HL, DE\n    ed_instructions[0x5a] = function () {\n        do_hl_adc(e | (d << 8));\n    };\n    // 0x5b : LD DE, (nn)\n    ed_instructions[0x5b] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        e = core.mem_read(address);\n        d = core.mem_read((address + 1) & 0xffff);\n    };\n    // 0x5c : NEG (Undocumented)\n    ed_instructions[0x5c] = function () {\n        do_neg();\n    };\n    // 0x5d : RETN\n    ed_instructions[0x5d] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x5e : IM 2\n    ed_instructions[0x5e] = function () {\n        imode = 2;\n    };\n    // 0x5f : LD A, R\n    ed_instructions[0x5f] = function () {\n        a = r;\n        flags.P = iff2;\n    };\n    // 0x60 : IN H, (C)\n    ed_instructions[0x60] = function () {\n        h = do_in((b << 8) | c);\n    };\n    // 0x61 : OUT (C), H\n    ed_instructions[0x61] = function () {\n        core.io_write((b << 8) | c, h);\n    };\n    // 0x62 : SBC HL, HL\n    ed_instructions[0x62] = function () {\n        do_hl_sbc(l | (h << 8));\n    };\n    // 0x63 : LD (nn), HL (Undocumented)\n    ed_instructions[0x63] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        core.mem_write(address, l);\n        core.mem_write((address + 1) & 0xffff, h);\n    };\n    // 0x64 : NEG (Undocumented)\n    ed_instructions[0x64] = function () {\n        do_neg();\n    };\n    // 0x65 : RETN\n    ed_instructions[0x65] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x66 : IM 0\n    ed_instructions[0x66] = function () {\n        imode = 0;\n    };\n    // 0x67 : RRD\n    ed_instructions[0x67] = function () {\n        var hl_value = core.mem_read(l | (h << 8));\n        var temp1 = hl_value & 0x0f, temp2 = a & 0x0f;\n        hl_value = ((hl_value & 0xf0) >>> 4) | (temp2 << 4);\n        a = (a & 0xf0) | temp1;\n        core.mem_write(l | (h << 8), hl_value);\n\n        flags.S = (a & 0x80) ? 1 : 0;\n        flags.Z = a ? 0 : 1;\n        flags.H = 0;\n        flags.P = get_parity(a) ? 1 : 0;\n        flags.N = 0;\n        update_xy_flags(a);\n    };\n    // 0x68 : IN L, (C)\n    ed_instructions[0x68] = function () {\n        l = do_in((b << 8) | c);\n    };\n    // 0x69 : OUT (C), L\n    ed_instructions[0x69] = function () {\n        core.io_write((b << 8) | c, l);\n    };\n    // 0x6a : ADC HL, HL\n    ed_instructions[0x6a] = function () {\n        do_hl_adc(l | (h << 8));\n    };\n    // 0x6b : LD HL, (nn) (Undocumented)\n    ed_instructions[0x6b] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        l = core.mem_read(address);\n        h = core.mem_read((address + 1) & 0xffff);\n    };\n    // 0x6c : NEG (Undocumented)\n    ed_instructions[0x6c] = function () {\n        do_neg();\n    };\n    // 0x6d : RETN\n    ed_instructions[0x6d] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x6e : IM 0 (Undocumented)\n    ed_instructions[0x6e] = function () {\n        imode = 0;\n    };\n    // 0x6f : RLD\n    ed_instructions[0x6f] = function () {\n        var hl_value = core.mem_read(l | (h << 8));\n        var temp1 = hl_value & 0xf0, temp2 = a & 0x0f;\n        hl_value = ((hl_value & 0x0f) << 4) | temp2;\n        a = (a & 0xf0) | (temp1 >>> 4);\n        core.mem_write(l | (h << 8), hl_value);\n\n        flags.S = (a & 0x80) ? 1 : 0;\n        flags.Z = a ? 0 : 1;\n        flags.H = 0;\n        flags.P = get_parity(a) ? 1 : 0;\n        flags.N = 0;\n        update_xy_flags(a);\n    };\n    // 0x70 : IN (C) (Undocumented)\n    ed_instructions[0x70] = function () {\n        do_in((b << 8) | c);\n    };\n    // 0x71 : OUT (C), 0 (Undocumented)\n    ed_instructions[0x71] = function () {\n        core.io_write((b << 8) | c, 0);\n    };\n    // 0x72 : SBC HL, SP\n    ed_instructions[0x72] = function () {\n        do_hl_sbc(sp);\n    };\n    // 0x73 : LD (nn), SP\n    ed_instructions[0x73] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        core.mem_write(address, sp & 0xff);\n        core.mem_write((address + 1) & 0xffff, (sp >>> 8) & 0xff);\n    };\n    // 0x74 : NEG (Undocumented)\n    ed_instructions[0x74] = function () {\n        do_neg();\n    };\n    // 0x75 : RETN\n    ed_instructions[0x75] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x76 : IM 1\n    ed_instructions[0x76] = function () {\n        imode = 1;\n    };\n    // 0x78 : IN A, (C)\n    ed_instructions[0x78] = function () {\n        a = do_in((b << 8) | c);\n    };\n    // 0x79 : OUT (C), A\n    ed_instructions[0x79] = function () {\n        core.io_write((b << 8) | c, a);\n    };\n    // 0x7a : ADC HL, SP\n    ed_instructions[0x7a] = function () {\n        do_hl_adc(sp);\n    };\n    // 0x7b : LD SP, (nn)\n    ed_instructions[0x7b] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        sp = core.mem_read(address);\n        sp |= core.mem_read((address + 1) & 0xffff) << 8;\n    };\n    // 0x7c : NEG (Undocumented)\n    ed_instructions[0x7c] = function () {\n        do_neg();\n    };\n    // 0x7d : RETN\n    ed_instructions[0x7d] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x7e : IM 2\n    ed_instructions[0x7e] = function () {\n        imode = 2;\n    };\n    // 0xa0 : LDI\n    ed_instructions[0xa0] = function () {\n        do_ldi();\n    };\n    // 0xa1 : CPI\n    ed_instructions[0xa1] = function () {\n        do_cpi();\n    };\n    // 0xa2 : INI\n    ed_instructions[0xa2] = function () {\n        do_ini();\n    };\n    // 0xa3 : OUTI\n    ed_instructions[0xa3] = function () {\n        do_outi();\n    };\n    // 0xa8 : LDD\n    ed_instructions[0xa8] = function () {\n        do_ldd();\n    };\n    // 0xa9 : CPD\n    ed_instructions[0xa9] = function () {\n        do_cpd();\n    };\n    // 0xaa : IND\n    ed_instructions[0xaa] = function () {\n        do_ind();\n    };\n    // 0xab : OUTD\n    ed_instructions[0xab] = function () {\n        do_outd();\n    };\n    // 0xb0 : LDIR\n    ed_instructions[0xb0] = function () {\n        do_ldi();\n        if (b || c) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xb1 : CPIR\n    ed_instructions[0xb1] = function () {\n        do_cpi();\n        if (!flags.Z && (b || c)) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xb2 : INIR\n    ed_instructions[0xb2] = function () {\n        do_ini();\n        if (b) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xb3 : OTIR\n    ed_instructions[0xb3] = function () {\n        do_outi();\n        if (b) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xb8 : LDDR\n    ed_instructions[0xb8] = function () {\n        do_ldd();\n        if (b || c) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xb9 : CPDR\n    ed_instructions[0xb9] = function () {\n        do_cpd();\n        if (!flags.Z && (b || c)) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xba : INDR\n    ed_instructions[0xba] = function () {\n        do_ind();\n        if (b) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xbb : OTDR\n    ed_instructions[0xbb] = function () {\n        do_outd();\n        if (b) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// Like ED, this table is quite sparse,\n    ///  and many of the opcodes here are also undocumented.\n    /// The undocumented instructions here are those that deal with only one byte\n    ///  of the two-byte IX register; the bytes are designed IXH and IXL here.\n    ///////////////////////////////////////////////////////////////////////////////\n    let dd_instructions = [];\n    // 0x09 : ADD IX, BC\n    dd_instructions[0x09] = function () {\n        do_ix_add(c | (b << 8));\n    };\n    // 0x19 : ADD IX, DE\n    dd_instructions[0x19] = function () {\n        do_ix_add(e | (d << 8));\n    };\n    // 0x21 : LD IX, nn\n    dd_instructions[0x21] = function () {\n        pc = (pc + 1) & 0xffff;\n        ix = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        ix |= (core.mem_read(pc) << 8);\n    };\n    // 0x22 : LD (nn), IX\n    dd_instructions[0x22] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= (core.mem_read(pc) << 8);\n\n        core.mem_write(address, ix & 0xff);\n        core.mem_write((address + 1) & 0xffff, (ix >>> 8) & 0xff);\n    };\n    // 0x23 : INC IX\n    dd_instructions[0x23] = function () {\n        ix = (ix + 1) & 0xffff;\n    };\n    // 0x24 : INC IXH (Undocumented)\n    dd_instructions[0x24] = function () {\n        ix = (do_inc(ix >>> 8) << 8) | (ix & 0xff);\n    };\n    // 0x25 : DEC IXH (Undocumented)\n    dd_instructions[0x25] = function () {\n        ix = (do_dec(ix >>> 8) << 8) | (ix & 0xff);\n    };\n    // 0x26 : LD IXH, n (Undocumented)\n    dd_instructions[0x26] = function () {\n        pc = (pc + 1) & 0xffff;\n        ix = (core.mem_read(pc) << 8) | (ix & 0xff);\n    };\n    // 0x29 : ADD IX, IX\n    dd_instructions[0x29] = function () {\n        do_ix_add(ix);\n    };\n    // 0x2a : LD IX, (nn)\n    dd_instructions[0x2a] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= (core.mem_read(pc) << 8);\n\n        ix = core.mem_read(address);\n        ix |= (core.mem_read((address + 1) & 0xffff) << 8);\n    };\n    // 0x2b : DEC IX\n    dd_instructions[0x2b] = function () {\n        ix = (ix - 1) & 0xffff;\n    };\n    // 0x2c : INC IXL (Undocumented)\n    dd_instructions[0x2c] = function () {\n        ix = do_inc(ix & 0xff) | (ix & 0xff00);\n    };\n    // 0x2d : DEC IXL (Undocumented)\n    dd_instructions[0x2d] = function () {\n        ix = do_dec(ix & 0xff) | (ix & 0xff00);\n    };\n    // 0x2e : LD IXL, n (Undocumented)\n    dd_instructions[0x2e] = function () {\n        pc = (pc + 1) & 0xffff;\n        ix = (core.mem_read(pc) & 0xff) | (ix & 0xff00);\n    };\n    // 0x34 : INC (IX+n)\n    dd_instructions[0x34] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc)),\n            value = core.mem_read((offset + ix) & 0xffff);\n        core.mem_write((offset + ix) & 0xffff, do_inc(value));\n    };\n    // 0x35 : DEC (IX+n)\n    dd_instructions[0x35] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc)),\n            value = core.mem_read((offset + ix) & 0xffff);\n        core.mem_write((offset + ix) & 0xffff, do_dec(value));\n    };\n    // 0x36 : LD (IX+n), n\n    dd_instructions[0x36] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        pc = (pc + 1) & 0xffff;\n        core.mem_write((ix + offset) & 0xffff, core.mem_read(pc));\n    };\n    // 0x39 : ADD IX, SP\n    dd_instructions[0x39] = function () {\n        do_ix_add(sp);\n    };\n    // 0x44 : LD B, IXH (Undocumented)\n    dd_instructions[0x44] = function () {\n        b = (ix >>> 8) & 0xff;\n    };\n    // 0x45 : LD B, IXL (Undocumented)\n    dd_instructions[0x45] = function () {\n        b = ix & 0xff;\n    };\n    // 0x46 : LD B, (IX+n)\n    dd_instructions[0x46] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        b = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x4c : LD C, IXH (Undocumented)\n    dd_instructions[0x4c] = function () {\n        c = (ix >>> 8) & 0xff;\n    };\n    // 0x4d : LD C, IXL (Undocumented)\n    dd_instructions[0x4d] = function () {\n        c = ix & 0xff;\n    };\n    // 0x4e : LD C, (IX+n)\n    dd_instructions[0x4e] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        c = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x54 : LD D, IXH (Undocumented)\n    dd_instructions[0x54] = function () {\n        d = (ix >>> 8) & 0xff;\n    };\n    // 0x55 : LD D, IXL (Undocumented)\n    dd_instructions[0x55] = function () {\n        d = ix & 0xff;\n    };\n    // 0x56 : LD D, (IX+n)\n    dd_instructions[0x56] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        d = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x5c : LD E, IXH (Undocumented)\n    dd_instructions[0x5c] = function () {\n        e = (ix >>> 8) & 0xff;\n    };\n    // 0x5d : LD E, IXL (Undocumented)\n    dd_instructions[0x5d] = function () {\n        e = ix & 0xff;\n    };\n    // 0x5e : LD E, (IX+n)\n    dd_instructions[0x5e] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        e = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x60 : LD IXH, B (Undocumented)\n    dd_instructions[0x60] = function () {\n        ix = (ix & 0xff) | (b << 8);\n    };\n    // 0x61 : LD IXH, C (Undocumented)\n    dd_instructions[0x61] = function () {\n        ix = (ix & 0xff) | (c << 8);\n    };\n    // 0x62 : LD IXH, D (Undocumented)\n    dd_instructions[0x62] = function () {\n        ix = (ix & 0xff) | (d << 8);\n    };\n    // 0x63 : LD IXH, E (Undocumented)\n    dd_instructions[0x63] = function () {\n        ix = (ix & 0xff) | (e << 8);\n    };\n    // 0x64 : LD IXH, IXH (Undocumented)\n    dd_instructions[0x64] = function () {\n        // No-op.\n    };\n    // 0x65 : LD IXH, IXL (Undocumented)\n    dd_instructions[0x65] = function () {\n        ix = (ix & 0xff) | ((ix & 0xff) << 8);\n    };\n    // 0x66 : LD H, (IX+n)\n    dd_instructions[0x66] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        h = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x67 : LD IXH, A (Undocumented)\n    dd_instructions[0x67] = function () {\n        ix = (ix & 0xff) | (a << 8);\n    };\n    // 0x68 : LD IXL, B (Undocumented)\n    dd_instructions[0x68] = function () {\n        ix = (ix & 0xff00) | b;\n    };\n    // 0x69 : LD IXL, C (Undocumented)\n    dd_instructions[0x69] = function () {\n        ix = (ix & 0xff00) | c;\n    };\n    // 0x6a : LD IXL, D (Undocumented)\n    dd_instructions[0x6a] = function () {\n        ix = (ix & 0xff00) | d;\n    };\n    // 0x6b : LD IXL, E (Undocumented)\n    dd_instructions[0x6b] = function () {\n        ix = (ix & 0xff00) | e;\n    };\n    // 0x6c : LD IXL, IXH (Undocumented)\n    dd_instructions[0x6c] = function () {\n        ix = (ix & 0xff00) | (ix >>> 8);\n    };\n    // 0x6d : LD IXL, IXL (Undocumented)\n    dd_instructions[0x6d] = function () {\n        // No-op.\n    };\n    // 0x6e : LD L, (IX+n)\n    dd_instructions[0x6e] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        l = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x6f : LD IXL, A (Undocumented)\n    dd_instructions[0x6f] = function () {\n        ix = (ix & 0xff00) | a;\n    };\n    // 0x70 : LD (IX+n), B\n    dd_instructions[0x70] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, b);\n    };\n    // 0x71 : LD (IX+n), C\n    dd_instructions[0x71] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, c);\n    };\n    // 0x72 : LD (IX+n), D\n    dd_instructions[0x72] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, d);\n    };\n    // 0x73 : LD (IX+n), E\n    dd_instructions[0x73] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, e);\n    };\n    // 0x74 : LD (IX+n), H\n    dd_instructions[0x74] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, h);\n    };\n    // 0x75 : LD (IX+n), L\n    dd_instructions[0x75] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, l);\n    };\n    // 0x77 : LD (IX+n), A\n    dd_instructions[0x77] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, a);\n    };\n    // 0x7c : LD A, IXH (Undocumented)\n    dd_instructions[0x7c] = function () {\n        a = (ix >>> 8) & 0xff;\n    };\n    // 0x7d : LD A, IXL (Undocumented)\n    dd_instructions[0x7d] = function () {\n        a = ix & 0xff;\n    };\n    // 0x7e : LD A, (IX+n)\n    dd_instructions[0x7e] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        a = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x84 : ADD A, IXH (Undocumented)\n    dd_instructions[0x84] = function () {\n        do_add((ix >>> 8) & 0xff);\n    };\n    // 0x85 : ADD A, IXL (Undocumented)\n    dd_instructions[0x85] = function () {\n        do_add(ix & 0xff);\n    };\n    // 0x86 : ADD A, (IX+n)\n    dd_instructions[0x86] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_add(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0x8c : ADC A, IXH (Undocumented)\n    dd_instructions[0x8c] = function () {\n        do_adc((ix >>> 8) & 0xff);\n    };\n    // 0x8d : ADC A, IXL (Undocumented)\n    dd_instructions[0x8d] = function () {\n        do_adc(ix & 0xff);\n    };\n    // 0x8e : ADC A, (IX+n)\n    dd_instructions[0x8e] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_adc(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0x94 : SUB IXH (Undocumented)\n    dd_instructions[0x94] = function () {\n        do_sub((ix >>> 8) & 0xff);\n    };\n    // 0x95 : SUB IXL (Undocumented)\n    dd_instructions[0x95] = function () {\n        do_sub(ix & 0xff);\n    };\n    // 0x96 : SUB A, (IX+n)\n    dd_instructions[0x96] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_sub(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0x9c : SBC IXH (Undocumented)\n    dd_instructions[0x9c] = function () {\n        do_sbc((ix >>> 8) & 0xff);\n    };\n    // 0x9d : SBC IXL (Undocumented)\n    dd_instructions[0x9d] = function () {\n        do_sbc(ix & 0xff);\n    };\n    // 0x9e : SBC A, (IX+n)\n    dd_instructions[0x9e] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_sbc(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0xa4 : AND IXH (Undocumented)\n    dd_instructions[0xa4] = function () {\n        do_and((ix >>> 8) & 0xff);\n    };\n    // 0xa5 : AND IXL (Undocumented)\n    dd_instructions[0xa5] = function () {\n        do_and(ix & 0xff);\n    };\n    // 0xa6 : AND A, (IX+n)\n    dd_instructions[0xa6] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_and(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0xac : XOR IXH (Undocumented)\n    dd_instructions[0xac] = function () {\n        do_xor((ix >>> 8) & 0xff);\n    };\n    // 0xad : XOR IXL (Undocumented)\n    dd_instructions[0xad] = function () {\n        do_xor(ix & 0xff);\n    };\n    // 0xae : XOR A, (IX+n)\n    dd_instructions[0xae] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_xor(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0xb4 : OR IXH (Undocumented)\n    dd_instructions[0xb4] = function () {\n        do_or((ix >>> 8) & 0xff);\n    };\n    // 0xb5 : OR IXL (Undocumented)\n    dd_instructions[0xb5] = function () {\n        do_or(ix & 0xff);\n    };\n    // 0xb6 : OR A, (IX+n)\n    dd_instructions[0xb6] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_or(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0xbc : CP IXH (Undocumented)\n    dd_instructions[0xbc] = function () {\n        do_cp((ix >>> 8) & 0xff);\n    };\n    // 0xbd : CP IXL (Undocumented)\n    dd_instructions[0xbd] = function () {\n        do_cp(ix & 0xff);\n    };\n    // 0xbe : CP A, (IX+n)\n    dd_instructions[0xbe] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_cp(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0xcb : CB Prefix (IX bit instructions)\n    dd_instructions[0xcb] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        pc = (pc + 1) & 0xffff;\n        var opcode = core.mem_read(pc), value;\n\n        // As with the \"normal\" CB prefix, we implement the DDCB prefix\n        //  by decoding the opcode directly, rather than using a table.\n        if (opcode < 0x40) {\n            // Shift and rotate instructions.\n            var ddcb_functions = [do_rlc, do_rrc, do_rl, do_rr,\n                do_sla, do_sra, do_sll, do_srl];\n\n            // Most of the opcodes in this range are not valid,\n            //  so we map this opcode onto one of the ones that is.\n            var func = ddcb_functions[(opcode & 0x38) >>> 3],\n                value = func(core.mem_read((ix + offset) & 0xffff));\n\n            core.mem_write((ix + offset) & 0xffff, value);\n        }\n        else {\n            var bit_number = (opcode & 0x38) >>> 3;\n\n            if (opcode < 0x80) {\n                // BIT\n                flags.N = 0;\n                flags.H = 1;\n                flags.Z = !(core.mem_read((ix + offset) & 0xffff) & (1 << bit_number)) ? 1 : 0;\n                flags.P = flags.Z;\n                flags.S = ((bit_number === 7) && !flags.Z) ? 1 : 0;\n            }\n            else if (opcode < 0xc0) {\n                // RES\n                value = core.mem_read((ix + offset) & 0xffff) & ~(1 << bit_number) & 0xff;\n                core.mem_write((ix + offset) & 0xffff, value);\n            }\n            else {\n                // SET\n                value = core.mem_read((ix + offset) & 0xffff) | (1 << bit_number);\n                core.mem_write((ix + offset) & 0xffff, value);\n            }\n        }\n\n        // This implements the undocumented shift, RES, and SET opcodes,\n        //  which write their result to memory and also to an 8080 register.\n        if (value !== undefined) {\n            if ((opcode & 0x07) === 0)\n                b = value;\n            else if ((opcode & 0x07) === 1)\n                c = value;\n            else if ((opcode & 0x07) === 2)\n                d = value;\n            else if ((opcode & 0x07) === 3)\n                e = value;\n            else if ((opcode & 0x07) === 4)\n                h = value;\n            else if ((opcode & 0x07) === 5)\n                l = value;\n            // 6 is the documented opcode, which doesn't set a register.\n            else if ((opcode & 0x07) === 7)\n                a = value;\n        }\n\n        cycle_counter += cycle_counts_cb[opcode] + 8;\n    };\n    // 0xe1 : POP IX\n    dd_instructions[0xe1] = function () {\n        ix = pop_word();\n    };\n    // 0xe3 : EX (SP), IX\n    dd_instructions[0xe3] = function () {\n        var temp = ix;\n        ix = core.mem_read(sp);\n        ix |= core.mem_read((sp + 1) & 0xffff) << 8;\n        core.mem_write(sp, temp & 0xff);\n        core.mem_write((sp + 1) & 0xffff, (temp >>> 8) & 0xff);\n    };\n    // 0xe5 : PUSH IX\n    dd_instructions[0xe5] = function () {\n        push_word(ix);\n    };\n    // 0xe9 : JP (IX)\n    dd_instructions[0xe9] = function () {\n        pc = (ix - 1) & 0xffff;\n    };\n    // 0xf9 : LD SP, IX\n    dd_instructions[0xf9] = function () {\n        sp = ix;\n    };\n\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// These tables contain the number of T cycles used for each instruction.\n    /// In a few special cases, such as conditional control flow instructions,\n    ///  additional cycles might be added to these values.\n    /// The total number of cycles is the return value of run_instruction().\n    ///////////////////////////////////////////////////////////////////////////////\n    let cycle_counts = [\n        4, 10, 7, 6, 4, 4, 7, 4, 4, 11, 7, 6, 4, 4, 7, 4,\n        8, 10, 7, 6, 4, 4, 7, 4, 12, 11, 7, 6, 4, 4, 7, 4,\n        7, 10, 16, 6, 4, 4, 7, 4, 7, 11, 16, 6, 4, 4, 7, 4,\n        7, 10, 13, 6, 11, 11, 10, 4, 7, 11, 13, 6, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        7, 7, 7, 7, 7, 7, 4, 7, 4, 4, 4, 4, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        5, 10, 10, 10, 10, 11, 7, 11, 5, 10, 10, 0, 10, 17, 7, 11,\n        5, 10, 10, 11, 10, 11, 7, 11, 5, 4, 10, 11, 10, 0, 7, 11,\n        5, 10, 10, 19, 10, 11, 7, 11, 5, 4, 10, 4, 10, 0, 7, 11,\n        5, 10, 10, 4, 10, 11, 7, 11, 5, 6, 10, 4, 10, 0, 7, 11\n    ];\n\n    let cycle_counts_ed = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        12, 12, 15, 20, 8, 14, 8, 9, 12, 12, 15, 20, 8, 14, 8, 9,\n        12, 12, 15, 20, 8, 14, 8, 9, 12, 12, 15, 20, 8, 14, 8, 9,\n        12, 12, 15, 20, 8, 14, 8, 18, 12, 12, 15, 20, 8, 14, 8, 18,\n        12, 12, 15, 20, 8, 14, 8, 0, 12, 12, 15, 20, 8, 14, 8, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        16, 16, 16, 16, 0, 0, 0, 0, 16, 16, 16, 16, 0, 0, 0, 0,\n        16, 16, 16, 16, 0, 0, 0, 0, 16, 16, 16, 16, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    ];\n\n    let cycle_counts_cb = [\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 12, 8, 8, 8, 8, 8, 8, 8, 12, 8,\n        8, 8, 8, 8, 8, 8, 12, 8, 8, 8, 8, 8, 8, 8, 12, 8,\n        8, 8, 8, 8, 8, 8, 12, 8, 8, 8, 8, 8, 8, 8, 12, 8,\n        8, 8, 8, 8, 8, 8, 12, 8, 8, 8, 8, 8, 8, 8, 12, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8\n    ];\n\n    let cycle_counts_dd = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0,\n        0, 14, 20, 10, 8, 8, 11, 0, 0, 15, 20, 10, 8, 8, 11, 0,\n        0, 0, 0, 0, 23, 23, 19, 0, 0, 15, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,\n        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,\n        8, 8, 8, 8, 8, 8, 19, 8, 8, 8, 8, 8, 8, 8, 19, 8,\n        19, 19, 19, 19, 19, 19, 0, 19, 0, 0, 0, 0, 8, 8, 19, 0,\n        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,\n        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,\n        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,\n        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 14, 0, 23, 0, 15, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0\n    ];\n\n    // There's tons of stuff in this object,\n    //  but only these three functions are the public API.\n    return {\n        getState,\n        setState,\n        reset,\n        reset1,\n        run_instruction,\n        interrupt,\n    };\n}","export const ROM =\n`:10000000C38005FFFFFFFFFFC32003FFFFFFFFFFCC\n:10001000C3E003FFFFFFFFFFC39004FFFFFFFFFFED\n:10002000FFFFFFFFFFFFFFFF213002C34100FFFF83\n:10003000213005C34100FFFF21D102220008C37017\n:1000400002220008C3B001FFFFFFFFFFFFFFFFFF19\n:10005000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB0\n:10006000FFFFFFFFFFFFDB00E61FED47C931F00F89\n:10007000CD3101CD8E013AF90FFE00C29600ED5749\n:10008000FE10DA8800C3E30021F70FCD6F01ED6F9A\n:1000900023ED6FC3DA00ED57FE10DAB700AF32FA86\n:1000A0000FED57FE13CADA00FE12CAC200FE11CAD3\n:1000B000C600FE10CAD0002AF70FCD7B01ED6FC33A\n:1000C000E3002AF70FE92AF70F2B22F70FC3E3000B\n:1000D0002AF70F2322F70FC3E3003E00060421F3A3\n:1000E0000F18073E67060221F10F32F90FD9ED5BB9\n:1000F000F70FCD02011ACD0E01D9CBE62310FBC3B9\n:100100006D0021F30F7BCD15017ACD1501C921F1C9\n:100110000FCD1501C9F5CD26017723F10F0F0F0F74\n:10012000CD26017723C9E5215F01E60F856F7EE1CA\n:10013000C93EFFED47CD4001ED57FEFFC0C3310181\n:10014000DDE5010106DD7E00D302DD2379D301CB9D\n:10015000274F3E0A3DC25401D30110E9DDE1C9EB4E\n:1001600028CDAD2EA7E729EF2F6FE6C3ECC747CD0B\n:100170007B01C0233E00772BED57C9ED57473AFA74\n:100180000FFE0078C0AF773D32FA0F78C9000E0A33\n:1001900021500029110100AFD3023DD3014110FECF\n:1001A000EE80ED5220F5C9FFFFFFFFFFFFFFFFFFCD\n:1001B000ED5B00081AE61FFE1FC80000FE1ECAB055\n:1001C00001FE00CAE9014713D521F801CDE301F58D\n:1001D00078211002CDE3016F2600F14FCD9301D1BC\n:1001E000C3B4015F1600197EC9D51100101B7AB384\n:1001F000C2ED01D113C3B4018C837C757067625C5E\n:1002000057524E4845413C3936322F2C2A27252358\n:10021000191A1C1D1E20232527292C2E3133373A6D\n:100220003D4145494D52575C10FFFFFFFFFFFFFF67\n:1002300006060A0D060D0A0D121614120F11120FE2\n:100240000D0D0D0A120F0D0A0806080A0F0A0D0FF0\n:1002500006060A0D060D0A0D121614120F11120FC2\n:100260000D0D0D0A120F0D0A0806080A0612001ECF\n:10027000FD2A0008DD21F10F060621F10F360023CB\n:1002800010FB060611F70F21F60F7E122B1B10FA3A\n:10029000FD7E00FD23E61FFE1FC8FE1E28D221B3EF\n:1002A00002CDE30132F10F3E80F5CD4001F13D205A\n:1002B000F818CF006FE6C3ECC747E36E28E8CEC25C\n:1002C00064EB4F2F44A746E0A9AECD041018000000\n:1002D0000008050C0C0E0013080511050013080991\n:1002E0001200091200130805001305031809191953\n:1002F000191904051209070D0504000216000A0E5B\n:10030000080D00080111041600060E110013051A4D\n:100310000000000000001EFFFFFFFFFFFFFFFFFFC8\n:10032000DD21F10FAF32FA0F32FB0F060621F10F7C\n:1003300036002310FB3AF50FFE00203711F50F2190\n:10034000F40F06047E122B1B10FAED5FCDB50332BD\n:10035000F10F3E0000F53EFFED473AFB0FCDB50330\n:1003600032F60FCD4001ED57FEFFC48E03F13D2064\n:10037000E418C2CD8E01060621F10F36002310FBD2\n:100380003AFA0F21F30FCD1501CD31011892FE106D\n:1003900020083AFB0F3C32FB0FC93AF60F4F21F50C\n:1003A0000F06057EB9200A36003AFA0F3C2732FACA\n:1003B0000F2B10EFC9E607CD2601C9160E14000C4D\n:1003C0000E1205001213140F09041A1F0E08000D57\n:1003D0000E19191909000C0E12131A1FFFFFFFFF47\n:1003E000DD21F10F3E2332FA0F21F10F0606360010\n:1003F0002310FB1E00CD6604CD3101ED57FE043005\n:10040000F4FE0028F05F3AFA0FBB284438429327E5\n:1004100032FA0FCD660421F60F36AE1600CD40013C\n:100420001520FA3AFA0FFE01282C3D27D604273072\n:10043000FBC60427FE0028105F3AFA0F932732FA12\n:100440000F21F60F362818ADED5FE603282818E8CF\n:1004500011BB03C3590411CC03ED530008CD700246\n:10046000CD3101C3E00321F10F3AFA0FCD1501237D\n:100470007BCD260177C93CC33804FF14121417172B\n:100480001214101F0111011101111FFFFFFFFFFFC7\n:10049000DD21F10FFD2100083E50FD77003E20FDDB\n:1004A0007701AFFD770221F10F060636002310FB1E\n:1004B0001680FD7E0121F10FCD15012323FD7E0065\n:1004C000CD15013EFFED47CD4001ED57FEFFC4F3D2\n:1004D0000415C2B204FD7E02D60127FD770247FD56\n:1004E0007E008027FE00CA1105FE60301BFD7700EC\n:1004F000C3B004FD7E01FE00C83D27FD7701FD7EEF\n:1005000002C60227FD7702C9118404DD210000180C\n:1005100003117B04ED530008CDB001CD3101C39030\n:1005200004FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD6\n:100530000B0A080A0A0A0606060B0A080A0A0A0A29\n:100540000A0A0B0A080A0A0A0606060A080A0D0D14\n:100550000D0D0D000D05080B0B0B0606060B0A080A\n:100560000A0A0A0606060B0A0608080808080A0B03\n:100570000A080606060606060000001EFFFFFFFF2B\n:1005800021000831F00FDD21F10F22F70FAF32F912\n:100590000F32FA0F0E0A215000CD93010E202130A8\n:1005A00000CD9301C3E300FFFFFFFFFFFFFFFFFF4D\n:1005B000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4B\n:1005C000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3B\n:1005D000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2B\n:1005E000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF1B\n:1005F000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0B\n:10060000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA\n:10061000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEA\n:10062000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDA\n:10063000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFCA\n:10064000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBA\n:10065000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFAA\n:10066000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF9A\n:10067000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8A\n:10068000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7A\n:10069000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF6A\n:1006A000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5A\n:1006B000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4A\n:1006C000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3A\n:1006D000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2A\n:1006E000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF1A\n:1006F000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0A\n:10070000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF9\n:10071000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE9\n:10072000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD9\n:10073000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC9\n:10074000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB9\n:10075000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA9\n:10076000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF99\n:10077000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF89\n:10078000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF79\n:10079000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF69\n:1007A000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF59\n:1007B000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF49\n:1007C000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF39\n:1007D000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF29\n:1007E000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF19\n:1007F000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF09\n:00000001FF\n`;\n","\n/**\n * Parser/writer for the \"Intel hex\" format.\n */\n\n/*\n * A regexp that matches lines in a .hex file.\n *\n * One hexadecimal character is matched by \"[0-9A-Fa-f]\".\n * Two hex characters are matched by \"[0-9A-Fa-f]{2}\"\n * Eight or more hex characters are matched by \"[0-9A-Fa-f]{8,}\"\n * A capture group of two hex characters is \"([0-9A-Fa-f]{2})\"\n *\n * Record mark         :\n * 8 or more hex chars  ([0-9A-Fa-f]{8,})\n * Checksum                              ([0-9A-Fa-f]{2})\n * Optional newline                                      (?:\\r\\n|\\r|\\n|)\n */\nconst hexLineRegexp = /:([0-9A-Fa-f]{8,})([0-9A-Fa-f]{2})(?:\\r\\n|\\r|\\n|)/g;\n\n\n// Takes a Uint8Array as input,\n// Returns an integer in the 0-255 range.\nfunction checksum(bytes) {\n    return (-bytes.reduce((sum, v)=>sum + v, 0)) & 0xFF;\n}\n\n// Takes two Uint8Arrays as input,\n// Returns an integer in the 0-255 range.\nfunction checksumTwo(array1, array2) {\n    const partial1 = array1.reduce((sum, v)=>sum + v, 0);\n    const partial2 = array2.reduce((sum, v)=>sum + v, 0);\n    return -( partial1 + partial2 ) & 0xFF;\n}\n\n\n// Trivial utility. Converts a number to hex and pads with zeroes up to 2 characters.\nfunction hexpad(number) {\n    return number.toString(16).toUpperCase().padStart(2, '0');\n}\n\n\n// Polyfill as per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\nNumber.isInteger = Number.isInteger || function(value) {\n    return typeof value === 'number' &&\n    isFinite(value) &&\n    Math.floor(value) === value;\n};\n\n\n/**\n * @class MemoryMap\n *\n * Represents the contents of a memory layout, with main focus into (possibly sparse) blocks of data.\n *<br/>\n * A {@linkcode MemoryMap} acts as a subclass of\n * {@linkcode https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Map|Map}.\n * In every entry of it, the key is the starting address of a data block (an integer number),\n * and the value is the <tt>Uint8Array</tt> with the data for that block.\n *<br/>\n * The main rationale for this is that a .hex file can contain a single block of contiguous\n * data starting at memory address 0 (and it's the common case for simple .hex files),\n * but complex files with several non-contiguous data blocks are also possible, thus\n * the need for a data structure on top of the <tt>Uint8Array</tt>s.\n *<br/>\n * In order to parse <tt>.hex</tt> files, use the {@linkcode MemoryMap.fromHex} <em>static</em> factory\n * method. In order to write <tt>.hex</tt> files, create a new {@linkcode MemoryMap} and call\n * its {@linkcode MemoryMap.asHexString} method.\n *\n * @extends Map\n * @example\n * import MemoryMap from 'nrf-intel-hex';\n *\n * let memMap1 = new MemoryMap();\n * let memMap2 = new MemoryMap([[0, new Uint8Array(1,2,3,4)]]);\n * let memMap3 = new MemoryMap({0: new Uint8Array(1,2,3,4)});\n * let memMap4 = new MemoryMap({0xCF0: new Uint8Array(1,2,3,4)});\n */\nclass MemoryMap {\n    /**\n     * @param {Iterable} blocks The initial value for the memory blocks inside this\n     * <tt>MemoryMap</tt>. All keys must be numeric, and all values must be instances of\n     * <tt>Uint8Array</tt>. Optionally it can also be a plain <tt>Object</tt> with\n     * only numeric keys.\n     */\n    constructor(blocks) {\n        this._blocks = new Map();\n\n        if (blocks && typeof blocks[Symbol.iterator] === 'function') {\n            for (const tuple of blocks) {\n                if (!(tuple instanceof Array) || tuple.length !== 2) {\n                    throw new Error('First parameter to MemoryMap constructor must be an iterable of [addr, bytes] or undefined');\n                }\n                this.set(tuple[0], tuple[1]);\n            }\n        } else if (typeof blocks === 'object') {\n            // Try iterating through the object's keys\n            const addrs = Object.keys(blocks);\n            for (const addr of addrs) {\n                this.set(parseInt(addr), blocks[addr]);\n            }\n\n        } else if (blocks !== undefined && blocks !== null) {\n            throw new Error('First parameter to MemoryMap constructor must be an iterable of [addr, bytes] or undefined');\n        }\n    }\n\n    set(addr, value) {\n        if (!Number.isInteger(addr)) {\n            throw new Error('Address passed to MemoryMap is not an integer');\n        }\n        if (addr < 0) {\n            throw new Error('Address passed to MemoryMap is negative');\n        }\n        if (!(value instanceof Uint8Array)) {\n            throw new Error('Bytes passed to MemoryMap are not an Uint8Array');\n        }\n        return this._blocks.set(addr, value);\n    }\n    // Delegate the following to the 'this._blocks' Map:\n    get(addr)    { return this._blocks.get(addr);    }\n    clear()      { return this._blocks.clear();      }\n    delete(addr) { return this._blocks.delete(addr); }\n    entries()    { return this._blocks.entries();    }\n    forEach(callback, that) { return this._blocks.forEach(callback, that); }\n    has(addr)    { return this._blocks.has(addr);    }\n    keys()       { return this._blocks.keys();       }\n    values()     { return this._blocks.values();     }\n    get size()   { return this._blocks.size;         }\n    [Symbol.iterator]() { return this._blocks[Symbol.iterator](); }\n\n\n    /**\n     * Parses a string containing data formatted in \"Intel HEX\" format, and\n     * returns an instance of {@linkcode MemoryMap}.\n     *<br/>\n     * The insertion order of keys in the {@linkcode MemoryMap} is guaranteed to be strictly\n     * ascending. In other words, when iterating through the {@linkcode MemoryMap}, the addresses\n     * will be ordered in ascending order.\n     *<br/>\n     * The parser has an opinionated behaviour, and will throw a descriptive error if it\n     * encounters some malformed input. Check the project's\n     * {@link https://github.com/NordicSemiconductor/nrf-intel-hex#Features|README file} for details.\n     *<br/>\n     * If <tt>maxBlockSize</tt> is given, any contiguous data block larger than that will\n     * be split in several blocks.\n     *\n     * @param {String} hexText The contents of a .hex file.\n     * @param {Number} [maxBlockSize=Infinity] Maximum size of the returned <tt>Uint8Array</tt>s.\n     *\n     * @return {MemoryMap}\n     *\n     * @example\n     * import MemoryMap from 'nrf-intel-hex';\n     *\n     * let intelHexString =\n     *     \":100000000102030405060708090A0B0C0D0E0F1068\\n\" +\n     *     \":00000001FF\";\n     *\n     * let memMap = MemoryMap.fromHex(intelHexString);\n     *\n     * for (let [address, dataBlock] of memMap) {\n     *     console.log('Data block at ', address, ', bytes: ', dataBlock);\n     * }\n     */\n    static fromHex(hexText, maxBlockSize = Infinity) {\n        const blocks = new MemoryMap();\n\n        let lastCharacterParsed = 0;\n        let matchResult;\n        let recordCount = 0;\n\n        // Upper Linear Base Address, the 16 most significant bits (2 bytes) of\n        // the current 32-bit (4-byte) address\n        // In practice this is a offset that is summed to the \"load offset\" of the\n        // data records\n        let ulba = 0;\n\n        hexLineRegexp.lastIndex = 0; // Reset the regexp, if not it would skip content when called twice\n\n        while ((matchResult = hexLineRegexp.exec(hexText)) !== null) {\n            recordCount++;\n\n            // By default, a regexp loop ignores gaps between matches, but\n            // we want to be aware of them.\n            if (lastCharacterParsed !== matchResult.index) {\n                throw new Error(\n                    'Malformed hex file: Could not parse between characters ' +\n                    lastCharacterParsed +\n                    ' and ' +\n                    matchResult.index +\n                    ' (\"' +\n                    hexText.substring(lastCharacterParsed, Math.min(matchResult.index, lastCharacterParsed + 16)).trim() +\n                    '\")');\n            }\n            lastCharacterParsed = hexLineRegexp.lastIndex;\n\n            // Give pretty names to the match's capture groups\n            const [, recordStr, recordChecksum] = matchResult;\n\n            // String to Uint8Array - https://stackoverflow.com/questions/43131242/how-to-convert-a-hexademical-string-of-data-to-an-arraybuffer-in-javascript\n            const recordBytes = new Uint8Array(recordStr.match(/[\\da-f]{2}/gi).map((h)=>parseInt(h, 16)));\n\n            const recordLength = recordBytes[0];\n            if (recordLength + 4 !== recordBytes.length) {\n                throw new Error('Mismatched record length at record ' + recordCount + ' (' + matchResult[0].trim() + '), expected ' + (recordLength) + ' data bytes but actual length is ' + (recordBytes.length - 4));\n            }\n\n            const cs = checksum(recordBytes);\n            if (parseInt(recordChecksum, 16) !== cs) {\n                throw new Error('Checksum failed at record ' + recordCount + ' (' + matchResult[0].trim() + '), should be ' + cs.toString(16) );\n            }\n\n            const offset = (recordBytes[1] << 8) + recordBytes[2];\n            const recordType = recordBytes[3];\n            const data = recordBytes.subarray(4);\n\n            if (recordType === 0) {\n                // Data record, contains data\n                // Create a new block, at (upper linear base address + offset)\n                if (blocks.has(ulba + offset)) {\n                    throw new Error('Duplicated data at record ' + recordCount + ' (' + matchResult[0].trim() + ')');\n                }\n                if (offset + data.length > 0x10000) {\n                    throw new Error(\n                        'Data at record ' +\n                        recordCount +\n                        ' (' +\n                        matchResult[0].trim() +\n                        ') wraps over 0xFFFF. This would trigger ambiguous behaviour. Please restructure your data so that for every record the data offset plus the data length do not exceed 0xFFFF.');\n                }\n\n                blocks.set( ulba + offset, data );\n\n            } else {\n\n                // All non-data records must have a data offset of zero\n                if (offset !== 0) {\n                    throw new Error('Record ' + recordCount + ' (' + matchResult[0].trim() + ') must have 0000 as data offset.');\n                }\n\n                switch (recordType) {\n                case 1: // EOF\n                    if (lastCharacterParsed !== hexText.length) {\n                        // This record should be at the very end of the string\n                        throw new Error('There is data after an EOF record at record ' + recordCount);\n                    }\n\n                    return blocks.join(maxBlockSize);\n\n                case 2: // Extended Segment Address Record\n                    // Sets the 16 most significant bits of the 20-bit Segment Base\n                    // Address for the subsequent data.\n                    ulba = ((data[0] << 8) + data[1]) << 4;\n                    break;\n\n                case 3: // Start Segment Address Record\n                    // Do nothing. Record type 3 only applies to 16-bit Intel CPUs,\n                    // where it should reset the program counter (CS+IP CPU registers)\n                    break;\n\n                case 4: // Extended Linear Address Record\n                    // Sets the 16 most significant (upper) bits of the 32-bit Linear Address\n                    // for the subsequent data\n                    ulba = ((data[0] << 8) + data[1]) << 16;\n                    break;\n\n                case 5: // Start Linear Address Record\n                    // Do nothing. Record type 5 only applies to 32-bit Intel CPUs,\n                    // where it should reset the program counter (EIP CPU register)\n                    // It might have meaning for other CPU architectures\n                    // (see http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/ka9903.html )\n                    // but will be ignored nonetheless.\n                    break;\n                default:\n                    throw new Error('Invalid record type 0x' + hexpad(recordType) + ' at record ' + recordCount + ' (should be between 0x00 and 0x05)');\n                }\n            }\n        }\n\n        if (recordCount) {\n            throw new Error('No EOF record at end of file');\n        } else {\n            throw new Error('Malformed .hex file, could not parse any registers');\n        }\n    }\n\n\n    /**\n     * Returns a <strong>new</strong> instance of {@linkcode MemoryMap}, containing\n     * the same data, but concatenating together those memory blocks that are adjacent.\n     *<br/>\n     * The insertion order of keys in the {@linkcode MemoryMap} is guaranteed to be strictly\n     * ascending. In other words, when iterating through the {@linkcode MemoryMap}, the addresses\n     * will be ordered in ascending order.\n     *<br/>\n     * If <tt>maxBlockSize</tt> is given, blocks will be concatenated together only\n     * until the joined block reaches this size in bytes. This means that the output\n     * {@linkcode MemoryMap} might have more entries than the input one.\n     *<br/>\n     * If there is any overlap between blocks, an error will be thrown.\n     *<br/>\n     * The returned {@linkcode MemoryMap} will use newly allocated memory.\n     *\n     * @param {Number} [maxBlockSize=Infinity] Maximum size of the <tt>Uint8Array</tt>s in the\n     * returned {@linkcode MemoryMap}.\n     *\n     * @return {MemoryMap}\n     */\n    join(maxBlockSize = Infinity) {\n\n        // First pass, create a Map of addresslength of contiguous blocks\n        const sortedKeys = Array.from(this.keys()).sort((a,b)=>a-b);\n        const blockSizes = new Map();\n        let lastBlockAddr = -1;\n        let lastBlockEndAddr = -1;\n\n        for (let i=0,l=sortedKeys.length; i<l; i++) {\n            const blockAddr = sortedKeys[i];\n            const blockLength = this.get(sortedKeys[i]).length;\n\n            if (lastBlockEndAddr === blockAddr && (lastBlockEndAddr - lastBlockAddr) < maxBlockSize) {\n                // Grow when the previous end address equals the current,\n                // and we don't go over the maximum block size.\n                blockSizes.set(lastBlockAddr, blockSizes.get(lastBlockAddr) + blockLength);\n                lastBlockEndAddr += blockLength;\n            } else if (lastBlockEndAddr <= blockAddr) {\n                // Else mark a new block.\n                blockSizes.set(blockAddr, blockLength);\n                lastBlockAddr = blockAddr;\n                lastBlockEndAddr = blockAddr + blockLength;\n            } else {\n                throw new Error('Overlapping data around address 0x' + blockAddr.toString(16));\n            }\n        }\n\n        // Second pass: allocate memory for the contiguous blocks and copy data around.\n        const mergedBlocks = new MemoryMap();\n        let mergingBlock;\n        let mergingBlockAddr = -1;\n        for (let i=0,l=sortedKeys.length; i<l; i++) {\n            const blockAddr = sortedKeys[i];\n            if (blockSizes.has(blockAddr)) {\n                mergingBlock = new Uint8Array(blockSizes.get(blockAddr));\n                mergedBlocks.set(blockAddr, mergingBlock);\n                mergingBlockAddr = blockAddr;\n            }\n            mergingBlock.set(this.get(blockAddr), blockAddr - mergingBlockAddr);\n        }\n\n        return mergedBlocks;\n    }\n\n    /**\n     * Given a {@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Map|<tt>Map</tt>}\n     * of {@linkcode MemoryMap}s, indexed by a alphanumeric ID,\n     * returns a <tt>Map</tt> of address to tuples (<tt>Arrays</tt>s of length 2) of the form\n     * <tt>(id, Uint8Array)</tt>s.\n     *<br/>\n     * The scenario for using this is having several {@linkcode MemoryMap}s, from several calls to\n     * {@link module:nrf-intel-hex~hexToArrays|hexToArrays}, each having a different identifier.\n     * This function locates where those memory block sets overlap, and returns a <tt>Map</tt>\n     * containing addresses as keys, and arrays as values. Each array will contain 1 or more\n     * <tt>(id, Uint8Array)</tt> tuples: the identifier of the memory block set that has\n     * data in that region, and the data itself. When memory block sets overlap, there will\n     * be more than one tuple.\n     *<br/>\n     * The <tt>Uint8Array</tt>s in the output are\n     * {@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray|subarrays}\n     * of the input data; new memory is <strong>not</strong> allocated for them.\n     *<br/>\n     * The insertion order of keys in the output <tt>Map</tt> is guaranteed to be strictly\n     * ascending. In other words, when iterating through the <tt>Map</tt>, the addresses\n     * will be ordered in ascending order.\n     *<br/>\n     * When two blocks overlap, the corresponding array of tuples will have the tuples ordered\n     * in the insertion order of the input <tt>Map</tt> of block sets.\n     *<br/>\n     *\n     * @param {Map.MemoryMap} memoryMaps The input memory block sets\n     *\n     * @example\n     * import MemoryMap from 'nrf-intel-hex';\n     *\n     * let memMap1 = MemoryMap.fromHex( hexdata1 );\n     * let memMap2 = MemoryMap.fromHex( hexdata2 );\n     * let memMap3 = MemoryMap.fromHex( hexdata3 );\n     *\n     * let maps = new Map([\n     *  ['file A', blocks1],\n     *  ['file B', blocks2],\n     *  ['file C', blocks3]\n     * ]);\n     *\n     * let overlappings = MemoryMap.overlapMemoryMaps(maps);\n     *\n     * for (let [address, tuples] of overlappings) {\n     *     // if 'tuples' has length > 1, there is an overlap starting at 'address'\n     *\n     *     for (let [address, tuples] of overlappings) {\n     *         let [id, bytes] = tuple;\n     *         // 'id' in this example is either 'file A', 'file B' or 'file C'\n     *     }\n     * }\n     * @return {Map.Array<mixed,Uint8Array>} The map of possibly overlapping memory blocks\n     */\n    static overlapMemoryMaps(memoryMaps) {\n        // First pass: create a list of addresses where any block starts or ends.\n        const cuts = new Set();\n        for (const [, blocks] of memoryMaps) {\n            for (const [address, block] of blocks) {\n                cuts.add(address);\n                cuts.add(address + block.length);\n            }\n        }\n\n        const orderedCuts = Array.from(cuts.values()).sort((a,b)=>a-b);\n        const overlaps = new Map();\n\n        // Second pass: iterate through the cuts, get slices of every intersecting blockset\n        for (let i=0, l=orderedCuts.length-1; i<l; i++) {\n            const cut = orderedCuts[i];\n            const nextCut = orderedCuts[i+1];\n            const tuples = [];\n\n            for (const [setId, blocks] of memoryMaps) {\n                // Find the block with the highest address that is equal or lower to\n                // the current cut (if any)\n                const blockAddr = Array.from(blocks.keys()).reduce((acc, val)=>{\n                    if (val > cut) {\n                        return acc;\n                    }\n                    return Math.max( acc, val );\n                }, -1);\n\n                if (blockAddr !== -1) {\n                    const block = blocks.get(blockAddr);\n                    const subBlockStart = cut - blockAddr;\n                    const subBlockEnd = nextCut - blockAddr;\n\n                    if (subBlockStart < block.length) {\n                        tuples.push([ setId, block.subarray(subBlockStart, subBlockEnd) ]);\n                    }\n                }\n            }\n\n            if (tuples.length) {\n                overlaps.set(cut, tuples);\n            }\n        }\n\n        return overlaps;\n    }\n\n\n    /**\n     * Given the output of the {@linkcode MemoryMap.overlapMemoryMaps|overlapMemoryMaps}\n     * (a <tt>Map</tt> of address to an <tt>Array</tt> of <tt>(id, Uint8Array)</tt> tuples),\n     * returns a {@linkcode MemoryMap}. This discards the IDs in the process.\n     *<br/>\n     * The output <tt>Map</tt> contains as many entries as the input one (using the same addresses\n     * as keys), but the value for each entry will be the <tt>Uint8Array</tt> of the <b>last</b>\n     * tuple for each address in the input data.\n     *<br/>\n     * The scenario is wanting to join together several parsed .hex files, not worrying about\n     * their overlaps.\n     *<br/>\n     *\n     * @param {Map.Array<mixed,Uint8Array>} overlaps The (possibly overlapping) input memory blocks\n     * @return {MemoryMap} The flattened memory blocks\n     */\n    static flattenOverlaps(overlaps) {\n        return new MemoryMap(\n            Array.from(overlaps.entries()).map(([address, tuples]) => {\n                return [address, tuples[tuples.length - 1][1] ];\n            })\n        );\n    }\n\n\n    /**\n     * Returns a new instance of {@linkcode MemoryMap}, where:\n     *\n     * <ul>\n     *  <li>Each key (the start address of each <tt>Uint8Array</tt>) is a multiple of\n     *    <tt>pageSize</tt></li>\n     *  <li>The size of each <tt>Uint8Array</tt> is exactly <tt>pageSize</tt></li>\n     *  <li>Bytes from the input map to bytes in the output</li>\n     *  <li>Bytes not in the input are replaced by a padding value</li>\n     * </ul>\n     *<br/>\n     * The scenario is wanting to prepare pages of bytes for a write operation, where the write\n     * operation affects a whole page/sector at once.\n     *<br/>\n     * The insertion order of keys in the output {@linkcode MemoryMap} is guaranteed\n     * to be strictly ascending. In other words, when iterating through the\n     * {@linkcode MemoryMap}, the addresses will be ordered in ascending order.\n     *<br/>\n     * The <tt>Uint8Array</tt>s in the output will be newly allocated.\n     *<br/>\n     *\n     * @param {Number} [pageSize=1024] The size of the output pages, in bytes\n     * @param {Number} [pad=0xFF] The byte value to use for padding\n     * @return {MemoryMap}\n     */\n    paginate( pageSize=1024, pad=0xFF) {\n        if (pageSize <= 0) {\n            throw new Error('Page size must be greater than zero');\n        }\n        const outPages = new MemoryMap();\n        let page;\n\n        const sortedKeys = Array.from(this.keys()).sort((a,b)=>a-b);\n\n        for (let i=0,l=sortedKeys.length; i<l; i++) {\n            const blockAddr = sortedKeys[i];\n            const block = this.get(blockAddr);\n            const blockLength = block.length;\n            const blockEnd = blockAddr + blockLength;\n\n            for (let pageAddr = blockAddr - (blockAddr % pageSize); pageAddr < blockEnd; pageAddr += pageSize) {\n                page = outPages.get(pageAddr);\n                if (!page) {\n                    page = new Uint8Array(pageSize);\n                    page.fill(pad);\n                    outPages.set(pageAddr, page);\n                }\n\n                const offset = pageAddr - blockAddr;\n                let subBlock;\n                if (offset <= 0) {\n                    // First page which intersects the block\n                    subBlock = block.subarray(0, Math.min(pageSize + offset, blockLength));\n                    page.set(subBlock, -offset);\n                } else {\n                    // Any other page which intersects the block\n                    subBlock = block.subarray(offset, offset + Math.min(pageSize, blockLength - offset));\n                    page.set(subBlock, 0);\n                }\n            }\n        }\n\n        return outPages;\n    }\n\n\n    /**\n     * Locates the <tt>Uint8Array</tt> which contains the given offset,\n     * and returns the four bytes held at that offset, as a 32-bit unsigned integer.\n     *\n     *<br/>\n     * Behaviour is similar to {@linkcode https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint32|DataView.prototype.getUint32},\n     * except that this operates over a {@linkcode MemoryMap} instead of\n     * over an <tt>ArrayBuffer</tt>, and that this may return <tt>undefined</tt> if\n     * the address is not <em>entirely</em> contained within one of the <tt>Uint8Array</tt>s.\n     *<br/>\n     *\n     * @param {Number} offset The memory offset to read the data\n     * @param {Boolean} [littleEndian=false] Whether to fetch the 4 bytes as a little- or big-endian integer\n     * @return {Number|undefined} An unsigned 32-bit integer number\n     */\n    getUint32(offset, littleEndian) {\n        const keys = Array.from(this.keys());\n\n        for (let i=0,l=keys.length; i<l; i++) {\n            const blockAddr = keys[i];\n            const block = this.get(blockAddr);\n            const blockLength = block.length;\n            const blockEnd = blockAddr + blockLength;\n\n            if (blockAddr <= offset && (offset+4) <= blockEnd) {\n                return (new DataView(block.buffer, offset - blockAddr, 4)).getUint32(0, littleEndian);\n            }\n        }\n        return;\n    }\n\n\n    /**\n     * Returns a <tt>String</tt> of text representing a .hex file.\n     * <br/>\n     * The writer has an opinionated behaviour. Check the project's\n     * {@link https://github.com/NordicSemiconductor/nrf-intel-hex#Features|README file} for details.\n     *\n     * @param {Number} [lineSize=16] Maximum number of bytes to be encoded in each data record.\n     * Must have a value between 1 and 255, as per the specification.\n     *\n     * @return {String} String of text with the .hex representation of the input binary data\n     *\n     * @example\n     * import MemoryMap from 'nrf-intel-hex';\n     *\n     * let memMap = new MemoryMap();\n     * let bytes = new Uint8Array(....);\n     * memMap.set(0x0FF80000, bytes); // The block with 'bytes' will start at offset 0x0FF80000\n     *\n     * let string = memMap.asHexString();\n     */\n    asHexString(lineSize = 16) {\n        let lowAddress  = 0;    // 16 least significant bits of the current addr\n        let highAddress = -1 << 16; // 16 most significant bits of the current addr\n        const records = [];\n        if (lineSize <=0) {\n            throw new Error('Size of record must be greater than zero');\n        } else if (lineSize > 255) {\n            throw new Error('Size of record must be less than 256');\n        }\n\n        // Placeholders\n        const offsetRecord = new Uint8Array(6);\n        const recordHeader = new Uint8Array(4);\n\n        const sortedKeys = Array.from(this.keys()).sort((a,b)=>a-b);\n        for (let i=0,l=sortedKeys.length; i<l; i++) {\n            const blockAddr = sortedKeys[i];\n            const block = this.get(blockAddr);\n\n            // Sanity checks\n            if (!(block instanceof Uint8Array)) {\n                throw new Error('Block at offset ' + blockAddr + ' is not an Uint8Array');\n            }\n            if (blockAddr < 0) {\n                throw new Error('Block at offset ' + blockAddr + ' has a negative thus invalid address');\n            }\n            const blockSize = block.length;\n            if (!blockSize) { continue; }   // Skip zero-length blocks\n\n\n            if (blockAddr > (highAddress + 0xFFFF)) {\n                // Insert a new 0x04 record to jump to a new 64KiB block\n\n                // Round up the least significant 16 bits - no bitmasks because they trigger\n                // base-2 negative numbers, whereas subtracting the modulo maintains precision\n                highAddress = blockAddr - blockAddr % 0x10000;\n                lowAddress = 0;\n\n                offsetRecord[0] = 2;    // Length\n                offsetRecord[1] = 0;    // Load offset, high byte\n                offsetRecord[2] = 0;    // Load offset, low byte\n                offsetRecord[3] = 4;    // Record type\n                offsetRecord[4] = highAddress >> 24;    // new address offset, high byte\n                offsetRecord[5] = highAddress >> 16;    // new address offset, low byte\n\n                records.push(\n                    ':' +\n                    Array.prototype.map.call(offsetRecord, hexpad).join('') +\n                    hexpad(checksum(offsetRecord))\n                );\n            }\n\n            if (blockAddr < (highAddress + lowAddress)) {\n                throw new Error(\n                    'Block starting at 0x' +\n                    blockAddr.toString(16) +\n                    ' overlaps with a previous block.');\n            }\n\n            lowAddress = blockAddr % 0x10000;\n            let blockOffset = 0;\n            const blockEnd = blockAddr + blockSize;\n            if (blockEnd > 0xFFFFFFFF) {\n                throw new Error('Data cannot be over 0xFFFFFFFF');\n            }\n\n            // Loop for every 64KiB memory segment that spans this block\n            while (highAddress + lowAddress < blockEnd) {\n\n                if (lowAddress > 0xFFFF) {\n                    // Insert a new 0x04 record to jump to a new 64KiB block\n                    highAddress += 1 << 16; // Increase by one\n                    lowAddress = 0;\n\n                    offsetRecord[0] = 2;    // Length\n                    offsetRecord[1] = 0;    // Load offset, high byte\n                    offsetRecord[2] = 0;    // Load offset, low byte\n                    offsetRecord[3] = 4;    // Record type\n                    offsetRecord[4] = highAddress >> 24;    // new address offset, high byte\n                    offsetRecord[5] = highAddress >> 16;    // new address offset, low byte\n\n                    records.push(\n                        ':' +\n                        Array.prototype.map.call(offsetRecord, hexpad).join('') +\n                        hexpad(checksum(offsetRecord))\n                    );\n                }\n\n                let recordSize = -1;\n                // Loop for every record for that spans the current 64KiB memory segment\n                while (lowAddress < 0x10000 && recordSize) {\n                    recordSize = Math.min(\n                        lineSize,                            // Normal case\n                        blockEnd - highAddress - lowAddress, // End of block\n                        0x10000 - lowAddress                 // End of low addresses\n                    );\n\n                    if (recordSize) {\n\n                        recordHeader[0] = recordSize;   // Length\n                        recordHeader[1] = lowAddress >> 8;    // Load offset, high byte\n                        recordHeader[2] = lowAddress;    // Load offset, low byte\n                        recordHeader[3] = 0;    // Record type\n\n                        const subBlock = block.subarray(blockOffset, blockOffset + recordSize);   // Data bytes for this record\n\n                        records.push(\n                            ':' +\n                            Array.prototype.map.call(recordHeader, hexpad).join('') +\n                            Array.prototype.map.call(subBlock, hexpad).join('') +\n                            hexpad(checksumTwo(recordHeader, subBlock))\n                        );\n\n                        blockOffset += recordSize;\n                        lowAddress += recordSize;\n                    }\n                }\n            }\n        }\n\n        records.push(':00000001FF');    // EOF record\n\n        return records.join('\\n');\n    }\n\n\n    /**\n     * Performs a deep copy of the current {@linkcode MemoryMap}, returning a new one\n     * with exactly the same contents, but allocating new memory for each of its\n     * <tt>Uint8Array</tt>s.\n     *\n     * @return {MemoryMap}\n     */\n    clone() {\n        const cloned = new MemoryMap();\n\n        for (let [addr, value] of this) {\n            cloned.set(addr, new Uint8Array(value));\n        }\n\n        return cloned;\n    }\n\n\n    /**\n     * Given one <tt>Uint8Array</tt>, looks through its contents and returns a new\n     * {@linkcode MemoryMap}, stripping away those regions where there are only\n     * padding bytes.\n     * <br/>\n     * The start of the input <tt>Uint8Array</tt> is assumed to be offset zero for the output.\n     * <br/>\n     * The use case here is dumping memory from a working device and try to see the\n     * \"interesting\" memory regions it has. This assumes that there is a constant,\n     * predefined padding byte value being used in the \"non-interesting\" regions.\n     * In other words: this will work as long as the dump comes from a flash memory\n     * which has been previously erased (thus <tt>0xFF</tt>s for padding), or from a\n     * previously blanked HDD (thus <tt>0x00</tt>s for padding).\n     * <br/>\n     * This method uses <tt>subarray</tt> on the input data, and thus does not allocate memory\n     * for the <tt>Uint8Array</tt>s.\n     *\n     * @param {Uint8Array} bytes The input data\n     * @param {Number} [padByte=0xFF] The value of the byte assumed to be used as padding\n     * @param {Number} [minPadLength=64] The minimum number of consecutive pad bytes to\n     * be considered actual padding\n     *\n     * @return {MemoryMap}\n     */\n    static fromPaddedUint8Array(bytes, padByte=0xFF, minPadLength=64) {\n\n        if (!(bytes instanceof Uint8Array)) {\n            throw new Error('Bytes passed to fromPaddedUint8Array are not an Uint8Array');\n        }\n\n        // The algorithm used is nave and checks every byte.\n        // An obvious optimization would be to implement Boyer-Moore\n        // (see https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm )\n        // or otherwise start skipping up to minPadLength bytes when going through a non-pad\n        // byte.\n        // Anyway, we could expect a lot of cases where there is a majority of pad bytes,\n        // and the algorithm should check most of them anyway, so the perf gain is questionable.\n\n        const memMap = new MemoryMap();\n        let consecutivePads = 0;\n        let lastNonPad = -1;\n        let firstNonPad = 0;\n        let skippingBytes = false;\n        const l = bytes.length;\n\n        for (let addr = 0; addr < l; addr++) {\n            const byte = bytes[addr];\n\n            if (byte === padByte) {\n                consecutivePads++;\n                if (consecutivePads >= minPadLength) {\n                    // Edge case: ignore writing a zero-length block when skipping\n                    // bytes at the beginning of the input\n                    if (lastNonPad !== -1) {\n                        /// Add the previous block to the result memMap\n                        memMap.set(firstNonPad, bytes.subarray(firstNonPad, lastNonPad+1));\n                    }\n\n                    skippingBytes = true;\n                }\n            } else {\n                if (skippingBytes) {\n                    skippingBytes = false;\n                    firstNonPad = addr;\n                }\n                lastNonPad = addr;\n                consecutivePads = 0;\n            }\n        }\n\n        // At EOF, add the last block if not skipping bytes already (and input not empty)\n        if (!skippingBytes && lastNonPad !== -1) {\n            memMap.set(firstNonPad, bytes.subarray(firstNonPad, l));\n        }\n\n        return memMap;\n    }\n\n\n    /**\n     * Returns a new instance of {@linkcode MemoryMap}, containing only data between\n     * the addresses <tt>address</tt> and <tt>address + length</tt>.\n     * Behaviour is similar to {@linkcode https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/slice|Array.prototype.slice},\n     * in that the return value is a portion of the current {@linkcode MemoryMap}.\n     *\n     * <br/>\n     * The returned {@linkcode MemoryMap} might be empty.\n     *\n     * <br/>\n     * Internally, this uses <tt>subarray</tt>, so new memory is not allocated.\n     *\n     * @param {Number} address The start address of the slice\n     * @param {Number} length The length of memory map to slice out\n     * @return {MemoryMap}\n     */\n    slice(address, length = Infinity){\n        if (length < 0) {\n            throw new Error('Length of the slice cannot be negative');\n        }\n\n        const sliced = new MemoryMap();\n\n        for (let [blockAddr, block] of this) {\n            const blockLength = block.length;\n\n            if ((blockAddr + blockLength) >= address && blockAddr < (address + length)) {\n                const sliceStart = Math.max(address, blockAddr);\n                const sliceEnd = Math.min(address + length, blockAddr + blockLength);\n                const sliceLength = sliceEnd - sliceStart;\n                const relativeSliceStart = sliceStart - blockAddr;\n\n                if (sliceLength > 0) {\n                    sliced.set(sliceStart, block.subarray(relativeSliceStart, relativeSliceStart + sliceLength));\n                }\n            }\n        }\n        return sliced;\n    }\n\n    /**\n     * Returns a new instance of {@linkcode https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint32|Uint8Array}, containing only data between\n     * the addresses <tt>address</tt> and <tt>address + length</tt>. Any byte without a value\n     * in the input {@linkcode MemoryMap} will have a value of <tt>padByte</tt>.\n     *\n     * <br/>\n     * This method allocates new memory.\n     *\n     * @param {Number} address The start address of the slice\n     * @param {Number} length The length of memory map to slice out\n     * @param {Number} [padByte=0xFF] The value of the byte assumed to be used as padding\n     * @return {MemoryMap}\n     */\n    slicePad(address, length, padByte=0xFF){\n        if (length < 0) {\n            throw new Error('Length of the slice cannot be negative');\n        }\n        \n        const out = (new Uint8Array(length)).fill(padByte);\n\n        for (let [blockAddr, block] of this) {\n            const blockLength = block.length;\n\n            if ((blockAddr + blockLength) >= address && blockAddr < (address + length)) {\n                const sliceStart = Math.max(address, blockAddr);\n                const sliceEnd = Math.min(address + length, blockAddr + blockLength);\n                const sliceLength = sliceEnd - sliceStart;\n                const relativeSliceStart = sliceStart - blockAddr;\n\n                if (sliceLength > 0) {\n                    out.set(block.subarray(relativeSliceStart, relativeSliceStart + sliceLength), sliceStart - address);\n                }\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Checks whether the current memory map contains the one given as a parameter.\n     *\n     * <br/>\n     * \"Contains\" means that all the offsets that have a byte value in the given\n     * memory map have a value in the current memory map, and that the byte values\n     * are the same.\n     *\n     * <br/>\n     * An empty memory map is always contained in any other memory map.\n     *\n     * <br/>\n     * Returns boolean <tt>true</tt> if the memory map is contained, <tt>false</tt>\n     * otherwise.\n     *\n     * @param {MemoryMap} memMap The memory map to check\n     * @return {Boolean}\n     */\n    contains(memMap) {\n        for (let [blockAddr, block] of memMap) {\n\n            const blockLength = block.length;\n\n            const slice = this.slice(blockAddr, blockLength).join().get(blockAddr);\n\n            if ((!slice) || slice.length !== blockLength ) {\n                return false;\n            }\n\n            for (const i in block) {\n                if (block[i] !== slice[i]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n\n\nexport default MemoryMap;\n\n","import { Z80 } from './z80';\nimport { ROM } from './ROM';\nimport MemoryMap from 'nrf-intel-hex';\n\nlet running = false;\nlet active = true;\nlet speed = 30;\n\nlet cycles = 0;\nconst memory = Array(0xFFFF).fill(0xFF);\nconst inPorts = Array(256).fill(0xFF);\nconst outPorts = Array(256).fill(0xFF);\n\nconst cpu = Z80({\n    mem_read: (addr) => memory[addr],\n    mem_write: (addr, value) => memory[addr] = value,\n    io_read: (port) => {\n        return inPorts[port & 0xFF];\n    },\n    io_write: (port, value) => {\n        const port1 = port & 0xFF;\n        outPorts[port1] = value;\n        updateDisplay();\n        postOutPorts(port1, value);\n    },\n});\n\nconst display = Array(6).fill(0);\n\nself.onmessage = event => {\n    if (event.data.type === 'INIT') {\n        loadROM();\n        cpu.reset();\n        running = true;\n        run();\n    }\n    else if (event.data.type === 'PAUSE') {\n        if (active) {\n            active = false;\n            running = false;\n        }\n        else {\n            active = true;\n            running = true;\n            run();\n        }\n    }\n    else if (event.data.type === 'RESUME') {\n    }\n    else if (event.data.type === 'RESET') {\n        console.log('resetting');\n        cpu.reset();\n        running = true;\n        run();\n    }\n    else if (event.data.type === 'SET_INPUT_VALUE') {\n        const { port, value } = event.data;\n        inPorts[port] = value;\n    }\n    else if (event.data.type === 'SET_SPEED') {\n        speed = Number(event.data.value)/100;\n        console.log('set speed', speed);\n    }\n    else if (event.data.type === 'NMI') {\n        cpu.interrupt(true);\n    }\n    // else if (event.data.type === 'HIDDEN') {\n    //     let hidden = event.data.value;\n    //     if (hidden) {\n    //         running = false;\n    //     }\n    //     else if (active) {\n    //         running = true;\n    //         run();\n    //     }\n    //     else {\n    //         console.log('not active');\n    //     }\n    // }\n};\n\nfunction* runGen () {\n    while (true){\n        for (let i = 0; i < 1000 ; i++) {\n            if (!running) return;\n            const count = cpu.run_instruction();\n            cycles += count;\n        }\n        yield cycles;\n    }\n}\n\nlet pending = false;\nconst iter = runGen();\nfunction run() {\n    if (pending) return;\n    iter.next();\n    const delay = Math.floor((1 - Number(speed)) * 30);\n    if (running) {\n        pending = true;\n        setTimeout(function(){\n            pending = false;\n            run();\n        }, delay)\n    };\n}\n\nfunction updateDisplay() {\n    const digits = outPorts[1];\n    const segments = outPorts[2];\n    let mask = 0x01;\n    for (let i = 0; i < 6; i++) {\n        if (digits & mask){\n            display[i] = segments;\n        }\n        mask = mask << 1;\n    }\n}\n\nfunction getPortsBuffer(){\n    var buffer = new ArrayBuffer(4);\n    var view = new Uint8Array(buffer);\n    view[0] = outPorts[0];\n    view[1] = outPorts[1];\n    view[2] = outPorts[2];\n    return buffer;\n}\n\nfunction getDisplayBuffer(){\n    var buffer = new ArrayBuffer(6);\n    var view = new Uint8Array(buffer);\n    for (let i = 0; i < 6; i++) {\n        view[i] = display[i];\n    }\n    return buffer;\n}\n\nlet speaker = 1;\nlet wavelength = 0;\nfunction postOutPorts(port, value) {\n    const buffer = getPortsBuffer();\n    const display = getDisplayBuffer();\n\n    if (port === 1 && (value === 0x7F || value === 0xFF)) {\n        const speaker1 = value >> 7;\n        if (speaker1 === 1 && speaker === 0) {\n            wavelength = cycles;\n            cycles = 0;\n        }\n        speaker = speaker1;\n    }\n    if (cycles > 10000) wavelength = 0;\n\n    self.postMessage({\n        type: 'POST_OUTPORTS',\n        buffer,\n        display,\n        speaker,\n        wavelength: wavelength,\n    }, [buffer, display]);\n}\n\nfunction loadROM() {\n    const blocks = MemoryMap.fromHex(ROM);\n\n    for (let address of blocks.keys()) {\n        const block = blocks.get(address);\n        for (let i = address; i < address + block.length; i++) {\n        memory[i] = block[i];\n        }\n    }\n}\n"]}