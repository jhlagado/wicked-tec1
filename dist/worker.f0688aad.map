{"version":3,"sources":["src/worker/z80.ts","intel-hex.js","src/worker/worker.ts"],"names":["const","let","this","i","l","blockAddr","blocks","block"],"mappings":"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AAA,ECnDA,CAAC,IDmDM,ECnDA,ADmDE,CCnDD,MD0CL,GC1CF,CAAiB,IAAjB,CAAT,EAAiC;AAC7B,ADmDI,MAAA,MCnDM,CDmDC,EAAE,CCnDC,KAAJ,CAAU,ADyCb,+CCzCG,CAAV;AACC,ACCJ,AFkDO,MAAA,OAAO,EAAE,OAXN;AEtCd,AFkDW,MAAA,OAAO,EAAE,OAZN;ACvCX,ADoDQ,MAAA,ECpDA,IAAI,CDoDG,ECpDA,ADoDE,CCpDjB,EAAkB,IDuCP;ACtCP,ACER,AFkDY,MAAA,GElDH,GDFS,CDoDC,EAAE,CCpDC,KAAJ,CAAU,ACE5B,AFoCe,GEpCO,sCDFJ,CAAV;AACC,ACEL,AFkDQ,MAAA,EElDF,AFkDI,EAAE,EAfD,EEnCC,GAAG,QAAQ,CAAC,CAAD,CAAvB;AACA,AFkDQ,MAAA,EElDF,AFkDI,EAAE,EAhBD,IElCG,GAAG,QAAQ,CAAC,CAAD,CAAzB;ADFA,ACGA,AFkDQ,MElDJ,AFkDI,CAAC,CCrDD,CDqDG,CCrDD,ACGF,AFiCG,GEjCA,EDHI,ECGf,UDH2B,UAAnB,CAAR,EAAwC;AACpC,ADqDI,MAAA,CAAC,EAAE,CAlBA,ECnCG,IAAI,KAAJ,CAAU,iDAAV,CAAV;AACC,ACEL,AFmDQ,MAAA,CEnDH,CFmDK,EAAE,CEnDH,CAAC,AFgCC,GEhCE,CAAb,EAAgB,CAAC,GAAG,CAApB,EAAuB,CAAC,EAAxB,EAA4B;AACxB,AFmDI,MAAA,EEnDA,AFmDE,EAAE,EApBD,EE/BG,GAAG,IAAb,EAAkB;ADFtB,ACGQ,AFmDA,MEnDA,AFmDA,KCtDG,ADsDE,EEnDE,AFmDA,CEnDC,CAAD,CDHC,ACGR,GAAa,IDHV,CAAa,GAAb,ACGH,CDHoB,IAAjB,EAAuB,KAAvB,CAAX;AACC,ACGI,AFmDO,GCjEhB,KDiEgB,CAAC,EAAE,KAAK,CAAC,CADN;AAEH,QAAA,CAAC,EAAE,KAAK,CAAC,CAFN;AEjDX,AFoDQ,IEpDR,IAAI,AFoDI,CAAC,EEpDF,AFoDI,IEpDA,CFoDK,CAAC,CAHN,CEjDI,CAAf;ADFR,ACGK,AFoDW,ECvDhB,MDuDgB,CAAC,ECvDjB,ADuDmB,CCvDnB,IDuDwB,CAAC,CAJN,GCnDnB,CAAI,GAAJ,GAAO,SAAA,GAAA,CAAC,IAAD,EAAM;AAAM,ACIlB,AFoDe,QAAA,CAAC,ECxDS,ADwDP,KCxDY,ADwDP,CAAC,CALN,KCnDO,CAAa,GAAb,CAAiB,IAAjB,CAAP;AAAmC,ADyDtC,GCzDhB,KDyDgB,CAAC,EAAE,KAAK,CAAC,CANN;AE7CnB,AFoDgB,QAAA,CEpDP,AFoDQ,EAAE,KAAK,CAAC,CAPN,KE7CnB,GAAuB;ADLvB,ACMI,AFoDY,EC1DhB,ICMQ,EFoDQ,CAAC,EC1DjB,AD0DmB,CC1DnB,ACMc,GAAG,CFoDO,CAAC,EEpDJ,EDNrB,CAAI,KAAJ,GAAS,ACMQ,CAAgB,CAAhB,CAAb,MDNK,KAAA,GAAI;AAAM,ACOf,AF2Ce,ME3CX,CFsBO,GEtBH,CDPc,ECOX,GDPgB,CCOZ,MDPO,CAAa,GCOxB,CAAe,CDPJ,EAAP,GCOJ,CAAX;ADPkD,ACQlD,AFoDQ,EEpDR,CDRJ,GCQQ,AFoDI,CEpDH,CAAD,CAAJ,GAAU,KFoDS,EAAE,CEpDH,CAAC,CAAD,CAAlB;AACA,AFoDY,EEpDZ,IAAI,CAAC,CAAD,AFoDQ,CEpDZ,AFoDa,EAAE,CEpDL,QAAQ,CAAC,CAAD,AFoDQ,CEpD1B,AFoD2B,CADN;AC3DzB,ACSI,AFoDY,EC7DhB,ACSI,IAAI,CAAC,CAAD,AFoDQ,CEpDZ,AFoDa,EC7DjB,AD6DmB,CC7DnB,ACSc,QAAQ,CDTtB,ACSuB,CDTnB,ACSkB,AFoDQ,CEpD1B,AFoD2B,CAFN,IC3DzB,GAAU,SAAA,QAAA,CAAC,IAAD,EAAO;AAAE,ACUf,AFoDY,QAAA,CEpDL,AFoDM,EC9DS,AD8DP,IEpDf,CDV2B,MD8DD,CC9DJ,AD8DK,CC9DQ,AD2Dd,MC3DC,CAAoB,IAApB,CAAP;AAAmC,ACWrD,AFoDe,GC/DhB,KD+DgB,CAAC,EAAE,WAAW,CAAC,CAJN;AAKT,QAAA,CAAC,EAAE,WAAW,CAAC,CALN;AC1DzB,ACYA,AFoDgB,EChEhB,MDgEgB,CEpDP,AFoDQ,EChEjB,ADgEmB,CChEnB,SAAA,CAAI,ADgE0B,CAAC,CANN,CE9CzB,GAAyB,CDZzB,GAAW,SAAA,OAAA,GAAE;AAAM,ACaf,AFoDY,MEpDR,EFoDQ,CAAC,ECjES,ADiEP,CEpDL,GAAG,CDbc,GCaV,GFoDS,CCjEJ,ADiEK,CCjEQ,AD0Dd,ME7CR,CDbS,ACaO,CAAhB,CDbE,ACaf;ADbkD,ACclD,AFoDY,GClEhB,GCcQ,EFoDQ,CAAC,CEpDL,CFoDO,EEpDJ,IAAI,KFoDW,CAAC,IEpDhB,CAAe,MAAf,CAAX;AF4CqB,OA/BV;AC1Bf,ACcI,AFqDQ,ECnEZ,IDmEY,CErDH,IDdT,ACca,AFqDI,CCnEjB,ACcc,CFqDK,EErDF,CAAb,EAAgB,AFYL,CEZM,EDdrB,CAAI,ACcoB,CAApB,EAAuB,CAAC,EAAxB,CDdJ,CCcgC,EDdrB,SAAA,OAAA,CAAC,QAAD,EAAW,IAAX,EAAiB;AAAE,ACetB,AFqDI,IErDJ,EFqDI,EErDA,CAAC,CAAD,AFqDI,CCpEqB,ACe7B,CFqDU,EErDA,EDfwB,AD0B3B,KEXU,CAAC,CDfW,ACeZ,CDfyB,ACe1C,ODf6B,CAAqB,QAArB,EAA+B,IAA/B,CAAP;AAA8C,ACgBvE,AFqDO,GCrEZ,GDqEY,IAAI,EAAE,IA3CH;AA4CH,MAAA,MAAM,EAAE,MA5CL;ACzBf,ACgBI,AFsDQ,ECtEZ,IDsEY,GEtDD,EDhBX,CAAA,GCgBI,IFsDqB,ECtEzB,ADsE2B,CCtEvB,GAAJ,GAAO,MDyBQ,GCzBR,GAAA,CAAC,IAAD,EAAM;AAAM,ACiBlB,AFsDW,MAAA,KCvEc,KAAK,GDuEN,EAAE,ECvED,CAAa,GAAb,CAAiB,IAAjB,CAAP,CDyBJ;ACzBuC,ADwE1C,GCxEZ,GDwEY,aAAa,EAAE;AErD3B,AFMe,IENX,CFMI,MENG,GAAG,CAAd;ADlBA,ACmBA,AFsDK,ECzEL,ECmBI,ODnBJ,CAAA,ECmBc,GAAG,CAAjB,GDnBA,CAAI,IAAJ,GAAQ,SAAA,IAAA,GAAK;AAAM,WAAO,KAAK,OAAL,CAAa,IAAb,EAAP;AAAmC,ACoBtD,AFuDI,GC3EJ,MCoBS,EFuDI,QAAT,CAAkB,CEvDtB,CAAsB,GFuDlB,CEvDJ,CFuDoC,CEvDD,KAAnC,EAA+C;AAC3C,AFuDI,IAAA,CAAC,GEvDC,AFuDE,KAAK,CEvDD,AFuDE,CAAV,EEvDW,cAAc,EAA7B;ADpBJ,ACqBI,AFuDI,EC5ER,ED4EQ,CAAC,GEvDC,AFuDE,GC5EZ,CAAA,CD4EiB,CAAC,CEvDD,AFuDT,GEvDY,GDrBpB,CAAI,MAAJ,GAAU,GCqB0B,EAAhC,IDrBM,MAAA,GAAG;AAAM,AD6EX,IAAA,CAAC,GAAG,GC7Ec,ED6ET,CAAC,CAAV,CC7EuB,OAAL,CAAa,MAAb,EAAP;AAAmC,ACuBlD,AFuDI,GC9ER,CD8EQ,CAAC,CEvDD,EFuDI,EEvDA,GFuDK,CAAC,CEvDD,AFuDT,CEvDA,KAAe,KAAK,KAAK,IAAV,IAAkB,KAAK,KAAK,IAA3C,CAAJ,EAAsD;AAClD,AFuDA,IAAA,CAAC,GAAG,EEvDE,GFuDG,CAAC,CAAV,GEvDc,GAAG,KAAK,IAAI,CAA1B;ADvBR,AD+EQ,EC/ER,ED+EQ,CAAC,GAAG,KAAK,CAAC,CAAV,KC/ER,CAAI,IAAJ,CAAY,GAAZ,GAAY,YAAK;AAAE,ACwBX,AFwDA,IAAA,CAAC,GExDG,AFwDA,GChFc,EDgFT,CAAC,CAAV,CChFuB,ACwBX,KAAK,CAAb,CDxBc,CAAa,ECwBT,EDxBX,KCwBkB,KAAK,CAAlC,EAAqC;ADxBS,ACyB1C,AFwDJ,GCjFR,CDiFQ,EExDI,KFwDG,GAAG,EExDI,GAAG,AFwDF,CAAC,KExDZ,EFwDJ;AEvDI,AFwDJ,IAAA,EExDI,KFwDG,CExDG,EFwDA,CExDG,CAAT,GFwDW,CAAC,OAAhB;ACjFR,AC0BS,AFwDD,EClFR,EDkFQ,OClFR,ADkFe,CClFf,EDkFkB,KAAK,CAAC,CClFxB,CAAK,KDkFG,CClFG,CAAC,QAAZ,IAAqB,YAAG;AAAE,ADmFlB,IAAA,OCnFyB,ADmFlB,GAAG,ECnFoB,GDmFf,CAAC,GCnFS,CAAa,GDmFtC,GCnF4C,CAAC,QAApB,GAAP;AAAyC,AC2B3D,AFyDA,GCpFR,CC2BQ,AFyDA,OEzDO,AFyDA,GEzDG,AFyDA,KAAK,CAAC,EEzDhB,KFyDA;AExDH,AFyDG,IAAA,OAAO,GAAG,KAAK,CAAC,OAAhB;AACA,IAAA,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","file":"worker.f0688aad.map","sourceRoot":"..","sourcesContent":["///////////////////////////////////////////////////////////////////////////////\n/// @file Z80.js\n///\n/// @brief Emulator for the Zilog Z80 microprocessor\n///\n/// @author Matthew Howell\n///\n/// @remarks\n///  This module is a simple, straightforward instruction interpreter.\n///   There is no fancy dynamic recompilation or cycle-accurate emulation.\n///   The author believes that this should be sufficient for any emulator that\n///   would be feasible to write in JavaScript anyway.\n///  The code and the comments in this file assume that the reader is familiar\n///   with the Z80 architecture. If you're not, here are some references I use:\n///  http://clrhome.org/table/ - Z80 instruction set tables\n///  http://www.zilog.com/docs/z80/um0080.pdf - The official manual\n///  http://www.myquest.nl/z80undocumented/z80-documented-v0.91.pdf\n///   - The Undocumented Z80, Documented\n///\n/// @copyright (c) 2013 Matthew Howell\n///  This code is released under the MIT license,\n///  a copy of which is available in the associated README.md file,\n///  or at http://opensource.org/licenses/MIT\n///////////////////////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////////////////////\n/// We'll begin with the object constructor and the public API functions.\n///////////////////////////////////////////////////////////////////////////////\n\ninterface CoreParameter {\n    mem_read: (addr: number) => any;\n    mem_write: (addr: number, value: number) => number;\n    io_read: (port: number) => any;\n    io_write: (port: number, value: number) => void;\n}\n\ninterface Z80State {\n    b:number;\n    a:number;\n    c:number;\n    d:number;\n    e:number;\n    h:number;\n    l:number;\n    a_prime:number;\n    b_prime:number;\n    c_prime:number;\n    d_prime:number;\n    e_prime:number;\n    h_prime:number;\n    l_prime:number;\n    ix:number;\n    iy:number;\n    i:number;\n    r:number;\n    sp:number;\n    pc:number;\n    flags: {\n        S:number;\n        Z:number;\n        Y:number;\n        H:number;\n        X:number;\n        P:number;\n        N:number;\n        C:number;\n    }\n    flags_prime: {\n        S:number;\n        Z:number;\n        Y:number;\n        H:number;\n        X:number;\n        P:number;\n        N:number;\n        C:number;\n    }\n    imode: number;\n    iff1: number;\n    iff2: number;\n    halted: boolean;\n    do_delayed_di: boolean;\n    do_delayed_ei: boolean;\n    cycle_counter: number;\n}\n\nexport function Z80(coreParameter: CoreParameter) {\n    // Obviously we'll be needing the core object's functions again.\n    let core = coreParameter;\n\n    // The argument to this constructor should be an object containing 4 functions:\n    // mem_read(address) should return the byte at the given memory address,\n    // mem_write(address, value) should write the given value to the given memory address,\n    // io_read(port) should read a return a byte read from the given I/O port,\n    // io_write(port, value) should write the given byte to the given I/O port.\n    // If any of those functions is missing, this module cannot run.\n    if (!core || (typeof core.mem_read !== \"function\") || (typeof core.mem_write !== \"function\") ||\n        (typeof core.io_read !== \"function\") || (typeof core.io_write !== \"function\"))\n        throw (\"Z80: Core object is missing required functions.\");\n\n    // All right, let's initialize the registers.\n    // First, the standard 8080 registers.\n    let a = 0x00;\n    let b = 0x00;\n    let c = 0x00;\n    let d = 0x00;\n    let e = 0x00;\n    let h = 0x00;\n    let l = 0x00;\n    // Now the special Z80 copies of the 8080 registers\n    //  (the ones used for the SWAP instruction and such).\n    let a_prime = 0x00;\n    let b_prime = 0x00;\n    let c_prime = 0x00;\n    let d_prime = 0x00;\n    let e_prime = 0x00;\n    let h_prime = 0x00;\n    let l_prime = 0x00;\n    // And now the Z80 index registers.\n    let ix = 0x0000;\n    let iy = 0x0000;\n    // Then the \"utility\" registers: the interrupt vector,\n    //  the memory refresh, the stack pointer, and the program counter.\n    let i = 0x00;\n    let r = 0x00;\n    let sp = 0xdff0;\n    let pc = 0x0000;\n    // We don't keep an F register for the flags,\n    //  because most of the time we're only accessing a single flag,\n    //  so we optimize for that case and use utility functions\n    //  for the rarer occasions when we need to access the whole register.\n    let flags = { S: 0, Z: 0, Y: 0, H: 0, X: 0, P: 0, N: 0, C: 0 };\n    let flags_prime = { S: 0, Z: 0, Y: 0, H: 0, X: 0, P: 0, N: 0, C: 0 };\n    // And finally we have the interrupt mode and flip-flop registers.\n    let imode = 0;\n    let iff1 = 0;\n    let iff2 = 0;\n\n    // These are all specific to this implementation, not Z80 features.\n    // Keep track of whether we've had a HALT instruction called.\n    let halted = false;\n    // EI and DI wait one instruction before they take effect;\n    //  these flags tell us when we're in that wait state.\n    let do_delayed_di = false;\n    let do_delayed_ei = false;\n    // This tracks the number of cycles spent in a single instruction run,\n    //  including processing any prefixes and handling interrupts.\n    let cycle_counter = 0;\n\n    function getState():Z80State {\n        return {\n            b: b,\n            a: a,\n            c: c,\n            d: d,\n            e: e,\n            h: h,\n            l: l,\n            a_prime: a_prime,\n            b_prime: b_prime,\n            c_prime: c_prime,\n            d_prime: d_prime,\n            e_prime: e_prime,\n            h_prime: h_prime,\n            l_prime: l_prime,\n            ix: ix,\n            iy: iy,\n            i: i,\n            r: r,\n            sp: sp,\n            pc: pc,\n            flags: {\n                S: flags.S,\n                Z: flags.Z,\n                Y: flags.Y,\n                H: flags.H,\n                X: flags.X,\n                P: flags.P,\n                N: flags.N,\n                C: flags.C\n            },\n            flags_prime: {\n                S: flags_prime.S,\n                Z: flags_prime.Z,\n                Y: flags_prime.Y,\n                H: flags_prime.H,\n                X: flags_prime.X,\n                P: flags_prime.P,\n                N: flags_prime.N,\n                C: flags_prime.C\n            },\n            imode: imode,\n            iff1: iff1,\n            iff2: iff2,\n            halted: halted,\n            do_delayed_di: do_delayed_di,\n            do_delayed_ei: do_delayed_ei,\n            cycle_counter: cycle_counter\n        };\n    }\n\n    function setState(state:Z80State) {\n        b = state.b;\n        a = state.a;\n        c = state.c;\n        d = state.d;\n        e = state.e;\n        h = state.h;\n        l = state.l;\n        a_prime = state.a_prime;\n        b_prime = state.b_prime;\n        c_prime = state.c_prime;\n        d_prime = state.d_prime;\n        e_prime = state.e_prime;\n        h_prime = state.h_prime;\n        l_prime = state.l_prime;\n        ix = state.ix;\n        iy = state.iy;\n        i = state.i;\n        r = state.r;\n        sp = state.sp;\n        pc = state.pc;\n        flags.S = state.flags.S;\n        flags.Z = state.flags.Z;\n        flags.Y = state.flags.Y;\n        flags.H = state.flags.H;\n        flags.X = state.flags.X;\n        flags.P = state.flags.P;\n        flags.N = state.flags.N;\n        flags.C = state.flags.C;\n        flags_prime.S = state.flags_prime.S;\n        flags_prime.Z = state.flags_prime.Z;\n        flags_prime.Y = state.flags_prime.Y;\n        flags_prime.H = state.flags_prime.H;\n        flags_prime.X = state.flags_prime.X;\n        flags_prime.P = state.flags_prime.P;\n        flags_prime.N = state.flags_prime.N;\n        flags_prime.C = state.flags_prime.C;\n        imode = state.imode;\n        iff1 = state.iff1;\n        iff2 = state.iff2;\n        halted = state.halted;\n        do_delayed_di = state.do_delayed_di;\n        do_delayed_ei = state.do_delayed_ei;\n        cycle_counter = state.cycle_counter;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// @public reset\n    ///\n    /// @brief Re-initialize the processor as if a reset or power on had occured\n    ///////////////////////////////////////////////////////////////////////////////\n    let reset = function () {\n        // These registers are the ones that have predictable states\n        //  immediately following a power-on or a reset.\n        // The others are left alone, because their states are unpredictable.\n        sp = 0xdff0;\n        pc = 0x0000;\n        a = 0x00;\n        r = 0x00;\n        set_flags_register(0);\n        // Start up with interrupts disabled.\n        imode = 0;\n        iff1 = 0;\n        iff2 = 0;\n        // Don't start halted or in a delayed DI or EI.\n        halted = false;\n        do_delayed_di = false;\n        do_delayed_ei = false;\n        // Obviously we've not used any cycles yet.\n        cycle_counter = 0;\n    };\n\n    let reset1 = function () {\n        sp = 0xdff0;\n        pc = 0x0000;\n        halted = false;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// @public run_instruction\n    ///\n    /// @brief Runs a single instruction\n    ///\n    /// @return The number of T cycles the instruction took to run,\n    ///          plus any time that went into handling interrupts that fired\n    ///          while this instruction was executing\n    ///////////////////////////////////////////////////////////////////////////////\n    let run_instruction = function () {\n        if (!halted) {\n            // If the previous instruction was a DI or an EI,\n            //  we'll need to disable or enable interrupts\n            //  after whatever instruction we're about to run is finished.\n            var doing_delayed_di = false, doing_delayed_ei = false;\n            if (do_delayed_di) {\n                do_delayed_di = false;\n                doing_delayed_di = true;\n            }\n            else if (do_delayed_ei) {\n                do_delayed_ei = false;\n                doing_delayed_ei = true;\n            }\n\n            // R is incremented at the start of every instruction cycle,\n            //  before the instruction actually runs.\n            // The high bit of R is not affected by this increment,\n            //  it can only be changed using the LD R, A instruction.\n            r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n\n            // Read the byte at the PC and run the instruction it encodes.\n            var opcode = core.mem_read(pc);\n            try {\n                decode_instruction(opcode);\n            }\n            catch (e) {\n                console.log(`Illegal opcode ${opcode} at ${pc}`, e);\n                halted = true;\n            }\n            pc = (pc + 1) & 0xffff;\n\n            // Actually do the delayed interrupt disable/enable if we have one.\n            if (doing_delayed_di) {\n                iff1 = 0;\n                iff2 = 0;\n            }\n            else if (doing_delayed_ei) {\n                iff1 = 1;\n                iff2 = 1;\n            }\n\n            // And finally clear out the cycle counter for the next instruction\n            //  before returning it to the emulator core.\n            var retval = cycle_counter;\n            cycle_counter = 0;\n            return retval;\n        }\n        else {\n            // While we're halted, claim that we spent a cycle doing nothing,\n            //  so that the rest of the emulator can still proceed.\n            return 1;\n        }\n    };\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// @public interrupt\n    ///\n    /// @brief Simulates pulsing the processor's INT (or NMI) pin\n    ///\n    /// @param non_maskable - true if this is a non-maskable interrupt\n    /// @param data - the value to be placed on the data bus, if needed\n    ///////////////////////////////////////////////////////////////////////////////\n    let interrupt = function (non_maskable:boolean, data:number) {\n        if (non_maskable) {\n            // The high bit of R is not affected by this increment,\n            //  it can only be changed using the LD R, A instruction.\n            r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n            // Non-maskable interrupts are always handled the same way;\n            //  clear IFF1 and then do a CALL 0x0066.\n            // Also, all interrupts reset the HALT state.\n            halted = false;\n            iff2 = iff1;\n            iff1 = 0;\n            push_word(pc);\n            pc = 0x66;\n            cycle_counter += 11;\n        }\n        else if (iff1) {\n            // The high bit of R is not affected by this increment,\n            //  it can only be changed using the LD R, A instruction.\n            r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n\n            halted = false;\n            iff1 = 0;\n            iff2 = 0;\n\n            if (imode === 0) {\n                // In the 8080-compatible interrupt mode,\n                //  decode the content of the data bus as an instruction and run it.\n                decode_instruction(data);\n                cycle_counter += 2;\n            }\n            else if (imode === 1) {\n                // Mode 1 is always just RST 0x38.\n                push_word(pc);\n                pc = 0x38;\n                cycle_counter += 13;\n            }\n            else if (imode === 2) {\n                // Mode 2 uses the value on the data bus as in index\n                //  into the vector table pointer to by the I register.\n                push_word(pc);\n                // The Z80 manual says that this address must be 2-byte aligned,\n                //  but it doesn't appear that this is actually the case on the hardware,\n                //  so we don't attempt to enforce that here.\n                var vector_address = ((i << 8) | data);\n                pc = core.mem_read(vector_address) |\n                    (core.mem_read((vector_address + 1) & 0xffff) << 8);\n\n                cycle_counter += 19;\n            }\n        }\n    };\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// The public API functions end here.\n    ///\n    /// What begins here are just general utility functions, used variously.\n    ///////////////////////////////////////////////////////////////////////////////\n    let decode_instruction = function (opcode:number) {\n        // The register-to-register loads and ALU instructions\n        //  are all so uniform that we can decode them directly\n        //  instead of going into the instruction array for them.\n        // This function gets the operand for all of these instructions.\n        var get_operand = function (opcode:number) {\n            return ((opcode & 0x07) === 0) ? b :\n                ((opcode & 0x07) === 1) ? c :\n                    ((opcode & 0x07) === 2) ? d :\n                        ((opcode & 0x07) === 3) ? e :\n                            ((opcode & 0x07) === 4) ? h :\n                                ((opcode & 0x07) === 5) ? l :\n                                    ((opcode & 0x07) === 6) ? core.mem_read(l | (h << 8)) : a;\n        };\n\n        // Handle HALT right up front, because it fouls up our LD decoding\n        //  by falling where LD (HL), (HL) ought to be.\n        if (opcode === 0x76) {\n            halted = true;\n        }\n        else if ((opcode >= 0x40) && (opcode < 0x80)) {\n            // This entire range is all 8-bit register loads.\n            // Get the operand and assign it to the correct destination.\n            var operand = get_operand(opcode);\n\n            if (((opcode & 0x38) >>> 3) === 0)\n                b = operand;\n            else if (((opcode & 0x38) >>> 3) === 1)\n                c = operand;\n            else if (((opcode & 0x38) >>> 3) === 2)\n                d = operand;\n            else if (((opcode & 0x38) >>> 3) === 3)\n                e = operand;\n            else if (((opcode & 0x38) >>> 3) === 4)\n                h = operand;\n            else if (((opcode & 0x38) >>> 3) === 5)\n                l = operand;\n            else if (((opcode & 0x38) >>> 3) === 6)\n                core.mem_write(l | (h << 8), operand);\n            else if (((opcode & 0x38) >>> 3) === 7)\n                a = operand;\n        }\n        else if ((opcode >= 0x80) && (opcode < 0xc0)) {\n            // These are the 8-bit register ALU instructions.\n            // We'll get the operand and then use this \"jump table\"\n            //  to call the correct utility function for the instruction.\n            var operand = get_operand(opcode),\n                op_array = [do_add, do_adc, do_sub, do_sbc,\n                    do_and, do_xor, do_or, do_cp];\n\n            op_array[(opcode & 0x38) >>> 3](operand);\n        }\n        else {\n            // This is one of the less formulaic instructions;\n            //  we'll get the specific function for it from our array.\n            var func = instructions[opcode];\n            func();\n        }\n\n        // Update the cycle counter with however many cycles\n        //  the base instruction took.\n        // If this was a prefixed instruction, then\n        //  the prefix handler has added its extra cycles already.\n        cycle_counter += cycle_counts[opcode];\n    };\n\n    let get_signed_offset_byte = function (value:number) {\n        // This function requires some explanation.\n        // We just use JavaScript Number variables for our registers,\n        //  not like a typed array or anything.\n        // That means that, when we have a byte value that's supposed\n        //  to represent a signed offset, the value we actually see\n        //  isn't signed at all, it's just a small integer.\n        // So, this function converts that byte into something JavaScript\n        //  will recognize as signed, so we can easily do arithmetic with it.\n        // First, we clamp the value to a single byte, just in case.\n        value &= 0xff;\n        // We don't have to do anything if the value is positive.\n        if (value & 0x80) {\n            // But if the value is negative, we need to manually un-two's-compliment it.\n            // I'm going to assume you can figure out what I meant by that,\n            //  because I don't know how else to explain it.\n            // We could also just do value |= 0xffffff00, but I prefer\n            //  not caring how many bits are in the integer representation\n            //  of a JavaScript number in the currently running browser.\n            value = -((0xff & ~value) + 1);\n        }\n        return value;\n    };\n\n    let get_flags_register = function () {\n        // We need the whole F register for some reason.\n        //  probably a PUSH AF instruction,\n        //  so make the F register out of our separate flags.\n        return (flags.S << 7) |\n            (flags.Z << 6) |\n            (flags.Y << 5) |\n            (flags.H << 4) |\n            (flags.X << 3) |\n            (flags.P << 2) |\n            (flags.N << 1) |\n            (flags.C);\n    };\n\n    let get_flags_prime = function () {\n        // This is the same as the above for the F' register.\n        return (flags_prime.S << 7) |\n            (flags_prime.Z << 6) |\n            (flags_prime.Y << 5) |\n            (flags_prime.H << 4) |\n            (flags_prime.X << 3) |\n            (flags_prime.P << 2) |\n            (flags_prime.N << 1) |\n            (flags_prime.C);\n    };\n\n    let set_flags_register = function (operand:number) {\n        // We need to set the F register, probably for a POP AF,\n        //  so break out the given value into our separate flags.\n        flags.S = (operand & 0x80) >>> 7;\n        flags.Z = (operand & 0x40) >>> 6;\n        flags.Y = (operand & 0x20) >>> 5;\n        flags.H = (operand & 0x10) >>> 4;\n        flags.X = (operand & 0x08) >>> 3;\n        flags.P = (operand & 0x04) >>> 2;\n        flags.N = (operand & 0x02) >>> 1;\n        flags.C = (operand & 0x01);\n    };\n\n    let set_flags_prime = function (operand:number) {\n        // Again, this is the same as the above for F'.\n        flags_prime.S = (operand & 0x80) >>> 7;\n        flags_prime.Z = (operand & 0x40) >>> 6;\n        flags_prime.Y = (operand & 0x20) >>> 5;\n        flags_prime.H = (operand & 0x10) >>> 4;\n        flags_prime.X = (operand & 0x08) >>> 3;\n        flags_prime.P = (operand & 0x04) >>> 2;\n        flags_prime.N = (operand & 0x02) >>> 1;\n        flags_prime.C = (operand & 0x01);\n    };\n\n    let update_xy_flags = function (result:number) {\n        // Most of the time, the undocumented flags\n        //  (sometimes called X and Y, or 3 and 5),\n        //  take their values from the corresponding bits\n        //  of the result of the instruction,\n        //  or from some other related value.\n        // This is a utility function to set those flags based on those bits.\n        flags.Y = (result & 0x20) >>> 5;\n        flags.X = (result & 0x08) >>> 3;\n    };\n\n    let get_parity = function (value:number) {\n        // We could try to actually calculate the parity every time,\n        //  but why calculate what you can pre-calculate?\n        var parity_bits = [\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1\n        ];\n        return parity_bits[value];\n    };\n\n    let push_word = function (operand:number) {\n        // Pretty obvious what this function does; given a 16-bit value,\n        //  decrement the stack pointer, write the high byte to the new\n        //  stack pointer location, then repeat for the low byte.\n        sp = (sp - 1) & 0xffff;\n        core.mem_write(sp, (operand & 0xff00) >>> 8);\n        sp = (sp - 1) & 0xffff;\n        core.mem_write(sp, operand & 0x00ff);\n    };\n\n    let pop_word = function () {\n        // Again, not complicated; read a byte off the top of the stack,\n        //  increment the stack pointer, rinse and repeat.\n        var retval = core.mem_read(sp) & 0xff;\n        sp = (sp + 1) & 0xffff;\n        retval |= core.mem_read(sp) << 8;\n        sp = (sp + 1) & 0xffff;\n        return retval;\n    };\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// Now, the way most instructions work in this emulator is that they set up\n    ///  their operands according to their addressing mode, and then they call a\n    ///  utility function that handles all variations of that instruction.\n    /// Those utility functions begin here.\n    ///////////////////////////////////////////////////////////////////////////////\n    let do_conditional_absolute_jump = function (condition:boolean) {\n        // This function implements the JP [condition],nn instructions.\n        if (condition) {\n            // We're taking this jump, so write the new PC,\n            //  and then decrement the thing we just wrote,\n            //  because the instruction decoder increments the PC\n            //  unconditionally at the end of every instruction\n            //  and we need to counteract that so we end up at the jump target.\n            pc = core.mem_read((pc + 1) & 0xffff) |\n                (core.mem_read((pc + 2) & 0xffff) << 8);\n            pc = (pc - 1) & 0xffff;\n        }\n        else {\n            // We're not taking this jump, just move the PC past the operand.\n            pc = (pc + 2) & 0xffff;\n        }\n    };\n\n    let do_conditional_relative_jump = function (condition:boolean) {\n        // This function implements the JR [condition],n instructions.\n        if (condition) {\n            // We need a few more cycles to actually take the jump.\n            cycle_counter += 5;\n            // Calculate the offset specified by our operand.\n            var offset = get_signed_offset_byte(core.mem_read((pc + 1) & 0xffff));\n            // Add the offset to the PC, also skipping past this instruction.\n            pc = (pc + offset + 1) & 0xffff;\n        }\n        else {\n            // No jump happening, just skip the operand.\n            pc = (pc + 1) & 0xffff;\n        }\n    };\n\n    let do_conditional_call = function (condition:boolean) {\n        // This function is the CALL [condition],nn instructions.\n        // If you've seen the previous functions, you know this drill.\n        if (condition) {\n            cycle_counter += 7;\n            push_word((pc + 3) & 0xffff);\n            pc = core.mem_read((pc + 1) & 0xffff) |\n                (core.mem_read((pc + 2) & 0xffff) << 8);\n            pc = (pc - 1) & 0xffff;\n        }\n        else {\n            pc = (pc + 2) & 0xffff;\n        }\n    };\n\n    let do_conditional_return = function (condition:boolean) {\n        if (condition) {\n            cycle_counter += 6;\n            pc = (pop_word() - 1) & 0xffff;\n        }\n    };\n\n    let do_reset = function (address:number) {\n        // The RST [address] instructions go through here.\n        push_word((pc + 1) & 0xffff);\n        pc = (address - 1) & 0xffff;\n    };\n\n    let do_add = function (operand:number) {\n        // This is the ADD A, [operand] instructions.\n        // We'll do the literal addition, which includes any overflow,\n        //  so that we can more easily figure out whether we had\n        //  an overflow or a carry and set the flags accordingly.\n        var result = a + operand;\n\n        // The great majority of the work for the arithmetic instructions\n        //  turns out to be setting the flags rather than the actual operation.\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = !(result & 0xff) ? 1 : 0;\n        flags.H = (((operand & 0x0f) + (a & 0x0f)) & 0x10) ? 1 : 0;\n        // An overflow has happened if the sign bits of the accumulator and the operand\n        //  don't match the sign bit of the result value.\n        flags.P = ((a & 0x80) === (operand & 0x80)) && ((a & 0x80) !== (result & 0x80)) ? 1 : 0;\n        flags.N = 0;\n        flags.C = (result & 0x100) ? 1 : 0;\n\n        a = result & 0xff;\n        update_xy_flags(a);\n    };\n\n    let do_adc = function (operand:number) {\n        var result = a + operand + flags.C;\n\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = !(result & 0xff) ? 1 : 0;\n        flags.H = (((operand & 0x0f) + (a & 0x0f) + flags.C) & 0x10) ? 1 : 0;\n        flags.P = ((a & 0x80) === (operand & 0x80)) && ((a & 0x80) !== (result & 0x80)) ? 1 : 0;\n        flags.N = 0;\n        flags.C = (result & 0x100) ? 1 : 0;\n\n        a = result & 0xff;\n        update_xy_flags(a);\n    };\n\n    let do_sub = function (operand:number) {\n        var result = a - operand;\n\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = !(result & 0xff) ? 1 : 0;\n        flags.H = (((a & 0x0f) - (operand & 0x0f)) & 0x10) ? 1 : 0;\n        flags.P = ((a & 0x80) !== (operand & 0x80)) && ((a & 0x80) !== (result & 0x80)) ? 1 : 0;\n        flags.N = 1;\n        flags.C = (result & 0x100) ? 1 : 0;\n\n        a = result & 0xff;\n        update_xy_flags(a);\n    };\n\n    let do_sbc = function (operand:number) {\n        var result = a - operand - flags.C;\n\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = !(result & 0xff) ? 1 : 0;\n        flags.H = (((a & 0x0f) - (operand & 0x0f) - flags.C) & 0x10) ? 1 : 0;\n        flags.P = ((a & 0x80) !== (operand & 0x80)) && ((a & 0x80) !== (result & 0x80)) ? 1 : 0;\n        flags.N = 1;\n        flags.C = (result & 0x100) ? 1 : 0;\n\n        a = result & 0xff;\n        update_xy_flags(a);\n    };\n\n    let do_cp = function (operand:number) {\n        // A compare instruction is just a subtraction that doesn't save the value,\n        //  so we implement it as... a subtraction that doesn't save the value.\n        var temp = a;\n        do_sub(operand);\n        a = temp;\n        // Since this instruction has no \"result\" value, the undocumented flags\n        //  are set based on the operand instead.\n        update_xy_flags(operand);\n    };\n\n    let do_and = function (operand:number) {\n        // The logic instructions are all pretty straightforward.\n        a &= operand & 0xff;\n        flags.S = (a & 0x80) ? 1 : 0;\n        flags.Z = !a ? 1 : 0;\n        flags.H = 1;\n        flags.P = get_parity(a);\n        flags.N = 0;\n        flags.C = 0;\n        update_xy_flags(a);\n    };\n\n    let do_or = function (operand:number) {\n        a = (operand | a) & 0xff;\n        flags.S = (a & 0x80) ? 1 : 0;\n        flags.Z = !a ? 1 : 0;\n        flags.H = 0;\n        flags.P = get_parity(a);\n        flags.N = 0;\n        flags.C = 0;\n        update_xy_flags(a);\n    };\n\n    let do_xor = function (operand:number) {\n        a = (operand ^ a) & 0xff;\n        flags.S = (a & 0x80) ? 1 : 0;\n        flags.Z = !a ? 1 : 0;\n        flags.H = 0;\n        flags.P = get_parity(a);\n        flags.N = 0;\n        flags.C = 0;\n        update_xy_flags(a);\n    };\n\n    let do_inc = function (operand:number) {\n        var result = operand + 1;\n\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = !(result & 0xff) ? 1 : 0;\n        flags.H = ((operand & 0x0f) === 0x0f) ? 1 : 0;\n        // It's a good deal easier to detect overflow for an increment/decrement.\n        flags.P = (operand === 0x7f) ? 1 : 0;\n        flags.N = 0;\n\n        result &= 0xff;\n        update_xy_flags(result);\n\n        return result;\n    };\n\n    let do_dec = function (operand:number) {\n        var result = operand - 1;\n\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = !(result & 0xff) ? 1 : 0;\n        flags.H = ((operand & 0x0f) === 0x00) ? 1 : 0;\n        flags.P = (operand === 0x80) ? 1 : 0;\n        flags.N = 1;\n\n        result &= 0xff;\n        update_xy_flags(result);\n\n        return result;\n    };\n\n    let do_hl_add = function (operand:number) {\n        // The HL arithmetic instructions are the same as the A ones,\n        //  just with twice as many bits happening.\n        var hl = l | (h << 8), result = hl + operand;\n\n        flags.N = 0;\n        flags.C = (result & 0x10000) ? 1 : 0;\n        flags.H = (((hl & 0x0fff) + (operand & 0x0fff)) & 0x1000) ? 1 : 0;\n\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n\n        update_xy_flags(h);\n    };\n\n    let do_hl_adc = function (operand:number) {\n        operand += flags.C;\n        var hl = l | (h << 8), result = hl + operand;\n\n        flags.S = (result & 0x8000) ? 1 : 0;\n        flags.Z = !(result & 0xffff) ? 1 : 0;\n        flags.H = (((hl & 0x0fff) + (operand & 0x0fff)) & 0x1000) ? 1 : 0;\n        flags.P = ((hl & 0x8000) === (operand & 0x8000)) && ((result & 0x8000) !== (hl & 0x8000)) ? 1 : 0;\n        flags.N = 0;\n        flags.C = (result & 0x10000) ? 1 : 0;\n\n        l = result & 0xff;\n        h = (result >>> 8) & 0xff;\n\n        update_xy_flags(h);\n    };\n\n    let do_hl_sbc = function (operand:number) {\n        operand += flags.C;\n        var hl = l | (h << 8), result = hl - operand;\n\n        flags.S = (result & 0x8000) ? 1 : 0;\n        flags.Z = !(result & 0xffff) ? 1 : 0;\n        flags.H = (((hl & 0x0fff) - (operand & 0x0fff)) & 0x1000) ? 1 : 0;\n        flags.P = ((hl & 0x8000) !== (operand & 0x8000)) && ((result & 0x8000) !== (hl & 0x8000)) ? 1 : 0;\n        flags.N = 1;\n        flags.C = (result & 0x10000) ? 1 : 0;\n\n        l = result & 0xff;\n        h = (result >>> 8) & 0xff;\n\n        update_xy_flags(h);\n    };\n\n    let do_in = function (port:number) {\n        var result = core.io_read(port);\n\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = result ? 0 : 1;\n        flags.H = 0;\n        flags.P = get_parity(result) ? 1 : 0;\n        flags.N = 0;\n        update_xy_flags(result);\n\n        return result;\n    };\n\n    let do_neg = function () {\n        // This instruction is defined to not alter the register if it === 0x80.\n        if (a !== 0x80) {\n            // This is a signed operation, so convert A to a signed value.\n            a = get_signed_offset_byte(a);\n\n            a = (-a) & 0xff;\n        }\n\n        flags.S = (a & 0x80) ? 1 : 0;\n        flags.Z = !a ? 1 : 0;\n        flags.H = (((-a) & 0x0f) > 0) ? 1 : 0;\n        flags.P = (a === 0x80) ? 1 : 0;\n        flags.N = 1;\n        flags.C = a ? 1 : 0;\n        update_xy_flags(a);\n    };\n\n    let do_ldi = function () {\n        // Copy the value that we're supposed to copy.\n        var read_value = core.mem_read(l | (h << 8));\n        core.mem_write(e | (d << 8), read_value);\n\n        // Increment DE and HL, and decrement BC.\n        var result = (e | (d << 8)) + 1;\n        e = result & 0xff;\n        d = (result & 0xff00) >>> 8;\n        result = (l | (h << 8)) + 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n        result = (c | (b << 8)) - 1;\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n\n        flags.H = 0;\n        flags.P = (c || b) ? 1 : 0;\n        flags.N = 0;\n        flags.Y = ((a + read_value) & 0x02) >>> 1;\n        flags.X = ((a + read_value) & 0x08) >>> 3;\n    };\n\n    let do_cpi = function () {\n        var temp_carry = flags.C;\n        var read_value = core.mem_read(l | (h << 8))\n        do_cp(read_value);\n        flags.C = temp_carry;\n        flags.Y = ((a - read_value - flags.H) & 0x02) >>> 1;\n        flags.X = ((a - read_value - flags.H) & 0x08) >>> 3;\n\n        var result = (l | (h << 8)) + 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n        result = (c | (b << 8)) - 1;\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n\n        flags.P = result ? 1 : 0;\n    };\n\n    let do_ini = function () {\n        b = do_dec(b);\n\n        core.mem_write(l | (h << 8), core.io_read((b << 8) | c));\n\n        var result = (l | (h << 8)) + 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n\n        flags.N = 1;\n    };\n\n    let do_outi = function () {\n        core.io_write((b << 8) | c, core.mem_read(l | (h << 8)));\n\n        var result = (l | (h << 8)) + 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n\n        b = do_dec(b);\n        flags.N = 1;\n    };\n\n    let do_ldd = function () {\n        flags.N = 0;\n        flags.H = 0;\n\n        var read_value = core.mem_read(l | (h << 8));\n        core.mem_write(e | (d << 8), read_value);\n\n        var result = (e | (d << 8)) - 1;\n        e = result & 0xff;\n        d = (result & 0xff00) >>> 8;\n        result = (l | (h << 8)) - 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n        result = (c | (b << 8)) - 1;\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n\n        flags.P = (c || b) ? 1 : 0;\n        flags.Y = ((a + read_value) & 0x02) >>> 1;\n        flags.X = ((a + read_value) & 0x08) >>> 3;\n    };\n\n    let do_cpd = function () {\n        var temp_carry = flags.C\n        var read_value = core.mem_read(l | (h << 8))\n        do_cp(read_value);\n        flags.C = temp_carry;\n        flags.Y = ((a - read_value - flags.H) & 0x02) >>> 1;\n        flags.X = ((a - read_value - flags.H) & 0x08) >>> 3;\n\n        var result = (l | (h << 8)) - 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n        result = (c | (b << 8)) - 1;\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n\n        flags.P = result ? 1 : 0;\n    };\n\n    let do_ind = function () {\n        b = do_dec(b);\n\n        core.mem_write(l | (h << 8), core.io_read((b << 8) | c));\n\n        var result = (l | (h << 8)) - 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n\n        flags.N = 1;\n    };\n\n    let do_outd = function () {\n        core.io_write((b << 8) | c, core.mem_read(l | (h << 8)));\n\n        var result = (l | (h << 8)) - 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n\n        b = do_dec(b);\n        flags.N = 1;\n    };\n\n    let do_rlc = function (operand:number) {\n        flags.N = 0;\n        flags.H = 0;\n\n        flags.C = (operand & 0x80) >>> 7;\n        operand = ((operand << 1) | flags.C) & 0xff;\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_rrc = function (operand:number) {\n        flags.N = 0;\n        flags.H = 0;\n\n        flags.C = operand & 1;\n        operand = ((operand >>> 1) & 0x7f) | (flags.C << 7);\n\n        flags.Z = !(operand & 0xff) ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand & 0xff;\n    };\n\n    let do_rl = function (operand:number) {\n        flags.N = 0;\n        flags.H = 0;\n\n        var temp = flags.C;\n        flags.C = (operand & 0x80) >>> 7;\n        operand = ((operand << 1) | temp) & 0xff;\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_rr = function (operand:number) {\n        flags.N = 0;\n        flags.H = 0;\n\n        var temp = flags.C;\n        flags.C = operand & 1;\n        operand = ((operand >>> 1) & 0x7f) | (temp << 7);\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_sla = function (operand:number) {\n        flags.N = 0;\n        flags.H = 0;\n\n        flags.C = (operand & 0x80) >>> 7;\n        operand = (operand << 1) & 0xff;\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_sra = function (operand:number) {\n        flags.N = 0;\n        flags.H = 0;\n\n        flags.C = operand & 1;\n        operand = ((operand >>> 1) & 0x7f) | (operand & 0x80);\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_sll = function (operand:number) {\n        flags.N = 0;\n        flags.H = 0;\n\n        flags.C = (operand & 0x80) >>> 7;\n        operand = ((operand << 1) & 0xff) | 1;\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_srl = function (operand:number) {\n        flags.N = 0;\n        flags.H = 0;\n\n        flags.C = operand & 1;\n        operand = (operand >>> 1) & 0x7f;\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_ix_add = function (operand:number) {\n        flags.N = 0;\n\n        var result = ix + operand;\n\n        flags.C = (result & 0x10000) ? 1 : 0;\n        flags.H = (((ix & 0xfff) + (operand & 0xfff)) & 0x1000) ? 1 : 0;\n        update_xy_flags((result & 0xff00) >>> 8);\n\n        ix = result;\n    };\n\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// This table contains the implementations for the instructions that weren't\n    ///  implemented directly in the decoder function (everything but the 8-bit\n    ///  register loads and the accumulator ALU instructions, in other words).\n    /// Similar tables for the ED and DD/FD prefixes follow this one.\n    ///////////////////////////////////////////////////////////////////////////////\n    let instructions:any[] = [];\n\n    // 0x00 : NOP\n    instructions[0x00] = function () { };\n    // 0x01 : LD BC, nn\n    instructions[0x01] = function () {\n        pc = (pc + 1) & 0xffff;\n        c = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        b = core.mem_read(pc);\n    };\n    // 0x02 : LD (BC), A\n    instructions[0x02] = function () {\n        core.mem_write(c | (b << 8), a);\n    };\n    // 0x03 : INC BC\n    instructions[0x03] = function () {\n        var result = (c | (b << 8));\n        result += 1;\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n    };\n    // 0x04 : INC B\n    instructions[0x04] = function () {\n        b = do_inc(b);\n    };\n    // 0x05 : DEC B\n    instructions[0x05] = function () {\n        b = do_dec(b);\n    };\n    // 0x06 : LD B, n\n    instructions[0x06] = function () {\n        pc = (pc + 1) & 0xffff;\n        b = core.mem_read(pc);\n    };\n    // 0x07 : RLCA\n    instructions[0x07] = function () {\n        // This instruction is implemented as a special case of the\n        //  more general Z80-specific RLC instruction.\n        // Specifially, RLCA is a version of RLC A that affects fewer flags.\n        // The same applies to RRCA, RLA, and RRA.\n        var temp_s = flags.S, temp_z = flags.Z, temp_p = flags.P;\n        a = do_rlc(a);\n        flags.S = temp_s;\n        flags.Z = temp_z;\n        flags.P = temp_p;\n    };\n    // 0x08 : EX AF, AF'\n    instructions[0x08] = function () {\n        var temp = a;\n        a = a_prime;\n        a_prime = temp;\n\n        temp = get_flags_register();\n        set_flags_register(get_flags_prime());\n        set_flags_prime(temp);\n    };\n    // 0x09 : ADD HL, BC\n    instructions[0x09] = function () {\n        do_hl_add(c | (b << 8));\n    };\n    // 0x0a : LD A, (BC)\n    instructions[0x0a] = function () {\n        a = core.mem_read(c | (b << 8));\n    };\n    // 0x0b : DEC BC\n    instructions[0x0b] = function () {\n        var result = (c | (b << 8));\n        result -= 1;\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n    };\n    // 0x0c : INC C\n    instructions[0x0c] = function () {\n        c = do_inc(c);\n    };\n    // 0x0d : DEC C\n    instructions[0x0d] = function () {\n        c = do_dec(c);\n    };\n    // 0x0e : LD C, n\n    instructions[0x0e] = function () {\n        pc = (pc + 1) & 0xffff;\n        c = core.mem_read(pc);\n    };\n    // 0x0f : RRCA\n    instructions[0x0f] = function () {\n        var temp_s = flags.S, temp_z = flags.Z, temp_p = flags.P;\n        a = do_rrc(a);\n        flags.S = temp_s;\n        flags.Z = temp_z;\n        flags.P = temp_p;\n    };\n    // 0x10 : DJNZ nn\n    instructions[0x10] = function () {\n        b = (b - 1) & 0xff;\n        do_conditional_relative_jump(b !== 0);\n    };\n    // 0x11 : LD DE, nn\n    instructions[0x11] = function () {\n        pc = (pc + 1) & 0xffff;\n        e = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        d = core.mem_read(pc);\n    };\n    // 0x12 : LD (DE), A\n    instructions[0x12] = function () {\n        core.mem_write(e | (d << 8), a);\n    };\n    // 0x13 : INC DE\n    instructions[0x13] = function () {\n        var result = (e | (d << 8));\n        result += 1;\n        e = result & 0xff;\n        d = (result & 0xff00) >>> 8;\n    };\n    // 0x14 : INC D\n    instructions[0x14] = function () {\n        d = do_inc(d);\n    };\n    // 0x15 : DEC D\n    instructions[0x15] = function () {\n        d = do_dec(d);\n    };\n    // 0x16 : LD D, n\n    instructions[0x16] = function () {\n        pc = (pc + 1) & 0xffff;\n        d = core.mem_read(pc);\n    };\n    // 0x17 : RLA\n    instructions[0x17] = function () {\n        var temp_s = flags.S, temp_z = flags.Z, temp_p = flags.P;\n        a = do_rl(a);\n        flags.S = temp_s;\n        flags.Z = temp_z;\n        flags.P = temp_p;\n    };\n    // 0x18 : JR n\n    instructions[0x18] = function () {\n        var offset = get_signed_offset_byte(core.mem_read((pc + 1) & 0xffff));\n        pc = (pc + offset + 1) & 0xffff;\n    };\n    // 0x19 : ADD HL, DE\n    instructions[0x19] = function () {\n        do_hl_add(e | (d << 8));\n    };\n    // 0x1a : LD A, (DE)\n    instructions[0x1a] = function () {\n        a = core.mem_read(e | (d << 8));\n    };\n    // 0x1b : DEC DE\n    instructions[0x1b] = function () {\n        var result = (e | (d << 8));\n        result -= 1;\n        e = result & 0xff;\n        d = (result & 0xff00) >>> 8;\n    };\n    // 0x1c : INC E\n    instructions[0x1c] = function () {\n        e = do_inc(e);\n    };\n    // 0x1d : DEC E\n    instructions[0x1d] = function () {\n        e = do_dec(e);\n    };\n    // 0x1e : LD E, n\n    instructions[0x1e] = function () {\n        pc = (pc + 1) & 0xffff;\n        e = core.mem_read(pc);\n    };\n    // 0x1f : RRA\n    instructions[0x1f] = function () {\n        var temp_s = flags.S, temp_z = flags.Z, temp_p = flags.P;\n        a = do_rr(a);\n        flags.S = temp_s;\n        flags.Z = temp_z;\n        flags.P = temp_p;\n    };\n    // 0x20 : JR NZ, n\n    instructions[0x20] = function () {\n        do_conditional_relative_jump(!flags.Z);\n    };\n    // 0x21 : LD HL, nn\n    instructions[0x21] = function () {\n        pc = (pc + 1) & 0xffff;\n        l = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        h = core.mem_read(pc);\n    };\n    // 0x22 : LD (nn), HL\n    instructions[0x22] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        core.mem_write(address, l);\n        core.mem_write((address + 1) & 0xffff, h);\n    };\n    // 0x23 : INC HL\n    instructions[0x23] = function () {\n        var result = (l | (h << 8));\n        result += 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n    };\n    // 0x24 : INC H\n    instructions[0x24] = function () {\n        h = do_inc(h);\n    };\n    // 0x25 : DEC H\n    instructions[0x25] = function () {\n        h = do_dec(h);\n    };\n    // 0x26 : LD H, n\n    instructions[0x26] = function () {\n        pc = (pc + 1) & 0xffff;\n        h = core.mem_read(pc);\n    };\n    // 0x27 : DAA\n    instructions[0x27] = function () {\n        var temp = a;\n        if (!flags.N) {\n            if (flags.H || ((a & 0x0f) > 9))\n                temp += 0x06;\n            if (flags.C || (a > 0x99))\n                temp += 0x60;\n        }\n        else {\n            if (flags.H || ((a & 0x0f) > 9))\n                temp -= 0x06;\n            if (flags.C || (a > 0x99))\n                temp -= 0x60;\n        }\n\n        flags.S = (temp & 0x80) ? 1 : 0;\n        flags.Z = !(temp & 0xff) ? 1 : 0;\n        flags.H = ((a & 0x10) ^ (temp & 0x10)) ? 1 : 0;\n        flags.P = get_parity(temp & 0xff);\n        // DAA never clears the carry flag if it was already set,\n        //  but it is able to set the carry flag if it was clear.\n        // Don't ask me, I don't know.\n        // Note also that we check for a BCD carry, instead of the usual.\n        flags.C = (flags.C || (a > 0x99)) ? 1 : 0;\n\n        a = temp & 0xff;\n\n        update_xy_flags(a);\n    };\n    // 0x28 : JR Z, n\n    instructions[0x28] = function () {\n        do_conditional_relative_jump(!!flags.Z);\n    };\n    // 0x29 : ADD HL, HL\n    instructions[0x29] = function () {\n        do_hl_add(l | (h << 8));\n    };\n    // 0x2a : LD HL, (nn)\n    instructions[0x2a] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        l = core.mem_read(address);\n        h = core.mem_read((address + 1) & 0xffff);\n    };\n    // 0x2b : DEC HL\n    instructions[0x2b] = function () {\n        var result = (l | (h << 8));\n        result -= 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n    };\n    // 0x2c : INC L\n    instructions[0x2c] = function () {\n        l = do_inc(l);\n    };\n    // 0x2d : DEC L\n    instructions[0x2d] = function () {\n        l = do_dec(l);\n    };\n    // 0x2e : LD L, n\n    instructions[0x2e] = function () {\n        pc = (pc + 1) & 0xffff;\n        l = core.mem_read(pc);\n    };\n    // 0x2f : CPL\n    instructions[0x2f] = function () {\n        a = (~a) & 0xff;\n        flags.N = 1;\n        flags.H = 1;\n        update_xy_flags(a);\n    };\n    // 0x30 : JR NC, n\n    instructions[0x30] = function () {\n        do_conditional_relative_jump(!flags.C);\n    };\n    // 0x31 : LD SP, nn\n    instructions[0x31] = function () {\n        sp = core.mem_read((pc + 1) & 0xffff) |\n            (core.mem_read((pc + 2) & 0xffff) << 8);\n        pc = (pc + 2) & 0xffff;\n    };\n    // 0x32 : LD (nn), A\n    instructions[0x32] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        core.mem_write(address, a);\n    };\n    // 0x33 : INC SP\n    instructions[0x33] = function () {\n        sp = (sp + 1) & 0xffff;\n    };\n    // 0x34 : INC (HL)\n    instructions[0x34] = function () {\n        var address = l | (h << 8);\n        core.mem_write(address, do_inc(core.mem_read(address)));\n    };\n    // 0x35 : DEC (HL)\n    instructions[0x35] = function () {\n        var address = l | (h << 8);\n        core.mem_write(address, do_dec(core.mem_read(address)));\n    };\n    // 0x36 : LD (HL), n\n    instructions[0x36] = function () {\n        pc = (pc + 1) & 0xffff;\n        core.mem_write(l | (h << 8), core.mem_read(pc));\n    };\n    // 0x37 : SCF\n    instructions[0x37] = function () {\n        flags.N = 0;\n        flags.H = 0;\n        flags.C = 1;\n        update_xy_flags(a);\n    };\n    // 0x38 : JR C, n\n    instructions[0x38] = function () {\n        do_conditional_relative_jump(!!flags.C);\n    };\n    // 0x39 : ADD HL, SP\n    instructions[0x39] = function () {\n        do_hl_add(sp);\n    };\n    // 0x3a : LD A, (nn)\n    instructions[0x3a] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        a = core.mem_read(address);\n    };\n    // 0x3b : DEC SP\n    instructions[0x3b] = function () {\n        sp = (sp - 1) & 0xffff;\n    };\n    // 0x3c : INC A\n    instructions[0x3c] = function () {\n        a = do_inc(a);\n    };\n    // 0x3d : DEC A\n    instructions[0x3d] = function () {\n        a = do_dec(a);\n    };\n    // 0x3e : LD A, n\n    instructions[0x3e] = function () {\n        a = core.mem_read((pc + 1) & 0xffff);\n        pc = (pc + 1) & 0xffff;\n    };\n    // 0x3f : CCF\n    instructions[0x3f] = function () {\n        flags.N = 0;\n        flags.H = flags.C;\n        flags.C = flags.C ? 0 : 1;\n        update_xy_flags(a);\n    };\n    // 0xc0 : RET NZ\n    instructions[0xc0] = function () {\n        do_conditional_return(!flags.Z);\n    };\n    // 0xc1 : POP BC\n    instructions[0xc1] = function () {\n        var result = pop_word();\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n    };\n    // 0xc2 : JP NZ, nn\n    instructions[0xc2] = function () {\n        do_conditional_absolute_jump(!flags.Z);\n    };\n    // 0xc3 : JP nn\n    instructions[0xc3] = function () {\n        pc = core.mem_read((pc + 1) & 0xffff) |\n            (core.mem_read((pc + 2) & 0xffff) << 8);\n        pc = (pc - 1) & 0xffff;\n    };\n    // 0xc4 : CALL NZ, nn\n    instructions[0xc4] = function () {\n        do_conditional_call(!flags.Z);\n    };\n    // 0xc5 : PUSH BC\n    instructions[0xc5] = function () {\n        push_word(c | (b << 8));\n    };\n    // 0xc6 : ADD A, n\n    instructions[0xc6] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_add(core.mem_read(pc));\n    };\n    // 0xc7 : RST 00h\n    instructions[0xc7] = function () {\n        do_reset(0x00);\n    };\n    // 0xc8 : RET Z\n    instructions[0xc8] = function () {\n        do_conditional_return(!!flags.Z);\n    };\n    // 0xc9 : RET\n    instructions[0xc9] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n    };\n    // 0xca : JP Z, nn\n    instructions[0xca] = function () {\n        do_conditional_absolute_jump(!!flags.Z);\n    };\n    // 0xcb : CB Prefix\n    instructions[0xcb] = function () {\n        // R is incremented at the start of the second instruction cycle,\n        //  before the instruction actually runs.\n        // The high bit of R is not affected by this increment,\n        //  it can only be changed using the LD R, A instruction.\n        r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n\n        // We don't have a table for this prefix,\n        //  the instructions are all so uniform that we can directly decode them.\n        pc = (pc + 1) & 0xffff;\n        var opcode = core.mem_read(pc),\n            bit_number = (opcode & 0x38) >>> 3,\n            reg_code = opcode & 0x07;\n\n        if (opcode < 0x40) {\n            // Shift/rotate instructions\n            var op_array = [do_rlc, do_rrc, do_rl, do_rr,\n                do_sla, do_sra, do_sll, do_srl];\n\n            if (reg_code === 0)\n                b = op_array[bit_number](b);\n            else if (reg_code === 1)\n                c = op_array[bit_number](c);\n            else if (reg_code === 2)\n                d = op_array[bit_number](d);\n            else if (reg_code === 3)\n                e = op_array[bit_number](e);\n            else if (reg_code === 4)\n                h = op_array[bit_number](h);\n            else if (reg_code === 5)\n                l = op_array[bit_number](l);\n            else if (reg_code === 6)\n                core.mem_write(l | (h << 8),\n                    op_array[bit_number](core.mem_read(l | (h << 8))));\n            else if (reg_code === 7)\n                a = op_array[bit_number](a);\n        }\n        else if (opcode < 0x80) {\n            // BIT instructions\n            if (reg_code === 0)\n                flags.Z = !(b & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 1)\n                flags.Z = !(c & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 2)\n                flags.Z = !(d & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 3)\n                flags.Z = !(e & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 4)\n                flags.Z = !(h & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 5)\n                flags.Z = !(l & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 6)\n                flags.Z = !((core.mem_read(l | (h << 8))) & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 7)\n                flags.Z = !(a & (1 << bit_number)) ? 1 : 0;\n\n            flags.N = 0;\n            flags.H = 1;\n            flags.P = flags.Z;\n            flags.S = ((bit_number === 7) && !flags.Z) ? 1 : 0;\n            // For the BIT n, (HL) instruction, the X and Y flags are obtained\n            //  from what is apparently an internal temporary register used for\n            //  some of the 16-bit arithmetic instructions.\n            // I haven't implemented that register here,\n            //  so for now we'll set X and Y the same way for every BIT opcode,\n            //  which means that they will usually be wrong for BIT n, (HL).\n            flags.Y = ((bit_number === 5) && !flags.Z) ? 1 : 0;\n            flags.X = ((bit_number === 3) && !flags.Z) ? 1 : 0;\n        }\n        else if (opcode < 0xc0) {\n            // RES instructions\n            if (reg_code === 0)\n                b &= (0xff & ~(1 << bit_number));\n            else if (reg_code === 1)\n                c &= (0xff & ~(1 << bit_number));\n            else if (reg_code === 2)\n                d &= (0xff & ~(1 << bit_number));\n            else if (reg_code === 3)\n                e &= (0xff & ~(1 << bit_number));\n            else if (reg_code === 4)\n                h &= (0xff & ~(1 << bit_number));\n            else if (reg_code === 5)\n                l &= (0xff & ~(1 << bit_number));\n            else if (reg_code === 6)\n                core.mem_write(l | (h << 8),\n                    core.mem_read(l | (h << 8)) & ~(1 << bit_number));\n            else if (reg_code === 7)\n                a &= (0xff & ~(1 << bit_number));\n        }\n        else {\n            // SET instructions\n            if (reg_code === 0)\n                b |= (1 << bit_number);\n            else if (reg_code === 1)\n                c |= (1 << bit_number);\n            else if (reg_code === 2)\n                d |= (1 << bit_number);\n            else if (reg_code === 3)\n                e |= (1 << bit_number);\n            else if (reg_code === 4)\n                h |= (1 << bit_number);\n            else if (reg_code === 5)\n                l |= (1 << bit_number);\n            else if (reg_code === 6)\n                core.mem_write(l | (h << 8),\n                    core.mem_read(l | (h << 8)) | (1 << bit_number));\n            else if (reg_code === 7)\n                a |= (1 << bit_number);\n        }\n\n        cycle_counter += cycle_counts_cb[opcode];\n    };\n    // 0xcc : CALL Z, nn\n    instructions[0xcc] = function () {\n        do_conditional_call(!!flags.Z);\n    };\n    // 0xcd : CALL nn\n    instructions[0xcd] = function () {\n        push_word((pc + 3) & 0xffff);\n        pc = core.mem_read((pc + 1) & 0xffff) |\n            (core.mem_read((pc + 2) & 0xffff) << 8);\n        pc = (pc - 1) & 0xffff;\n    };\n    // 0xce : ADC A, n\n    instructions[0xce] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_adc(core.mem_read(pc));\n    };\n    // 0xcf : RST 08h\n    instructions[0xcf] = function () {\n        do_reset(0x08);\n    };\n    // 0xd0 : RET NC\n    instructions[0xd0] = function () {\n        do_conditional_return(!flags.C);\n    };\n    // 0xd1 : POP DE\n    instructions[0xd1] = function () {\n        var result = pop_word();\n        e = result & 0xff;\n        d = (result & 0xff00) >>> 8;\n    };\n    // 0xd2 : JP NC, nn\n    instructions[0xd2] = function () {\n        do_conditional_absolute_jump(!flags.C);\n    };\n    // 0xd3 : OUT (n), A\n    instructions[0xd3] = function () {\n        pc = (pc + 1) & 0xffff;\n        core.io_write((a << 8) | core.mem_read(pc), a);\n    };\n    // 0xd4 : CALL NC, nn\n    instructions[0xd4] = function () {\n        do_conditional_call(!flags.C);\n    };\n    // 0xd5 : PUSH DE\n    instructions[0xd5] = function () {\n        push_word(e | (d << 8));\n    };\n    // 0xd6 : SUB n\n    instructions[0xd6] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_sub(core.mem_read(pc));\n    };\n    // 0xd7 : RST 10h\n    instructions[0xd7] = function () {\n        do_reset(0x10);\n    };\n    // 0xd8 : RET C\n    instructions[0xd8] = function () {\n        do_conditional_return(!!flags.C);\n    };\n    // 0xd9 : EXX\n    instructions[0xd9] = function () {\n        var temp = b;\n        b = b_prime;\n        b_prime = temp;\n        temp = c;\n        c = c_prime;\n        c_prime = temp;\n        temp = d;\n        d = d_prime;\n        d_prime = temp;\n        temp = e;\n        e = e_prime;\n        e_prime = temp;\n        temp = h;\n        h = h_prime;\n        h_prime = temp;\n        temp = l;\n        l = l_prime;\n        l_prime = temp;\n    };\n    // 0xda : JP C, nn\n    instructions[0xda] = function () {\n        do_conditional_absolute_jump(!!flags.C);\n    };\n    // 0xdb : IN A, (n)\n    instructions[0xdb] = function () {\n        pc = (pc + 1) & 0xffff;\n        a = core.io_read((a << 8) | core.mem_read(pc));\n    };\n    // 0xdc : CALL C, nn\n    instructions[0xdc] = function () {\n        do_conditional_call(!!flags.C);\n    };\n    // 0xdd : DD Prefix (IX instructions)\n    instructions[0xdd] = function () {\n        // R is incremented at the start of the second instruction cycle,\n        //  before the instruction actually runs.\n        // The high bit of R is not affected by this increment,\n        //  it can only be changed using the LD R, A instruction.\n        r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n\n        pc = (pc + 1) & 0xffff;\n        var opcode = core.mem_read(pc),\n            func = dd_instructions[opcode];\n\n        if (func) {\n            //func = func.bind(this);\n            func();\n            cycle_counter += cycle_counts_dd[opcode];\n        }\n        else {\n            // Apparently if a DD opcode doesn't exist,\n            //  it gets treated as an unprefixed opcode.\n            // What we'll do to handle that is just back up the\n            //  program counter, so that this byte gets decoded\n            //  as a normal instruction.\n            pc = (pc - 1) & 0xffff;\n            // And we'll add in the cycle count for a NOP.\n            cycle_counter += cycle_counts[0];\n        }\n    };\n    // 0xde : SBC n\n    instructions[0xde] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_sbc(core.mem_read(pc));\n    };\n    // 0xdf : RST 18h\n    instructions[0xdf] = function () {\n        do_reset(0x18);\n    };\n    // 0xe0 : RET PO\n    instructions[0xe0] = function () {\n        do_conditional_return(!flags.P);\n    };\n    // 0xe1 : POP HL\n    instructions[0xe1] = function () {\n        var result = pop_word();\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n    };\n    // 0xe2 : JP PO, (nn)\n    instructions[0xe2] = function () {\n        do_conditional_absolute_jump(!flags.P);\n    };\n    // 0xe3 : EX (SP), HL\n    instructions[0xe3] = function () {\n        var temp = core.mem_read(sp);\n        core.mem_write(sp, l);\n        l = temp;\n        temp = core.mem_read((sp + 1) & 0xffff);\n        core.mem_write((sp + 1) & 0xffff, h);\n        h = temp;\n    };\n    // 0xe4 : CALL PO, nn\n    instructions[0xe4] = function () {\n        do_conditional_call(!flags.P);\n    };\n    // 0xe5 : PUSH HL\n    instructions[0xe5] = function () {\n        push_word(l | (h << 8));\n    };\n    // 0xe6 : AND n\n    instructions[0xe6] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_and(core.mem_read(pc));\n    };\n    // 0xe7 : RST 20h\n    instructions[0xe7] = function () {\n        do_reset(0x20);\n    };\n    // 0xe8 : RET PE\n    instructions[0xe8] = function () {\n        do_conditional_return(!!flags.P);\n    };\n    // 0xe9 : JP (HL)\n    instructions[0xe9] = function () {\n        pc = l | (h << 8);\n        pc = (pc - 1) & 0xffff;\n    };\n    // 0xea : JP PE, nn\n    instructions[0xea] = function () {\n        do_conditional_absolute_jump(!!flags.P);\n    };\n    // 0xeb : EX DE, HL\n    instructions[0xeb] = function () {\n        var temp = d;\n        d = h;\n        h = temp;\n        temp = e;\n        e = l;\n        l = temp;\n    };\n    // 0xec : CALL PE, nn\n    instructions[0xec] = function () {\n        do_conditional_call(!!flags.P);\n    };\n    // 0xed : ED Prefix\n    instructions[0xed] = function () {\n        // R is incremented at the start of the second instruction cycle,\n        //  before the instruction actually runs.\n        // The high bit of R is not affected by this increment,\n        //  it can only be changed using the LD R, A instruction.\n        r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n\n        pc = (pc + 1) & 0xffff;\n        var opcode = core.mem_read(pc),\n            func = ed_instructions[opcode];\n\n        if (func) {\n            //func = func.bind(this);\n            func();\n            cycle_counter += cycle_counts_ed[opcode];\n        }\n        else {\n            // If the opcode didn't exist, the whole thing is a two-byte NOP.\n            cycle_counter += cycle_counts[0];\n        }\n    };\n    // 0xee : XOR n\n    instructions[0xee] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_xor(core.mem_read(pc));\n    };\n    // 0xef : RST 28h\n    instructions[0xef] = function () {\n        do_reset(0x28);\n    };\n    // 0xf0 : RET P\n    instructions[0xf0] = function () {\n        do_conditional_return(!flags.S);\n    };\n    // 0xf1 : POP AF\n    instructions[0xf1] = function () {\n        var result = pop_word();\n        set_flags_register(result & 0xff);\n        a = (result & 0xff00) >>> 8;\n    };\n    // 0xf2 : JP P, nn\n    instructions[0xf2] = function () {\n        do_conditional_absolute_jump(!flags.S);\n    };\n    // 0xf3 : DI\n    instructions[0xf3] = function () {\n        // DI doesn't actually take effect until after the next instruction.\n        do_delayed_di = true;\n    };\n    // 0xf4 : CALL P, nn\n    instructions[0xf4] = function () {\n        do_conditional_call(!flags.S);\n    };\n    // 0xf5 : PUSH AF\n    instructions[0xf5] = function () {\n        push_word(get_flags_register() | (a << 8));\n    };\n    // 0xf6 : OR n\n    instructions[0xf6] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_or(core.mem_read(pc));\n    };\n    // 0xf7 : RST 30h\n    instructions[0xf7] = function () {\n        do_reset(0x30);\n    };\n    // 0xf8 : RET M\n    instructions[0xf8] = function () {\n        do_conditional_return(!!flags.S);\n    };\n    // 0xf9 : LD SP, HL\n    instructions[0xf9] = function () {\n        sp = l | (h << 8);\n    };\n    // 0xfa : JP M, nn\n    instructions[0xfa] = function () {\n        do_conditional_absolute_jump(!!flags.S);\n    };\n    // 0xfb : EI\n    instructions[0xfb] = function () {\n        // EI doesn't actually take effect until after the next instruction.\n        do_delayed_ei = true;\n    };\n    // 0xfc : CALL M, nn\n    instructions[0xfc] = function () {\n        do_conditional_call(!!flags.S);\n    };\n    // 0xfd : FD Prefix (IY instructions)\n    instructions[0xfd] = function () {\n        // R is incremented at the start of the second instruction cycle,\n        //  before the instruction actually runs.\n        // The high bit of R is not affected by this increment,\n        //  it can only be changed using the LD R, A instruction.\n        r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n\n        pc = (pc + 1) & 0xffff;\n        var opcode = core.mem_read(pc),\n            func = dd_instructions[opcode];\n\n        if (func) {\n            // Rather than copy and paste all the IX instructions into IY instructions,\n            //  what we'll do is sneakily copy IY into IX, run the IX instruction,\n            //  and then copy the result into IY and restore the old IX.\n            var temp = ix;\n            ix = iy;\n            //func = func.bind(this);\n            func();\n            iy = ix;\n            ix = temp;\n\n            cycle_counter += cycle_counts_dd[opcode];\n        }\n        else {\n            // Apparently if an FD opcode doesn't exist,\n            //  it gets treated as an unprefixed opcode.\n            // What we'll do to handle that is just back up the\n            //  program counter, so that this byte gets decoded\n            //  as a normal instruction.\n            pc = (pc - 1) & 0xffff;\n            // And we'll add in the cycle count for a NOP.\n            cycle_counter += cycle_counts[0];\n        }\n    };\n    // 0xfe : CP n\n    instructions[0xfe] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_cp(core.mem_read(pc));\n    };\n    // 0xff : RST 38h\n    instructions[0xff] = function () {\n        do_reset(0x38);\n    };\n\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// This table of ED opcodes is pretty sparse;\n    ///  there are not very many valid ED-prefixed opcodes in the Z80,\n    ///  and many of the ones that are valid are not documented.\n    ///////////////////////////////////////////////////////////////////////////////\n    let ed_instructions:any[] = [];\n    // 0x40 : IN B, (C)\n    ed_instructions[0x40] = function () {\n        b = do_in((b << 8) | c);\n    };\n    // 0x41 : OUT (C), B\n    ed_instructions[0x41] = function () {\n        core.io_write((b << 8) | c, b);\n    };\n    // 0x42 : SBC HL, BC\n    ed_instructions[0x42] = function () {\n        do_hl_sbc(c | (b << 8));\n    };\n    // 0x43 : LD (nn), BC\n    ed_instructions[0x43] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        core.mem_write(address, c);\n        core.mem_write((address + 1) & 0xffff, b);\n    };\n    // 0x44 : NEG\n    ed_instructions[0x44] = function () {\n        do_neg();\n    };\n    // 0x45 : RETN\n    ed_instructions[0x45] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x46 : IM 0\n    ed_instructions[0x46] = function () {\n        imode = 0;\n    };\n    // 0x47 : LD I, A\n    ed_instructions[0x47] = function () {\n        i = a\n    };\n    // 0x48 : IN C, (C)\n    ed_instructions[0x48] = function () {\n        c = do_in((b << 8) | c);\n    };\n    // 0x49 : OUT (C), C\n    ed_instructions[0x49] = function () {\n        core.io_write((b << 8) | c, c);\n    };\n    // 0x4a : ADC HL, BC\n    ed_instructions[0x4a] = function () {\n        do_hl_adc(c | (b << 8));\n    };\n    // 0x4b : LD BC, (nn)\n    ed_instructions[0x4b] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        c = core.mem_read(address);\n        b = core.mem_read((address + 1) & 0xffff);\n    };\n    // 0x4c : NEG (Undocumented)\n    ed_instructions[0x4c] = function () {\n        do_neg();\n    };\n    // 0x4d : RETI\n    ed_instructions[0x4d] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n    };\n    // 0x4e : IM 0 (Undocumented)\n    ed_instructions[0x4e] = function () {\n        imode = 0;\n    };\n    // 0x4f : LD R, A\n    ed_instructions[0x4f] = function () {\n        r = a;\n    };\n    // 0x50 : IN D, (C)\n    ed_instructions[0x50] = function () {\n        d = do_in((b << 8) | c);\n    };\n    // 0x51 : OUT (C), D\n    ed_instructions[0x51] = function () {\n        core.io_write((b << 8) | c, d);\n    };\n    // 0x52 : SBC HL, DE\n    ed_instructions[0x52] = function () {\n        do_hl_sbc(e | (d << 8));\n    };\n    // 0x53 : LD (nn), DE\n    ed_instructions[0x53] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        core.mem_write(address, e);\n        core.mem_write((address + 1) & 0xffff, d);\n    };\n    // 0x54 : NEG (Undocumented)\n    ed_instructions[0x54] = function () {\n        do_neg();\n    };\n    // 0x55 : RETN\n    ed_instructions[0x55] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x56 : IM 1\n    ed_instructions[0x56] = function () {\n        imode = 1;\n    };\n    // 0x57 : LD A, I\n    ed_instructions[0x57] = function () {\n        a = i;\n        flags.S = i & 0x80 ? 1 : 0;\n        flags.Z = i ? 0 : 1;\n        flags.H = 0;\n        flags.P = iff2;\n        flags.N = 0;\n    };\n    // 0x58 : IN E, (C)\n    ed_instructions[0x58] = function () {\n        e = do_in((b << 8) | c);\n    };\n    // 0x59 : OUT (C), E\n    ed_instructions[0x59] = function () {\n        core.io_write((b << 8) | c, e);\n    };\n    // 0x5a : ADC HL, DE\n    ed_instructions[0x5a] = function () {\n        do_hl_adc(e | (d << 8));\n    };\n    // 0x5b : LD DE, (nn)\n    ed_instructions[0x5b] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        e = core.mem_read(address);\n        d = core.mem_read((address + 1) & 0xffff);\n    };\n    // 0x5c : NEG (Undocumented)\n    ed_instructions[0x5c] = function () {\n        do_neg();\n    };\n    // 0x5d : RETN\n    ed_instructions[0x5d] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x5e : IM 2\n    ed_instructions[0x5e] = function () {\n        imode = 2;\n    };\n    // 0x5f : LD A, R\n    ed_instructions[0x5f] = function () {\n        a = r;\n        flags.P = iff2;\n    };\n    // 0x60 : IN H, (C)\n    ed_instructions[0x60] = function () {\n        h = do_in((b << 8) | c);\n    };\n    // 0x61 : OUT (C), H\n    ed_instructions[0x61] = function () {\n        core.io_write((b << 8) | c, h);\n    };\n    // 0x62 : SBC HL, HL\n    ed_instructions[0x62] = function () {\n        do_hl_sbc(l | (h << 8));\n    };\n    // 0x63 : LD (nn), HL (Undocumented)\n    ed_instructions[0x63] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        core.mem_write(address, l);\n        core.mem_write((address + 1) & 0xffff, h);\n    };\n    // 0x64 : NEG (Undocumented)\n    ed_instructions[0x64] = function () {\n        do_neg();\n    };\n    // 0x65 : RETN\n    ed_instructions[0x65] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x66 : IM 0\n    ed_instructions[0x66] = function () {\n        imode = 0;\n    };\n    // 0x67 : RRD\n    ed_instructions[0x67] = function () {\n        var hl_value = core.mem_read(l | (h << 8));\n        var temp1 = hl_value & 0x0f, temp2 = a & 0x0f;\n        hl_value = ((hl_value & 0xf0) >>> 4) | (temp2 << 4);\n        a = (a & 0xf0) | temp1;\n        core.mem_write(l | (h << 8), hl_value);\n\n        flags.S = (a & 0x80) ? 1 : 0;\n        flags.Z = a ? 0 : 1;\n        flags.H = 0;\n        flags.P = get_parity(a) ? 1 : 0;\n        flags.N = 0;\n        update_xy_flags(a);\n    };\n    // 0x68 : IN L, (C)\n    ed_instructions[0x68] = function () {\n        l = do_in((b << 8) | c);\n    };\n    // 0x69 : OUT (C), L\n    ed_instructions[0x69] = function () {\n        core.io_write((b << 8) | c, l);\n    };\n    // 0x6a : ADC HL, HL\n    ed_instructions[0x6a] = function () {\n        do_hl_adc(l | (h << 8));\n    };\n    // 0x6b : LD HL, (nn) (Undocumented)\n    ed_instructions[0x6b] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        l = core.mem_read(address);\n        h = core.mem_read((address + 1) & 0xffff);\n    };\n    // 0x6c : NEG (Undocumented)\n    ed_instructions[0x6c] = function () {\n        do_neg();\n    };\n    // 0x6d : RETN\n    ed_instructions[0x6d] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x6e : IM 0 (Undocumented)\n    ed_instructions[0x6e] = function () {\n        imode = 0;\n    };\n    // 0x6f : RLD\n    ed_instructions[0x6f] = function () {\n        var hl_value = core.mem_read(l | (h << 8));\n        var temp1 = hl_value & 0xf0, temp2 = a & 0x0f;\n        hl_value = ((hl_value & 0x0f) << 4) | temp2;\n        a = (a & 0xf0) | (temp1 >>> 4);\n        core.mem_write(l | (h << 8), hl_value);\n\n        flags.S = (a & 0x80) ? 1 : 0;\n        flags.Z = a ? 0 : 1;\n        flags.H = 0;\n        flags.P = get_parity(a) ? 1 : 0;\n        flags.N = 0;\n        update_xy_flags(a);\n    };\n    // 0x70 : IN (C) (Undocumented)\n    ed_instructions[0x70] = function () {\n        do_in((b << 8) | c);\n    };\n    // 0x71 : OUT (C), 0 (Undocumented)\n    ed_instructions[0x71] = function () {\n        core.io_write((b << 8) | c, 0);\n    };\n    // 0x72 : SBC HL, SP\n    ed_instructions[0x72] = function () {\n        do_hl_sbc(sp);\n    };\n    // 0x73 : LD (nn), SP\n    ed_instructions[0x73] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        core.mem_write(address, sp & 0xff);\n        core.mem_write((address + 1) & 0xffff, (sp >>> 8) & 0xff);\n    };\n    // 0x74 : NEG (Undocumented)\n    ed_instructions[0x74] = function () {\n        do_neg();\n    };\n    // 0x75 : RETN\n    ed_instructions[0x75] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x76 : IM 1\n    ed_instructions[0x76] = function () {\n        imode = 1;\n    };\n    // 0x78 : IN A, (C)\n    ed_instructions[0x78] = function () {\n        a = do_in((b << 8) | c);\n    };\n    // 0x79 : OUT (C), A\n    ed_instructions[0x79] = function () {\n        core.io_write((b << 8) | c, a);\n    };\n    // 0x7a : ADC HL, SP\n    ed_instructions[0x7a] = function () {\n        do_hl_adc(sp);\n    };\n    // 0x7b : LD SP, (nn)\n    ed_instructions[0x7b] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        sp = core.mem_read(address);\n        sp |= core.mem_read((address + 1) & 0xffff) << 8;\n    };\n    // 0x7c : NEG (Undocumented)\n    ed_instructions[0x7c] = function () {\n        do_neg();\n    };\n    // 0x7d : RETN\n    ed_instructions[0x7d] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x7e : IM 2\n    ed_instructions[0x7e] = function () {\n        imode = 2;\n    };\n    // 0xa0 : LDI\n    ed_instructions[0xa0] = function () {\n        do_ldi();\n    };\n    // 0xa1 : CPI\n    ed_instructions[0xa1] = function () {\n        do_cpi();\n    };\n    // 0xa2 : INI\n    ed_instructions[0xa2] = function () {\n        do_ini();\n    };\n    // 0xa3 : OUTI\n    ed_instructions[0xa3] = function () {\n        do_outi();\n    };\n    // 0xa8 : LDD\n    ed_instructions[0xa8] = function () {\n        do_ldd();\n    };\n    // 0xa9 : CPD\n    ed_instructions[0xa9] = function () {\n        do_cpd();\n    };\n    // 0xaa : IND\n    ed_instructions[0xaa] = function () {\n        do_ind();\n    };\n    // 0xab : OUTD\n    ed_instructions[0xab] = function () {\n        do_outd();\n    };\n    // 0xb0 : LDIR\n    ed_instructions[0xb0] = function () {\n        do_ldi();\n        if (b || c) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xb1 : CPIR\n    ed_instructions[0xb1] = function () {\n        do_cpi();\n        if (!flags.Z && (b || c)) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xb2 : INIR\n    ed_instructions[0xb2] = function () {\n        do_ini();\n        if (b) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xb3 : OTIR\n    ed_instructions[0xb3] = function () {\n        do_outi();\n        if (b) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xb8 : LDDR\n    ed_instructions[0xb8] = function () {\n        do_ldd();\n        if (b || c) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xb9 : CPDR\n    ed_instructions[0xb9] = function () {\n        do_cpd();\n        if (!flags.Z && (b || c)) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xba : INDR\n    ed_instructions[0xba] = function () {\n        do_ind();\n        if (b) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xbb : OTDR\n    ed_instructions[0xbb] = function () {\n        do_outd();\n        if (b) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// Like ED, this table is quite sparse,\n    ///  and many of the opcodes here are also undocumented.\n    /// The undocumented instructions here are those that deal with only one byte\n    ///  of the two-byte IX register; the bytes are designed IXH and IXL here.\n    ///////////////////////////////////////////////////////////////////////////////\n    let dd_instructions: (() => void)[] = [];\n    // 0x09 : ADD IX, BC\n    dd_instructions[0x09] = function () {\n        do_ix_add(c | (b << 8));\n    };\n    // 0x19 : ADD IX, DE\n    dd_instructions[0x19] = function () {\n        do_ix_add(e | (d << 8));\n    };\n    // 0x21 : LD IX, nn\n    dd_instructions[0x21] = function () {\n        pc = (pc + 1) & 0xffff;\n        ix = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        ix |= (core.mem_read(pc) << 8);\n    };\n    // 0x22 : LD (nn), IX\n    dd_instructions[0x22] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= (core.mem_read(pc) << 8);\n\n        core.mem_write(address, ix & 0xff);\n        core.mem_write((address + 1) & 0xffff, (ix >>> 8) & 0xff);\n    };\n    // 0x23 : INC IX\n    dd_instructions[0x23] = function () {\n        ix = (ix + 1) & 0xffff;\n    };\n    // 0x24 : INC IXH (Undocumented)\n    dd_instructions[0x24] = function () {\n        ix = (do_inc(ix >>> 8) << 8) | (ix & 0xff);\n    };\n    // 0x25 : DEC IXH (Undocumented)\n    dd_instructions[0x25] = function () {\n        ix = (do_dec(ix >>> 8) << 8) | (ix & 0xff);\n    };\n    // 0x26 : LD IXH, n (Undocumented)\n    dd_instructions[0x26] = function () {\n        pc = (pc + 1) & 0xffff;\n        ix = (core.mem_read(pc) << 8) | (ix & 0xff);\n    };\n    // 0x29 : ADD IX, IX\n    dd_instructions[0x29] = function () {\n        do_ix_add(ix);\n    };\n    // 0x2a : LD IX, (nn)\n    dd_instructions[0x2a] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= (core.mem_read(pc) << 8);\n\n        ix = core.mem_read(address);\n        ix |= (core.mem_read((address + 1) & 0xffff) << 8);\n    };\n    // 0x2b : DEC IX\n    dd_instructions[0x2b] = function () {\n        ix = (ix - 1) & 0xffff;\n    };\n    // 0x2c : INC IXL (Undocumented)\n    dd_instructions[0x2c] = function () {\n        ix = do_inc(ix & 0xff) | (ix & 0xff00);\n    };\n    // 0x2d : DEC IXL (Undocumented)\n    dd_instructions[0x2d] = function () {\n        ix = do_dec(ix & 0xff) | (ix & 0xff00);\n    };\n    // 0x2e : LD IXL, n (Undocumented)\n    dd_instructions[0x2e] = function () {\n        pc = (pc + 1) & 0xffff;\n        ix = (core.mem_read(pc) & 0xff) | (ix & 0xff00);\n    };\n    // 0x34 : INC (IX+n)\n    dd_instructions[0x34] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc)),\n            value = core.mem_read((offset + ix) & 0xffff);\n        core.mem_write((offset + ix) & 0xffff, do_inc(value));\n    };\n    // 0x35 : DEC (IX+n)\n    dd_instructions[0x35] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc)),\n            value = core.mem_read((offset + ix) & 0xffff);\n        core.mem_write((offset + ix) & 0xffff, do_dec(value));\n    };\n    // 0x36 : LD (IX+n), n\n    dd_instructions[0x36] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        pc = (pc + 1) & 0xffff;\n        core.mem_write((ix + offset) & 0xffff, core.mem_read(pc));\n    };\n    // 0x39 : ADD IX, SP\n    dd_instructions[0x39] = function () {\n        do_ix_add(sp);\n    };\n    // 0x44 : LD B, IXH (Undocumented)\n    dd_instructions[0x44] = function () {\n        b = (ix >>> 8) & 0xff;\n    };\n    // 0x45 : LD B, IXL (Undocumented)\n    dd_instructions[0x45] = function () {\n        b = ix & 0xff;\n    };\n    // 0x46 : LD B, (IX+n)\n    dd_instructions[0x46] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        b = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x4c : LD C, IXH (Undocumented)\n    dd_instructions[0x4c] = function () {\n        c = (ix >>> 8) & 0xff;\n    };\n    // 0x4d : LD C, IXL (Undocumented)\n    dd_instructions[0x4d] = function () {\n        c = ix & 0xff;\n    };\n    // 0x4e : LD C, (IX+n)\n    dd_instructions[0x4e] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        c = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x54 : LD D, IXH (Undocumented)\n    dd_instructions[0x54] = function () {\n        d = (ix >>> 8) & 0xff;\n    };\n    // 0x55 : LD D, IXL (Undocumented)\n    dd_instructions[0x55] = function () {\n        d = ix & 0xff;\n    };\n    // 0x56 : LD D, (IX+n)\n    dd_instructions[0x56] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        d = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x5c : LD E, IXH (Undocumented)\n    dd_instructions[0x5c] = function () {\n        e = (ix >>> 8) & 0xff;\n    };\n    // 0x5d : LD E, IXL (Undocumented)\n    dd_instructions[0x5d] = function () {\n        e = ix & 0xff;\n    };\n    // 0x5e : LD E, (IX+n)\n    dd_instructions[0x5e] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        e = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x60 : LD IXH, B (Undocumented)\n    dd_instructions[0x60] = function () {\n        ix = (ix & 0xff) | (b << 8);\n    };\n    // 0x61 : LD IXH, C (Undocumented)\n    dd_instructions[0x61] = function () {\n        ix = (ix & 0xff) | (c << 8);\n    };\n    // 0x62 : LD IXH, D (Undocumented)\n    dd_instructions[0x62] = function () {\n        ix = (ix & 0xff) | (d << 8);\n    };\n    // 0x63 : LD IXH, E (Undocumented)\n    dd_instructions[0x63] = function () {\n        ix = (ix & 0xff) | (e << 8);\n    };\n    // 0x64 : LD IXH, IXH (Undocumented)\n    dd_instructions[0x64] = function () {\n        // No-op.\n    };\n    // 0x65 : LD IXH, IXL (Undocumented)\n    dd_instructions[0x65] = function () {\n        ix = (ix & 0xff) | ((ix & 0xff) << 8);\n    };\n    // 0x66 : LD H, (IX+n)\n    dd_instructions[0x66] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        h = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x67 : LD IXH, A (Undocumented)\n    dd_instructions[0x67] = function () {\n        ix = (ix & 0xff) | (a << 8);\n    };\n    // 0x68 : LD IXL, B (Undocumented)\n    dd_instructions[0x68] = function () {\n        ix = (ix & 0xff00) | b;\n    };\n    // 0x69 : LD IXL, C (Undocumented)\n    dd_instructions[0x69] = function () {\n        ix = (ix & 0xff00) | c;\n    };\n    // 0x6a : LD IXL, D (Undocumented)\n    dd_instructions[0x6a] = function () {\n        ix = (ix & 0xff00) | d;\n    };\n    // 0x6b : LD IXL, E (Undocumented)\n    dd_instructions[0x6b] = function () {\n        ix = (ix & 0xff00) | e;\n    };\n    // 0x6c : LD IXL, IXH (Undocumented)\n    dd_instructions[0x6c] = function () {\n        ix = (ix & 0xff00) | (ix >>> 8);\n    };\n    // 0x6d : LD IXL, IXL (Undocumented)\n    dd_instructions[0x6d] = function () {\n        // No-op.\n    };\n    // 0x6e : LD L, (IX+n)\n    dd_instructions[0x6e] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        l = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x6f : LD IXL, A (Undocumented)\n    dd_instructions[0x6f] = function () {\n        ix = (ix & 0xff00) | a;\n    };\n    // 0x70 : LD (IX+n), B\n    dd_instructions[0x70] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, b);\n    };\n    // 0x71 : LD (IX+n), C\n    dd_instructions[0x71] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, c);\n    };\n    // 0x72 : LD (IX+n), D\n    dd_instructions[0x72] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, d);\n    };\n    // 0x73 : LD (IX+n), E\n    dd_instructions[0x73] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, e);\n    };\n    // 0x74 : LD (IX+n), H\n    dd_instructions[0x74] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, h);\n    };\n    // 0x75 : LD (IX+n), L\n    dd_instructions[0x75] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, l);\n    };\n    // 0x77 : LD (IX+n), A\n    dd_instructions[0x77] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, a);\n    };\n    // 0x7c : LD A, IXH (Undocumented)\n    dd_instructions[0x7c] = function () {\n        a = (ix >>> 8) & 0xff;\n    };\n    // 0x7d : LD A, IXL (Undocumented)\n    dd_instructions[0x7d] = function () {\n        a = ix & 0xff;\n    };\n    // 0x7e : LD A, (IX+n)\n    dd_instructions[0x7e] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        a = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x84 : ADD A, IXH (Undocumented)\n    dd_instructions[0x84] = function () {\n        do_add((ix >>> 8) & 0xff);\n    };\n    // 0x85 : ADD A, IXL (Undocumented)\n    dd_instructions[0x85] = function () {\n        do_add(ix & 0xff);\n    };\n    // 0x86 : ADD A, (IX+n)\n    dd_instructions[0x86] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_add(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0x8c : ADC A, IXH (Undocumented)\n    dd_instructions[0x8c] = function () {\n        do_adc((ix >>> 8) & 0xff);\n    };\n    // 0x8d : ADC A, IXL (Undocumented)\n    dd_instructions[0x8d] = function () {\n        do_adc(ix & 0xff);\n    };\n    // 0x8e : ADC A, (IX+n)\n    dd_instructions[0x8e] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_adc(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0x94 : SUB IXH (Undocumented)\n    dd_instructions[0x94] = function () {\n        do_sub((ix >>> 8) & 0xff);\n    };\n    // 0x95 : SUB IXL (Undocumented)\n    dd_instructions[0x95] = function () {\n        do_sub(ix & 0xff);\n    };\n    // 0x96 : SUB A, (IX+n)\n    dd_instructions[0x96] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_sub(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0x9c : SBC IXH (Undocumented)\n    dd_instructions[0x9c] = function () {\n        do_sbc((ix >>> 8) & 0xff);\n    };\n    // 0x9d : SBC IXL (Undocumented)\n    dd_instructions[0x9d] = function () {\n        do_sbc(ix & 0xff);\n    };\n    // 0x9e : SBC A, (IX+n)\n    dd_instructions[0x9e] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_sbc(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0xa4 : AND IXH (Undocumented)\n    dd_instructions[0xa4] = function () {\n        do_and((ix >>> 8) & 0xff);\n    };\n    // 0xa5 : AND IXL (Undocumented)\n    dd_instructions[0xa5] = function () {\n        do_and(ix & 0xff);\n    };\n    // 0xa6 : AND A, (IX+n)\n    dd_instructions[0xa6] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_and(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0xac : XOR IXH (Undocumented)\n    dd_instructions[0xac] = function () {\n        do_xor((ix >>> 8) & 0xff);\n    };\n    // 0xad : XOR IXL (Undocumented)\n    dd_instructions[0xad] = function () {\n        do_xor(ix & 0xff);\n    };\n    // 0xae : XOR A, (IX+n)\n    dd_instructions[0xae] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_xor(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0xb4 : OR IXH (Undocumented)\n    dd_instructions[0xb4] = function () {\n        do_or((ix >>> 8) & 0xff);\n    };\n    // 0xb5 : OR IXL (Undocumented)\n    dd_instructions[0xb5] = function () {\n        do_or(ix & 0xff);\n    };\n    // 0xb6 : OR A, (IX+n)\n    dd_instructions[0xb6] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_or(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0xbc : CP IXH (Undocumented)\n    dd_instructions[0xbc] = function () {\n        do_cp((ix >>> 8) & 0xff);\n    };\n    // 0xbd : CP IXL (Undocumented)\n    dd_instructions[0xbd] = function () {\n        do_cp(ix & 0xff);\n    };\n    // 0xbe : CP A, (IX+n)\n    dd_instructions[0xbe] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_cp(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0xcb : CB Prefix (IX bit instructions)\n    dd_instructions[0xcb] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        pc = (pc + 1) & 0xffff;\n        var opcode = core.mem_read(pc), value;\n\n        // As with the \"normal\" CB prefix, we implement the DDCB prefix\n        //  by decoding the opcode directly, rather than using a table.\n        if (opcode < 0x40) {\n            // Shift and rotate instructions.\n            var ddcb_functions = [do_rlc, do_rrc, do_rl, do_rr,\n                do_sla, do_sra, do_sll, do_srl];\n\n            // Most of the opcodes in this range are not valid,\n            //  so we map this opcode onto one of the ones that is.\n            var func = ddcb_functions[(opcode & 0x38) >>> 3];\n            value = func(core.mem_read((ix + offset) & 0xffff));\n\n            core.mem_write((ix + offset) & 0xffff, value);\n        }\n        else {\n            var bit_number = (opcode & 0x38) >>> 3;\n\n            if (opcode < 0x80) {\n                // BIT\n                flags.N = 0;\n                flags.H = 1;\n                flags.Z = !(core.mem_read((ix + offset) & 0xffff) & (1 << bit_number)) ? 1 : 0;\n                flags.P = flags.Z;\n                flags.S = ((bit_number === 7) && !flags.Z) ? 1 : 0;\n            }\n            else if (opcode < 0xc0) {\n                // RES\n                value = core.mem_read((ix + offset) & 0xffff) & ~(1 << bit_number) & 0xff;\n                core.mem_write((ix + offset) & 0xffff, value);\n            }\n            else {\n                // SET\n                value = core.mem_read((ix + offset) & 0xffff) | (1 << bit_number);\n                core.mem_write((ix + offset) & 0xffff, value);\n            }\n        }\n\n        // This implements the undocumented shift, RES, and SET opcodes,\n        //  which write their result to memory and also to an 8080 register.\n        if (value !== undefined) {\n            if ((opcode & 0x07) === 0)\n                b = value;\n            else if ((opcode & 0x07) === 1)\n                c = value;\n            else if ((opcode & 0x07) === 2)\n                d = value;\n            else if ((opcode & 0x07) === 3)\n                e = value;\n            else if ((opcode & 0x07) === 4)\n                h = value;\n            else if ((opcode & 0x07) === 5)\n                l = value;\n            // 6 is the documented opcode, which doesn't set a register.\n            else if ((opcode & 0x07) === 7)\n                a = value;\n        }\n\n        cycle_counter += cycle_counts_cb[opcode] + 8;\n    };\n    // 0xe1 : POP IX\n    dd_instructions[0xe1] = function () {\n        ix = pop_word();\n    };\n    // 0xe3 : EX (SP), IX\n    dd_instructions[0xe3] = function () {\n        var temp = ix;\n        ix = core.mem_read(sp);\n        ix |= core.mem_read((sp + 1) & 0xffff) << 8;\n        core.mem_write(sp, temp & 0xff);\n        core.mem_write((sp + 1) & 0xffff, (temp >>> 8) & 0xff);\n    };\n    // 0xe5 : PUSH IX\n    dd_instructions[0xe5] = function () {\n        push_word(ix);\n    };\n    // 0xe9 : JP (IX)\n    dd_instructions[0xe9] = function () {\n        pc = (ix - 1) & 0xffff;\n    };\n    // 0xf9 : LD SP, IX\n    dd_instructions[0xf9] = function () {\n        sp = ix;\n    };\n\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// These tables contain the number of T cycles used for each instruction.\n    /// In a few special cases, such as conditional control flow instructions,\n    ///  additional cycles might be added to these values.\n    /// The total number of cycles is the return value of run_instruction().\n    ///////////////////////////////////////////////////////////////////////////////\n    let cycle_counts = [\n        4, 10, 7, 6, 4, 4, 7, 4, 4, 11, 7, 6, 4, 4, 7, 4,\n        8, 10, 7, 6, 4, 4, 7, 4, 12, 11, 7, 6, 4, 4, 7, 4,\n        7, 10, 16, 6, 4, 4, 7, 4, 7, 11, 16, 6, 4, 4, 7, 4,\n        7, 10, 13, 6, 11, 11, 10, 4, 7, 11, 13, 6, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        7, 7, 7, 7, 7, 7, 4, 7, 4, 4, 4, 4, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        5, 10, 10, 10, 10, 11, 7, 11, 5, 10, 10, 0, 10, 17, 7, 11,\n        5, 10, 10, 11, 10, 11, 7, 11, 5, 4, 10, 11, 10, 0, 7, 11,\n        5, 10, 10, 19, 10, 11, 7, 11, 5, 4, 10, 4, 10, 0, 7, 11,\n        5, 10, 10, 4, 10, 11, 7, 11, 5, 6, 10, 4, 10, 0, 7, 11\n    ];\n\n    let cycle_counts_ed = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        12, 12, 15, 20, 8, 14, 8, 9, 12, 12, 15, 20, 8, 14, 8, 9,\n        12, 12, 15, 20, 8, 14, 8, 9, 12, 12, 15, 20, 8, 14, 8, 9,\n        12, 12, 15, 20, 8, 14, 8, 18, 12, 12, 15, 20, 8, 14, 8, 18,\n        12, 12, 15, 20, 8, 14, 8, 0, 12, 12, 15, 20, 8, 14, 8, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        16, 16, 16, 16, 0, 0, 0, 0, 16, 16, 16, 16, 0, 0, 0, 0,\n        16, 16, 16, 16, 0, 0, 0, 0, 16, 16, 16, 16, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    ];\n\n    let cycle_counts_cb = [\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 12, 8, 8, 8, 8, 8, 8, 8, 12, 8,\n        8, 8, 8, 8, 8, 8, 12, 8, 8, 8, 8, 8, 8, 8, 12, 8,\n        8, 8, 8, 8, 8, 8, 12, 8, 8, 8, 8, 8, 8, 8, 12, 8,\n        8, 8, 8, 8, 8, 8, 12, 8, 8, 8, 8, 8, 8, 8, 12, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8\n    ];\n\n    let cycle_counts_dd = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0,\n        0, 14, 20, 10, 8, 8, 11, 0, 0, 15, 20, 10, 8, 8, 11, 0,\n        0, 0, 0, 0, 23, 23, 19, 0, 0, 15, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,\n        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,\n        8, 8, 8, 8, 8, 8, 19, 8, 8, 8, 8, 8, 8, 8, 19, 8,\n        19, 19, 19, 19, 19, 19, 0, 19, 0, 0, 0, 0, 8, 8, 19, 0,\n        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,\n        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,\n        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,\n        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 14, 0, 23, 0, 15, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0\n    ];\n\n    // There's tons of stuff in this object,\n    //  but only these three functions are the public API.\n    return {\n        getState,\n        setState,\n        reset,\n        reset1,\n        run_instruction,\n        interrupt,\n    };\n}","\n/**\n * Parser/writer for the \"Intel hex\" format.\n */\n\n/*\n * A regexp that matches lines in a .hex file.\n *\n * One hexadecimal character is matched by \"[0-9A-Fa-f]\".\n * Two hex characters are matched by \"[0-9A-Fa-f]{2}\"\n * Eight or more hex characters are matched by \"[0-9A-Fa-f]{8,}\"\n * A capture group of two hex characters is \"([0-9A-Fa-f]{2})\"\n *\n * Record mark         :\n * 8 or more hex chars  ([0-9A-Fa-f]{8,})\n * Checksum                              ([0-9A-Fa-f]{2})\n * Optional newline                                      (?:\\r\\n|\\r|\\n|)\n */\nconst hexLineRegexp = /:([0-9A-Fa-f]{8,})([0-9A-Fa-f]{2})(?:\\r\\n|\\r|\\n|)/g;\n\n\n// Takes a Uint8Array as input,\n// Returns an integer in the 0-255 range.\nfunction checksum(bytes) {\n    return (-bytes.reduce((sum, v)=>sum + v, 0)) & 0xFF;\n}\n\n// Takes two Uint8Arrays as input,\n// Returns an integer in the 0-255 range.\nfunction checksumTwo(array1, array2) {\n    const partial1 = array1.reduce((sum, v)=>sum + v, 0);\n    const partial2 = array2.reduce((sum, v)=>sum + v, 0);\n    return -( partial1 + partial2 ) & 0xFF;\n}\n\n\n// Trivial utility. Converts a number to hex and pads with zeroes up to 2 characters.\nfunction hexpad(number) {\n    return number.toString(16).toUpperCase().padStart(2, '0');\n}\n\n\n// Polyfill as per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\nNumber.isInteger = Number.isInteger || function(value) {\n    return typeof value === 'number' &&\n    isFinite(value) &&\n    Math.floor(value) === value;\n};\n\n\n/**\n * @class MemoryMap\n *\n * Represents the contents of a memory layout, with main focus into (possibly sparse) blocks of data.\n *<br/>\n * A {@linkcode MemoryMap} acts as a subclass of\n * {@linkcode https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Map|Map}.\n * In every entry of it, the key is the starting address of a data block (an integer number),\n * and the value is the <tt>Uint8Array</tt> with the data for that block.\n *<br/>\n * The main rationale for this is that a .hex file can contain a single block of contiguous\n * data starting at memory address 0 (and it's the common case for simple .hex files),\n * but complex files with several non-contiguous data blocks are also possible, thus\n * the need for a data structure on top of the <tt>Uint8Array</tt>s.\n *<br/>\n * In order to parse <tt>.hex</tt> files, use the {@linkcode MemoryMap.fromHex} <em>static</em> factory\n * method. In order to write <tt>.hex</tt> files, create a new {@linkcode MemoryMap} and call\n * its {@linkcode MemoryMap.asHexString} method.\n *\n * @extends Map\n * @example\n * import MemoryMap from 'nrf-intel-hex';\n *\n * let memMap1 = new MemoryMap();\n * let memMap2 = new MemoryMap([[0, new Uint8Array(1,2,3,4)]]);\n * let memMap3 = new MemoryMap({0: new Uint8Array(1,2,3,4)});\n * let memMap4 = new MemoryMap({0xCF0: new Uint8Array(1,2,3,4)});\n */\nclass MemoryMap {\n    /**\n     * @param {Iterable} blocks The initial value for the memory blocks inside this\n     * <tt>MemoryMap</tt>. All keys must be numeric, and all values must be instances of\n     * <tt>Uint8Array</tt>. Optionally it can also be a plain <tt>Object</tt> with\n     * only numeric keys.\n     */\n    constructor(blocks) {\n        this._blocks = new Map();\n\n        if (blocks && typeof blocks[Symbol.iterator] === 'function') {\n            for (const tuple of blocks) {\n                if (!(tuple instanceof Array) || tuple.length !== 2) {\n                    throw new Error('First parameter to MemoryMap constructor must be an iterable of [addr, bytes] or undefined');\n                }\n                this.set(tuple[0], tuple[1]);\n            }\n        } else if (typeof blocks === 'object') {\n            // Try iterating through the object's keys\n            const addrs = Object.keys(blocks);\n            for (const addr of addrs) {\n                this.set(parseInt(addr), blocks[addr]);\n            }\n\n        } else if (blocks !== undefined && blocks !== null) {\n            throw new Error('First parameter to MemoryMap constructor must be an iterable of [addr, bytes] or undefined');\n        }\n    }\n\n    set(addr, value) {\n        if (!Number.isInteger(addr)) {\n            throw new Error('Address passed to MemoryMap is not an integer');\n        }\n        if (addr < 0) {\n            throw new Error('Address passed to MemoryMap is negative');\n        }\n        if (!(value instanceof Uint8Array)) {\n            throw new Error('Bytes passed to MemoryMap are not an Uint8Array');\n        }\n        return this._blocks.set(addr, value);\n    }\n    // Delegate the following to the 'this._blocks' Map:\n    get(addr)    { return this._blocks.get(addr);    }\n    clear()      { return this._blocks.clear();      }\n    delete(addr) { return this._blocks.delete(addr); }\n    entries()    { return this._blocks.entries();    }\n    forEach(callback, that) { return this._blocks.forEach(callback, that); }\n    has(addr)    { return this._blocks.has(addr);    }\n    keys()       { return this._blocks.keys();       }\n    values()     { return this._blocks.values();     }\n    get size()   { return this._blocks.size;         }\n    [Symbol.iterator]() { return this._blocks[Symbol.iterator](); }\n\n\n    /**\n     * Parses a string containing data formatted in \"Intel HEX\" format, and\n     * returns an instance of {@linkcode MemoryMap}.\n     *<br/>\n     * The insertion order of keys in the {@linkcode MemoryMap} is guaranteed to be strictly\n     * ascending. In other words, when iterating through the {@linkcode MemoryMap}, the addresses\n     * will be ordered in ascending order.\n     *<br/>\n     * The parser has an opinionated behaviour, and will throw a descriptive error if it\n     * encounters some malformed input. Check the project's\n     * {@link https://github.com/NordicSemiconductor/nrf-intel-hex#Features|README file} for details.\n     *<br/>\n     * If <tt>maxBlockSize</tt> is given, any contiguous data block larger than that will\n     * be split in several blocks.\n     *\n     * @param {String} hexText The contents of a .hex file.\n     * @param {Number} [maxBlockSize=Infinity] Maximum size of the returned <tt>Uint8Array</tt>s.\n     *\n     * @return {MemoryMap}\n     *\n     * @example\n     * import MemoryMap from 'nrf-intel-hex';\n     *\n     * let intelHexString =\n     *     \":100000000102030405060708090A0B0C0D0E0F1068\\n\" +\n     *     \":00000001FF\";\n     *\n     * let memMap = MemoryMap.fromHex(intelHexString);\n     *\n     * for (let [address, dataBlock] of memMap) {\n     *     console.log('Data block at ', address, ', bytes: ', dataBlock);\n     * }\n     */\n    static fromHex(hexText, maxBlockSize = Infinity) {\n        const blocks = new MemoryMap();\n\n        let lastCharacterParsed = 0;\n        let matchResult;\n        let recordCount = 0;\n\n        // Upper Linear Base Address, the 16 most significant bits (2 bytes) of\n        // the current 32-bit (4-byte) address\n        // In practice this is a offset that is summed to the \"load offset\" of the\n        // data records\n        let ulba = 0;\n\n        hexLineRegexp.lastIndex = 0; // Reset the regexp, if not it would skip content when called twice\n\n        while ((matchResult = hexLineRegexp.exec(hexText)) !== null) {\n            recordCount++;\n\n            // By default, a regexp loop ignores gaps between matches, but\n            // we want to be aware of them.\n            if (lastCharacterParsed !== matchResult.index) {\n                throw new Error(\n                    'Malformed hex file: Could not parse between characters ' +\n                    lastCharacterParsed +\n                    ' and ' +\n                    matchResult.index +\n                    ' (\"' +\n                    hexText.substring(lastCharacterParsed, Math.min(matchResult.index, lastCharacterParsed + 16)).trim() +\n                    '\")');\n            }\n            lastCharacterParsed = hexLineRegexp.lastIndex;\n\n            // Give pretty names to the match's capture groups\n            const [, recordStr, recordChecksum] = matchResult;\n\n            // String to Uint8Array - https://stackoverflow.com/questions/43131242/how-to-convert-a-hexademical-string-of-data-to-an-arraybuffer-in-javascript\n            const recordBytes = new Uint8Array(recordStr.match(/[\\da-f]{2}/gi).map((h)=>parseInt(h, 16)));\n\n            const recordLength = recordBytes[0];\n            if (recordLength + 4 !== recordBytes.length) {\n                throw new Error('Mismatched record length at record ' + recordCount + ' (' + matchResult[0].trim() + '), expected ' + (recordLength) + ' data bytes but actual length is ' + (recordBytes.length - 4));\n            }\n\n            const cs = checksum(recordBytes);\n            if (parseInt(recordChecksum, 16) !== cs) {\n                throw new Error('Checksum failed at record ' + recordCount + ' (' + matchResult[0].trim() + '), should be ' + cs.toString(16) );\n            }\n\n            const offset = (recordBytes[1] << 8) + recordBytes[2];\n            const recordType = recordBytes[3];\n            const data = recordBytes.subarray(4);\n\n            if (recordType === 0) {\n                // Data record, contains data\n                // Create a new block, at (upper linear base address + offset)\n                if (blocks.has(ulba + offset)) {\n                    throw new Error('Duplicated data at record ' + recordCount + ' (' + matchResult[0].trim() + ')');\n                }\n                if (offset + data.length > 0x10000) {\n                    throw new Error(\n                        'Data at record ' +\n                        recordCount +\n                        ' (' +\n                        matchResult[0].trim() +\n                        ') wraps over 0xFFFF. This would trigger ambiguous behaviour. Please restructure your data so that for every record the data offset plus the data length do not exceed 0xFFFF.');\n                }\n\n                blocks.set( ulba + offset, data );\n\n            } else {\n\n                // All non-data records must have a data offset of zero\n                if (offset !== 0) {\n                    throw new Error('Record ' + recordCount + ' (' + matchResult[0].trim() + ') must have 0000 as data offset.');\n                }\n\n                switch (recordType) {\n                case 1: // EOF\n                    if (lastCharacterParsed !== hexText.length) {\n                        // This record should be at the very end of the string\n                        throw new Error('There is data after an EOF record at record ' + recordCount);\n                    }\n\n                    return blocks.join(maxBlockSize);\n\n                case 2: // Extended Segment Address Record\n                    // Sets the 16 most significant bits of the 20-bit Segment Base\n                    // Address for the subsequent data.\n                    ulba = ((data[0] << 8) + data[1]) << 4;\n                    break;\n\n                case 3: // Start Segment Address Record\n                    // Do nothing. Record type 3 only applies to 16-bit Intel CPUs,\n                    // where it should reset the program counter (CS+IP CPU registers)\n                    break;\n\n                case 4: // Extended Linear Address Record\n                    // Sets the 16 most significant (upper) bits of the 32-bit Linear Address\n                    // for the subsequent data\n                    ulba = ((data[0] << 8) + data[1]) << 16;\n                    break;\n\n                case 5: // Start Linear Address Record\n                    // Do nothing. Record type 5 only applies to 32-bit Intel CPUs,\n                    // where it should reset the program counter (EIP CPU register)\n                    // It might have meaning for other CPU architectures\n                    // (see http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/ka9903.html )\n                    // but will be ignored nonetheless.\n                    break;\n                default:\n                    throw new Error('Invalid record type 0x' + hexpad(recordType) + ' at record ' + recordCount + ' (should be between 0x00 and 0x05)');\n                }\n            }\n        }\n\n        if (recordCount) {\n            throw new Error('No EOF record at end of file');\n        } else {\n            throw new Error('Malformed .hex file, could not parse any registers');\n        }\n    }\n\n\n    /**\n     * Returns a <strong>new</strong> instance of {@linkcode MemoryMap}, containing\n     * the same data, but concatenating together those memory blocks that are adjacent.\n     *<br/>\n     * The insertion order of keys in the {@linkcode MemoryMap} is guaranteed to be strictly\n     * ascending. In other words, when iterating through the {@linkcode MemoryMap}, the addresses\n     * will be ordered in ascending order.\n     *<br/>\n     * If <tt>maxBlockSize</tt> is given, blocks will be concatenated together only\n     * until the joined block reaches this size in bytes. This means that the output\n     * {@linkcode MemoryMap} might have more entries than the input one.\n     *<br/>\n     * If there is any overlap between blocks, an error will be thrown.\n     *<br/>\n     * The returned {@linkcode MemoryMap} will use newly allocated memory.\n     *\n     * @param {Number} [maxBlockSize=Infinity] Maximum size of the <tt>Uint8Array</tt>s in the\n     * returned {@linkcode MemoryMap}.\n     *\n     * @return {MemoryMap}\n     */\n    join(maxBlockSize = Infinity) {\n\n        // First pass, create a Map of addresslength of contiguous blocks\n        const sortedKeys = Array.from(this.keys()).sort((a,b)=>a-b);\n        const blockSizes = new Map();\n        let lastBlockAddr = -1;\n        let lastBlockEndAddr = -1;\n\n        for (let i=0,l=sortedKeys.length; i<l; i++) {\n            const blockAddr = sortedKeys[i];\n            const blockLength = this.get(sortedKeys[i]).length;\n\n            if (lastBlockEndAddr === blockAddr && (lastBlockEndAddr - lastBlockAddr) < maxBlockSize) {\n                // Grow when the previous end address equals the current,\n                // and we don't go over the maximum block size.\n                blockSizes.set(lastBlockAddr, blockSizes.get(lastBlockAddr) + blockLength);\n                lastBlockEndAddr += blockLength;\n            } else if (lastBlockEndAddr <= blockAddr) {\n                // Else mark a new block.\n                blockSizes.set(blockAddr, blockLength);\n                lastBlockAddr = blockAddr;\n                lastBlockEndAddr = blockAddr + blockLength;\n            } else {\n                throw new Error('Overlapping data around address 0x' + blockAddr.toString(16));\n            }\n        }\n\n        // Second pass: allocate memory for the contiguous blocks and copy data around.\n        const mergedBlocks = new MemoryMap();\n        let mergingBlock;\n        let mergingBlockAddr = -1;\n        for (let i=0,l=sortedKeys.length; i<l; i++) {\n            const blockAddr = sortedKeys[i];\n            if (blockSizes.has(blockAddr)) {\n                mergingBlock = new Uint8Array(blockSizes.get(blockAddr));\n                mergedBlocks.set(blockAddr, mergingBlock);\n                mergingBlockAddr = blockAddr;\n            }\n            mergingBlock.set(this.get(blockAddr), blockAddr - mergingBlockAddr);\n        }\n\n        return mergedBlocks;\n    }\n\n    /**\n     * Given a {@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Map|<tt>Map</tt>}\n     * of {@linkcode MemoryMap}s, indexed by a alphanumeric ID,\n     * returns a <tt>Map</tt> of address to tuples (<tt>Arrays</tt>s of length 2) of the form\n     * <tt>(id, Uint8Array)</tt>s.\n     *<br/>\n     * The scenario for using this is having several {@linkcode MemoryMap}s, from several calls to\n     * {@link module:nrf-intel-hex~hexToArrays|hexToArrays}, each having a different identifier.\n     * This function locates where those memory block sets overlap, and returns a <tt>Map</tt>\n     * containing addresses as keys, and arrays as values. Each array will contain 1 or more\n     * <tt>(id, Uint8Array)</tt> tuples: the identifier of the memory block set that has\n     * data in that region, and the data itself. When memory block sets overlap, there will\n     * be more than one tuple.\n     *<br/>\n     * The <tt>Uint8Array</tt>s in the output are\n     * {@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray|subarrays}\n     * of the input data; new memory is <strong>not</strong> allocated for them.\n     *<br/>\n     * The insertion order of keys in the output <tt>Map</tt> is guaranteed to be strictly\n     * ascending. In other words, when iterating through the <tt>Map</tt>, the addresses\n     * will be ordered in ascending order.\n     *<br/>\n     * When two blocks overlap, the corresponding array of tuples will have the tuples ordered\n     * in the insertion order of the input <tt>Map</tt> of block sets.\n     *<br/>\n     *\n     * @param {Map.MemoryMap} memoryMaps The input memory block sets\n     *\n     * @example\n     * import MemoryMap from 'nrf-intel-hex';\n     *\n     * let memMap1 = MemoryMap.fromHex( hexdata1 );\n     * let memMap2 = MemoryMap.fromHex( hexdata2 );\n     * let memMap3 = MemoryMap.fromHex( hexdata3 );\n     *\n     * let maps = new Map([\n     *  ['file A', blocks1],\n     *  ['file B', blocks2],\n     *  ['file C', blocks3]\n     * ]);\n     *\n     * let overlappings = MemoryMap.overlapMemoryMaps(maps);\n     *\n     * for (let [address, tuples] of overlappings) {\n     *     // if 'tuples' has length > 1, there is an overlap starting at 'address'\n     *\n     *     for (let [address, tuples] of overlappings) {\n     *         let [id, bytes] = tuple;\n     *         // 'id' in this example is either 'file A', 'file B' or 'file C'\n     *     }\n     * }\n     * @return {Map.Array<mixed,Uint8Array>} The map of possibly overlapping memory blocks\n     */\n    static overlapMemoryMaps(memoryMaps) {\n        // First pass: create a list of addresses where any block starts or ends.\n        const cuts = new Set();\n        for (const [, blocks] of memoryMaps) {\n            for (const [address, block] of blocks) {\n                cuts.add(address);\n                cuts.add(address + block.length);\n            }\n        }\n\n        const orderedCuts = Array.from(cuts.values()).sort((a,b)=>a-b);\n        const overlaps = new Map();\n\n        // Second pass: iterate through the cuts, get slices of every intersecting blockset\n        for (let i=0, l=orderedCuts.length-1; i<l; i++) {\n            const cut = orderedCuts[i];\n            const nextCut = orderedCuts[i+1];\n            const tuples = [];\n\n            for (const [setId, blocks] of memoryMaps) {\n                // Find the block with the highest address that is equal or lower to\n                // the current cut (if any)\n                const blockAddr = Array.from(blocks.keys()).reduce((acc, val)=>{\n                    if (val > cut) {\n                        return acc;\n                    }\n                    return Math.max( acc, val );\n                }, -1);\n\n                if (blockAddr !== -1) {\n                    const block = blocks.get(blockAddr);\n                    const subBlockStart = cut - blockAddr;\n                    const subBlockEnd = nextCut - blockAddr;\n\n                    if (subBlockStart < block.length) {\n                        tuples.push([ setId, block.subarray(subBlockStart, subBlockEnd) ]);\n                    }\n                }\n            }\n\n            if (tuples.length) {\n                overlaps.set(cut, tuples);\n            }\n        }\n\n        return overlaps;\n    }\n\n\n    /**\n     * Given the output of the {@linkcode MemoryMap.overlapMemoryMaps|overlapMemoryMaps}\n     * (a <tt>Map</tt> of address to an <tt>Array</tt> of <tt>(id, Uint8Array)</tt> tuples),\n     * returns a {@linkcode MemoryMap}. This discards the IDs in the process.\n     *<br/>\n     * The output <tt>Map</tt> contains as many entries as the input one (using the same addresses\n     * as keys), but the value for each entry will be the <tt>Uint8Array</tt> of the <b>last</b>\n     * tuple for each address in the input data.\n     *<br/>\n     * The scenario is wanting to join together several parsed .hex files, not worrying about\n     * their overlaps.\n     *<br/>\n     *\n     * @param {Map.Array<mixed,Uint8Array>} overlaps The (possibly overlapping) input memory blocks\n     * @return {MemoryMap} The flattened memory blocks\n     */\n    static flattenOverlaps(overlaps) {\n        return new MemoryMap(\n            Array.from(overlaps.entries()).map(([address, tuples]) => {\n                return [address, tuples[tuples.length - 1][1] ];\n            })\n        );\n    }\n\n\n    /**\n     * Returns a new instance of {@linkcode MemoryMap}, where:\n     *\n     * <ul>\n     *  <li>Each key (the start address of each <tt>Uint8Array</tt>) is a multiple of\n     *    <tt>pageSize</tt></li>\n     *  <li>The size of each <tt>Uint8Array</tt> is exactly <tt>pageSize</tt></li>\n     *  <li>Bytes from the input map to bytes in the output</li>\n     *  <li>Bytes not in the input are replaced by a padding value</li>\n     * </ul>\n     *<br/>\n     * The scenario is wanting to prepare pages of bytes for a write operation, where the write\n     * operation affects a whole page/sector at once.\n     *<br/>\n     * The insertion order of keys in the output {@linkcode MemoryMap} is guaranteed\n     * to be strictly ascending. In other words, when iterating through the\n     * {@linkcode MemoryMap}, the addresses will be ordered in ascending order.\n     *<br/>\n     * The <tt>Uint8Array</tt>s in the output will be newly allocated.\n     *<br/>\n     *\n     * @param {Number} [pageSize=1024] The size of the output pages, in bytes\n     * @param {Number} [pad=0xFF] The byte value to use for padding\n     * @return {MemoryMap}\n     */\n    paginate( pageSize=1024, pad=0xFF) {\n        if (pageSize <= 0) {\n            throw new Error('Page size must be greater than zero');\n        }\n        const outPages = new MemoryMap();\n        let page;\n\n        const sortedKeys = Array.from(this.keys()).sort((a,b)=>a-b);\n\n        for (let i=0,l=sortedKeys.length; i<l; i++) {\n            const blockAddr = sortedKeys[i];\n            const block = this.get(blockAddr);\n            const blockLength = block.length;\n            const blockEnd = blockAddr + blockLength;\n\n            for (let pageAddr = blockAddr - (blockAddr % pageSize); pageAddr < blockEnd; pageAddr += pageSize) {\n                page = outPages.get(pageAddr);\n                if (!page) {\n                    page = new Uint8Array(pageSize);\n                    page.fill(pad);\n                    outPages.set(pageAddr, page);\n                }\n\n                const offset = pageAddr - blockAddr;\n                let subBlock;\n                if (offset <= 0) {\n                    // First page which intersects the block\n                    subBlock = block.subarray(0, Math.min(pageSize + offset, blockLength));\n                    page.set(subBlock, -offset);\n                } else {\n                    // Any other page which intersects the block\n                    subBlock = block.subarray(offset, offset + Math.min(pageSize, blockLength - offset));\n                    page.set(subBlock, 0);\n                }\n            }\n        }\n\n        return outPages;\n    }\n\n\n    /**\n     * Locates the <tt>Uint8Array</tt> which contains the given offset,\n     * and returns the four bytes held at that offset, as a 32-bit unsigned integer.\n     *\n     *<br/>\n     * Behaviour is similar to {@linkcode https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint32|DataView.prototype.getUint32},\n     * except that this operates over a {@linkcode MemoryMap} instead of\n     * over an <tt>ArrayBuffer</tt>, and that this may return <tt>undefined</tt> if\n     * the address is not <em>entirely</em> contained within one of the <tt>Uint8Array</tt>s.\n     *<br/>\n     *\n     * @param {Number} offset The memory offset to read the data\n     * @param {Boolean} [littleEndian=false] Whether to fetch the 4 bytes as a little- or big-endian integer\n     * @return {Number|undefined} An unsigned 32-bit integer number\n     */\n    getUint32(offset, littleEndian) {\n        const keys = Array.from(this.keys());\n\n        for (let i=0,l=keys.length; i<l; i++) {\n            const blockAddr = keys[i];\n            const block = this.get(blockAddr);\n            const blockLength = block.length;\n            const blockEnd = blockAddr + blockLength;\n\n            if (blockAddr <= offset && (offset+4) <= blockEnd) {\n                return (new DataView(block.buffer, offset - blockAddr, 4)).getUint32(0, littleEndian);\n            }\n        }\n        return;\n    }\n\n\n    /**\n     * Returns a <tt>String</tt> of text representing a .hex file.\n     * <br/>\n     * The writer has an opinionated behaviour. Check the project's\n     * {@link https://github.com/NordicSemiconductor/nrf-intel-hex#Features|README file} for details.\n     *\n     * @param {Number} [lineSize=16] Maximum number of bytes to be encoded in each data record.\n     * Must have a value between 1 and 255, as per the specification.\n     *\n     * @return {String} String of text with the .hex representation of the input binary data\n     *\n     * @example\n     * import MemoryMap from 'nrf-intel-hex';\n     *\n     * let memMap = new MemoryMap();\n     * let bytes = new Uint8Array(....);\n     * memMap.set(0x0FF80000, bytes); // The block with 'bytes' will start at offset 0x0FF80000\n     *\n     * let string = memMap.asHexString();\n     */\n    asHexString(lineSize = 16) {\n        let lowAddress  = 0;    // 16 least significant bits of the current addr\n        let highAddress = -1 << 16; // 16 most significant bits of the current addr\n        const records = [];\n        if (lineSize <=0) {\n            throw new Error('Size of record must be greater than zero');\n        } else if (lineSize > 255) {\n            throw new Error('Size of record must be less than 256');\n        }\n\n        // Placeholders\n        const offsetRecord = new Uint8Array(6);\n        const recordHeader = new Uint8Array(4);\n\n        const sortedKeys = Array.from(this.keys()).sort((a,b)=>a-b);\n        for (let i=0,l=sortedKeys.length; i<l; i++) {\n            const blockAddr = sortedKeys[i];\n            const block = this.get(blockAddr);\n\n            // Sanity checks\n            if (!(block instanceof Uint8Array)) {\n                throw new Error('Block at offset ' + blockAddr + ' is not an Uint8Array');\n            }\n            if (blockAddr < 0) {\n                throw new Error('Block at offset ' + blockAddr + ' has a negative thus invalid address');\n            }\n            const blockSize = block.length;\n            if (!blockSize) { continue; }   // Skip zero-length blocks\n\n\n            if (blockAddr > (highAddress + 0xFFFF)) {\n                // Insert a new 0x04 record to jump to a new 64KiB block\n\n                // Round up the least significant 16 bits - no bitmasks because they trigger\n                // base-2 negative numbers, whereas subtracting the modulo maintains precision\n                highAddress = blockAddr - blockAddr % 0x10000;\n                lowAddress = 0;\n\n                offsetRecord[0] = 2;    // Length\n                offsetRecord[1] = 0;    // Load offset, high byte\n                offsetRecord[2] = 0;    // Load offset, low byte\n                offsetRecord[3] = 4;    // Record type\n                offsetRecord[4] = highAddress >> 24;    // new address offset, high byte\n                offsetRecord[5] = highAddress >> 16;    // new address offset, low byte\n\n                records.push(\n                    ':' +\n                    Array.prototype.map.call(offsetRecord, hexpad).join('') +\n                    hexpad(checksum(offsetRecord))\n                );\n            }\n\n            if (blockAddr < (highAddress + lowAddress)) {\n                throw new Error(\n                    'Block starting at 0x' +\n                    blockAddr.toString(16) +\n                    ' overlaps with a previous block.');\n            }\n\n            lowAddress = blockAddr % 0x10000;\n            let blockOffset = 0;\n            const blockEnd = blockAddr + blockSize;\n            if (blockEnd > 0xFFFFFFFF) {\n                throw new Error('Data cannot be over 0xFFFFFFFF');\n            }\n\n            // Loop for every 64KiB memory segment that spans this block\n            while (highAddress + lowAddress < blockEnd) {\n\n                if (lowAddress > 0xFFFF) {\n                    // Insert a new 0x04 record to jump to a new 64KiB block\n                    highAddress += 1 << 16; // Increase by one\n                    lowAddress = 0;\n\n                    offsetRecord[0] = 2;    // Length\n                    offsetRecord[1] = 0;    // Load offset, high byte\n                    offsetRecord[2] = 0;    // Load offset, low byte\n                    offsetRecord[3] = 4;    // Record type\n                    offsetRecord[4] = highAddress >> 24;    // new address offset, high byte\n                    offsetRecord[5] = highAddress >> 16;    // new address offset, low byte\n\n                    records.push(\n                        ':' +\n                        Array.prototype.map.call(offsetRecord, hexpad).join('') +\n                        hexpad(checksum(offsetRecord))\n                    );\n                }\n\n                let recordSize = -1;\n                // Loop for every record for that spans the current 64KiB memory segment\n                while (lowAddress < 0x10000 && recordSize) {\n                    recordSize = Math.min(\n                        lineSize,                            // Normal case\n                        blockEnd - highAddress - lowAddress, // End of block\n                        0x10000 - lowAddress                 // End of low addresses\n                    );\n\n                    if (recordSize) {\n\n                        recordHeader[0] = recordSize;   // Length\n                        recordHeader[1] = lowAddress >> 8;    // Load offset, high byte\n                        recordHeader[2] = lowAddress;    // Load offset, low byte\n                        recordHeader[3] = 0;    // Record type\n\n                        const subBlock = block.subarray(blockOffset, blockOffset + recordSize);   // Data bytes for this record\n\n                        records.push(\n                            ':' +\n                            Array.prototype.map.call(recordHeader, hexpad).join('') +\n                            Array.prototype.map.call(subBlock, hexpad).join('') +\n                            hexpad(checksumTwo(recordHeader, subBlock))\n                        );\n\n                        blockOffset += recordSize;\n                        lowAddress += recordSize;\n                    }\n                }\n            }\n        }\n\n        records.push(':00000001FF');    // EOF record\n\n        return records.join('\\n');\n    }\n\n\n    /**\n     * Performs a deep copy of the current {@linkcode MemoryMap}, returning a new one\n     * with exactly the same contents, but allocating new memory for each of its\n     * <tt>Uint8Array</tt>s.\n     *\n     * @return {MemoryMap}\n     */\n    clone() {\n        const cloned = new MemoryMap();\n\n        for (let [addr, value] of this) {\n            cloned.set(addr, new Uint8Array(value));\n        }\n\n        return cloned;\n    }\n\n\n    /**\n     * Given one <tt>Uint8Array</tt>, looks through its contents and returns a new\n     * {@linkcode MemoryMap}, stripping away those regions where there are only\n     * padding bytes.\n     * <br/>\n     * The start of the input <tt>Uint8Array</tt> is assumed to be offset zero for the output.\n     * <br/>\n     * The use case here is dumping memory from a working device and try to see the\n     * \"interesting\" memory regions it has. This assumes that there is a constant,\n     * predefined padding byte value being used in the \"non-interesting\" regions.\n     * In other words: this will work as long as the dump comes from a flash memory\n     * which has been previously erased (thus <tt>0xFF</tt>s for padding), or from a\n     * previously blanked HDD (thus <tt>0x00</tt>s for padding).\n     * <br/>\n     * This method uses <tt>subarray</tt> on the input data, and thus does not allocate memory\n     * for the <tt>Uint8Array</tt>s.\n     *\n     * @param {Uint8Array} bytes The input data\n     * @param {Number} [padByte=0xFF] The value of the byte assumed to be used as padding\n     * @param {Number} [minPadLength=64] The minimum number of consecutive pad bytes to\n     * be considered actual padding\n     *\n     * @return {MemoryMap}\n     */\n    static fromPaddedUint8Array(bytes, padByte=0xFF, minPadLength=64) {\n\n        if (!(bytes instanceof Uint8Array)) {\n            throw new Error('Bytes passed to fromPaddedUint8Array are not an Uint8Array');\n        }\n\n        // The algorithm used is nave and checks every byte.\n        // An obvious optimization would be to implement Boyer-Moore\n        // (see https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm )\n        // or otherwise start skipping up to minPadLength bytes when going through a non-pad\n        // byte.\n        // Anyway, we could expect a lot of cases where there is a majority of pad bytes,\n        // and the algorithm should check most of them anyway, so the perf gain is questionable.\n\n        const memMap = new MemoryMap();\n        let consecutivePads = 0;\n        let lastNonPad = -1;\n        let firstNonPad = 0;\n        let skippingBytes = false;\n        const l = bytes.length;\n\n        for (let addr = 0; addr < l; addr++) {\n            const byte = bytes[addr];\n\n            if (byte === padByte) {\n                consecutivePads++;\n                if (consecutivePads >= minPadLength) {\n                    // Edge case: ignore writing a zero-length block when skipping\n                    // bytes at the beginning of the input\n                    if (lastNonPad !== -1) {\n                        /// Add the previous block to the result memMap\n                        memMap.set(firstNonPad, bytes.subarray(firstNonPad, lastNonPad+1));\n                    }\n\n                    skippingBytes = true;\n                }\n            } else {\n                if (skippingBytes) {\n                    skippingBytes = false;\n                    firstNonPad = addr;\n                }\n                lastNonPad = addr;\n                consecutivePads = 0;\n            }\n        }\n\n        // At EOF, add the last block if not skipping bytes already (and input not empty)\n        if (!skippingBytes && lastNonPad !== -1) {\n            memMap.set(firstNonPad, bytes.subarray(firstNonPad, l));\n        }\n\n        return memMap;\n    }\n\n\n    /**\n     * Returns a new instance of {@linkcode MemoryMap}, containing only data between\n     * the addresses <tt>address</tt> and <tt>address + length</tt>.\n     * Behaviour is similar to {@linkcode https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/slice|Array.prototype.slice},\n     * in that the return value is a portion of the current {@linkcode MemoryMap}.\n     *\n     * <br/>\n     * The returned {@linkcode MemoryMap} might be empty.\n     *\n     * <br/>\n     * Internally, this uses <tt>subarray</tt>, so new memory is not allocated.\n     *\n     * @param {Number} address The start address of the slice\n     * @param {Number} length The length of memory map to slice out\n     * @return {MemoryMap}\n     */\n    slice(address, length = Infinity){\n        if (length < 0) {\n            throw new Error('Length of the slice cannot be negative');\n        }\n\n        const sliced = new MemoryMap();\n\n        for (let [blockAddr, block] of this) {\n            const blockLength = block.length;\n\n            if ((blockAddr + blockLength) >= address && blockAddr < (address + length)) {\n                const sliceStart = Math.max(address, blockAddr);\n                const sliceEnd = Math.min(address + length, blockAddr + blockLength);\n                const sliceLength = sliceEnd - sliceStart;\n                const relativeSliceStart = sliceStart - blockAddr;\n\n                if (sliceLength > 0) {\n                    sliced.set(sliceStart, block.subarray(relativeSliceStart, relativeSliceStart + sliceLength));\n                }\n            }\n        }\n        return sliced;\n    }\n\n    /**\n     * Returns a new instance of {@linkcode https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint32|Uint8Array}, containing only data between\n     * the addresses <tt>address</tt> and <tt>address + length</tt>. Any byte without a value\n     * in the input {@linkcode MemoryMap} will have a value of <tt>padByte</tt>.\n     *\n     * <br/>\n     * This method allocates new memory.\n     *\n     * @param {Number} address The start address of the slice\n     * @param {Number} length The length of memory map to slice out\n     * @param {Number} [padByte=0xFF] The value of the byte assumed to be used as padding\n     * @return {MemoryMap}\n     */\n    slicePad(address, length, padByte=0xFF){\n        if (length < 0) {\n            throw new Error('Length of the slice cannot be negative');\n        }\n        \n        const out = (new Uint8Array(length)).fill(padByte);\n\n        for (let [blockAddr, block] of this) {\n            const blockLength = block.length;\n\n            if ((blockAddr + blockLength) >= address && blockAddr < (address + length)) {\n                const sliceStart = Math.max(address, blockAddr);\n                const sliceEnd = Math.min(address + length, blockAddr + blockLength);\n                const sliceLength = sliceEnd - sliceStart;\n                const relativeSliceStart = sliceStart - blockAddr;\n\n                if (sliceLength > 0) {\n                    out.set(block.subarray(relativeSliceStart, relativeSliceStart + sliceLength), sliceStart - address);\n                }\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Checks whether the current memory map contains the one given as a parameter.\n     *\n     * <br/>\n     * \"Contains\" means that all the offsets that have a byte value in the given\n     * memory map have a value in the current memory map, and that the byte values\n     * are the same.\n     *\n     * <br/>\n     * An empty memory map is always contained in any other memory map.\n     *\n     * <br/>\n     * Returns boolean <tt>true</tt> if the memory map is contained, <tt>false</tt>\n     * otherwise.\n     *\n     * @param {MemoryMap} memMap The memory map to check\n     * @return {Boolean}\n     */\n    contains(memMap) {\n        for (let [blockAddr, block] of memMap) {\n\n            const blockLength = block.length;\n\n            const slice = this.slice(blockAddr, blockLength).join().get(blockAddr);\n\n            if ((!slice) || slice.length !== blockLength ) {\n                return false;\n            }\n\n            for (const i in block) {\n                if (block[i] !== slice[i]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n\n\nexport default MemoryMap;\n\n","import { Z80 } from './z80';\n// @ts-ignore: Module '\"nrf-intel-hex\"' has no default export\nimport MemoryMap from 'nrf-intel-hex';\n\nlet running = false;\nlet active = true;\nlet speed = 30;\n\nlet cycles = 0;\nconst memory = Array(0xFFFF).fill(0xFF);\nconst inPorts = Array(256).fill(0xFF);\nconst outPorts = Array(256).fill(0xFF);\n\nconst cpu = Z80({\n    mem_read: (addr:number) => memory[addr],\n    mem_write: (addr:number, value:number) => memory[addr] = value,\n    io_read: (port:number) => {\n        return inPorts[port & 0xFF];\n    },\n    io_write: (port:number, value:number) => {\n        const port1 = port & 0xFF;\n        outPorts[port1] = value;\n        updateDisplay();\n        postOutPorts(port1, value);\n    },\n});\n\nconst display = Array(6).fill(0);\n\nself.onmessage = event => {\n    if (event.data.type === 'INIT') {\n        // updateMemory(ROM);\n        cpu.reset();\n        running = true;\n        run();\n    }\n    else if (event.data.type === 'PAUSE') {\n        if (active) {\n            active = false;\n            running = false;\n        }\n        else {\n            active = true;\n            running = true;\n            run();\n        }\n    }\n    else if (event.data.type === 'RESUME') {\n    }\n    else if (event.data.type === 'RESET') {\n        console.log('resetting');\n        cpu.reset();\n        running = true;\n        run();\n    }\n    else if (event.data.type === 'SET_INPUT_VALUE') {\n        const { port, value } = event.data;\n        inPorts[port] = value;\n    }\n    else if (event.data.type === 'SET_SPEED') {\n        speed = Number(event.data.value)/100;\n        console.log('set speed', speed);\n    }\n    else if (event.data.type === 'NMI') {\n        cpu.interrupt(true, 0);\n    }\n    else if (event.data.type === 'UPDATE_MEMORY') {\n        updateMemory(event.data.value);\n        cpu.reset();\n    }\n    else if (event.data.type === 'READ_MEMORY') {\n        readMemory(event.data.from, event.data.size);\n    }\n    else if (event.data.type === 'HIDDEN') {\n        let hidden = event.data.value;\n        if (hidden) {\n            running = false;\n        }\n        else if (active) {\n            running = true;\n            run();\n        }\n        else {\n            console.log('not active');\n        }\n    }\n};\n\nfunction* runGen () {\n    while (true){\n        for (let i = 0; i < 1000 ; i++) {\n            const count = cpu.run_instruction();\n            cycles += count;\n        }\n        yield cycles;\n    }\n}\n\nlet pending = false;\nconst iter = runGen();\nfunction run() {\n    if (pending) return;\n    if (!running) return;\n    iter.next();\n    const delay = Math.floor((1 - Number(speed)) * 30);\n    if (running) {\n        pending = true;\n        setTimeout(function(){\n            pending = false;\n            run();\n        }, delay)\n    };\n}\n\nfunction updateDisplay() {\n    const digits = outPorts[1];\n    const segments = outPorts[2];\n    let mask = 0x01;\n    for (let i = 0; i < 6; i++) {\n        if (digits & mask){\n            display[i] = segments;\n        }\n        mask = mask << 1;\n    }\n}\n\nfunction getPortsBuffer(){\n    var buffer = new ArrayBuffer(4);\n    var view = new Uint8Array(buffer);\n    view[0] = outPorts[0];\n    view[1] = outPorts[1];\n    view[2] = outPorts[2];\n    return buffer;\n}\n\nfunction getDisplayBuffer(){\n    var buffer = new ArrayBuffer(6);\n    var view = new Uint8Array(buffer);\n    for (let i = 0; i < 6; i++) {\n        view[i] = display[i];\n    }\n    return buffer;\n}\n\nlet speaker = 1;\nlet wavelength = 0;\nfunction postOutPorts(port:number, value:number) {\n    const buffer = getPortsBuffer();\n    const display = getDisplayBuffer();\n\n    if (port === 1 && (value === 0x7F || value === 0xFF)) {\n        const speaker1 = value >> 7;\n        if (speaker1 === 1 && speaker === 0) {\n            wavelength = cycles;\n            cycles = 0;\n        }\n        speaker = speaker1;\n    }\n    if (cycles > 10000) wavelength = 0;\n\n    self.postMessage({\n        type: 'POST_OUTPORTS',\n        buffer,\n        display,\n        speaker,\n        wavelength,\n    // @ts-ignore: Type 'ArrayBuffer' is not assignable to type 'string' bug in type definition\n    }, [buffer, display]);\n}\n\nfunction updateMemory(rom:string) {\n    const blocks = MemoryMap.fromHex(rom);\n    for (let address of blocks.keys()) {\n        const block = blocks.get(address);\n        for (let i = address; i < address + block.length; i++) {\n            memory[i] = block[i];\n        }\n    }\n}\n\nfunction readMemory(from:number, size:number) {\n    from = 0x0000;\n    size = 0x800;\n    // let memMap = new MemoryMap();\n    let buffer = new ArrayBuffer(size);\n    let bytes = new Uint8Array(buffer);\n    for (let i = 0; i < size; i++) {\n        bytes[i] = memory[i + from]\n    }\n    // memMap.set(from, bytes);\n    // let value = memMap.asHexString();\n    self.postMessage({\n        type: 'POST_MEMORY',\n        from,\n        size,\n        buffer,\n    // @ts-ignore: Type 'ArrayBuffer' is not assignable to type 'string' bug in type definition\n    }, [buffer]);\n}\n"]}